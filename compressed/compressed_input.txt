The document appears to be a table of contents for a chapter on internet sockets, with section headings and page numbers. The sections cover various topics related to internet sockets, including:

1. Two Types of Internet Sockets (pages 6-8)
2. Low level Nonsense and Network Theory (page 8)
3. IP Addresses, structs, and Data Munging
	* IP Addresses, versions 4 and 6 (pages 10-11)
	* Subnets (page 11)
	* Port Numbers (page 12)
	* Byte Order (page 12)
	* structs (page 14)
	* IP Addresses, Part Deux (pages 16-17)
	* Private (Or Disconnected) Networks (page 17)
4. Jumping from IPv4 to IPv6 (page 19)
5. System Calls or Bust
	* getaddrinfo()—Prepare to launch! (pages 21-22)
	* socket()—Get the File Descriptor! (pages 24-25)
	* bind()—What port am I on? (page 25)
	* connect()—Hey, you! (page 27)
	* listen()—Will somebody please call me? (page 28)
	* accept()—“Thank you for calling port 3490.” (page 29)
	* send() and recv()—Talk to me, baby! (pages 30-31)
	* sendto() and recvfrom()—Talk to me, DGRAM-style (page 31)
	* close() and shutdown()—Get outta my face! (page 32)
	* getpeername()—Who are you? (page 32)
	* gethostname()—Who am I? (page 33)
6. Client-Server Background
	* A Simple Stream Server (pages 34-35)
	* A Simple Stream Client (pages 37-38)

The document does not contain any additional information beyond the section headings and page numbers.
**Chapter 6: Datagram Sockets**

* No content listed under this chapter.

**Chapter 7: Slightly Advanced Techniques**

* Section 7.1: Blocking
* Section 7.2: poll()—Synchronous I/O Multiplexing
* Section 7.3: select()—Synchronous I/O Multiplexing, Old School
* Section 7.4: Handling Partial send()s
* Section 7.5: Serialization—How to Pack Data
* Section 7.6: Son of Data Encapsulation
* Section 7.7: Broadcast Packets—Hello, World!

**Chapter 8: Common Questions**

* No content listed under this chapter.

**Chapter 9: Man Pages**

* Section 9.1: accept()
* Section 9.2: bind()
* Section 9.3: connect()
* Section 9.4: close()
* Section 9.5: getaddrinfo(), freeaddrinfo(), gai_strerror()
* Section 9.6: gethostname()
* Section 9.7: gethostbyname(), gethostbyaddr()
* Section 9.8: getnameinfo()
* Section 9.9: getpeername()
* Section 9.10: errno
* Section 9.11: fcntl()
* Section 9.12: htons(), htonl(), ntohs(), ntohl()
* Section 9.13: inet_ntoa(), inet_aton(), inet_addr
* Section 9.14: inet_ntop(), inet_pton()
* Section 9.15: listen()
* Section 9.16: perror(), strerror()
* Section 9.17: poll()
* Section 9.18: recv(), recvfrom()
* Section 9.19: select()
* Section 9.20: setsockopt(), getsockopt()
* Section 9.21: send(), sendto()
* Section 9.22: shutdown()
* Section 9.23: socket()
* Section 9.24: struct sockaddr and pals

**Chapter 10: More References**

* Section 10.1: Books
* Section 10.2: Web References
* Section 10.3: RFCs
**Introduction**

The author is excited to share their knowledge and experience with socket programming, which can be overwhelming for beginners. This document aims to provide a tutorial for competent C programmers who want to get started with networking.

**Audience**

This guide is intended for those new to socket programming, providing a foothold to help them understand the basics. It is not a complete reference to socket programming.

**Platform and Compiler**

The code examples in this document were compiled on a Linux PC using Gnu's gcc compiler. The code should work on other platforms that use gcc, but note that Windows-specific information can be found in a later section.

**Official Homepage and Books For Sale**

The official location of this guide is at https://beej.us/guide/bgnet/, where you can also find example code and translations into various languages. To purchase print copies of the guide, visit https://beej.us/guide/url/bgbuy/.
**Note for Solaris/SunOS Programmers**

* When compiling on Solaris or SunOS, add the following command-line switches to link in proper libraries: `-lnsl -lsocket -lresolv`
* Alternatively, you can also add `-lxnet` to the end of the compile command
* Note that the author has not tested these instructions and they are based on information provided by others

**Note for Windows Programmers**

* The author acknowledges that Windows is a valid operating system with a large install base
* However, they still recommend using Linux, BSD, or Unix instead
* For those who prefer to use Windows, the author suggests trying the Windows Subsystem for Linux or installing Cygwin, which allows you to run Unix tools on Windows
* Alternatively, you can compile programs without modifying them by ignoring system header files and including different ones instead.
* winsock2.h is the "new" version of the Windows socket library (circa 1994).
* If windows.h is included, it automatically pulls in the older winsock.h (version 1) header file which conflicts with winsock2.h.
* To avoid this conflict, define a macro #define WIN32_LEAN_AND_MEAN and include windows.h before including winsock2.h.
* Before using the sockets library, you must call WSAStartup() to initialize it and specify the desired Winsock version (e.g. 2.2).
* Check the result of WSAStartup() to ensure that the specified version is available.
* If the version is not available, exit the program with an error message.
* When finished using the Winsock library, call WSACleanup() to clean up.
* Link the Winsock library (ws2_32.lib) in your compiler settings.
* Note that some socket functions have different names than their Unix equivalents:
	+ close() is replaced by closesocket()
	+ select() only works with socket descriptors, not file descriptors
* A socket class called CSocket is available for use.
* Check the official Microsoft page for more information on Winsock.
* Windows does not have a fork() system call, so alternative methods such as linking to a POSIX library or using CreateProcess() may be needed.
**Chapter 1: Introduction**

* The author mentions that `fork()` takes no arguments, while `CreateProcess()` takes about 48 billion arguments.
* He also mentions that multithreading is beyond the scope of this document.

**Email Policy**

* The author is generally available to help with email questions but cannot guarantee a response due to his busy schedule.
* He asks that questions be narrowed down and include relevant information, such as platform, compiler, error messages, etc.
* If no response is received, the author suggests trying to find the answer on one's own and then writing back with the findings.

**Mirroring**

* The author welcomes mirroring of the site, publicly or privately, and invites those who mirror it publicly to let him know so he can link to it from the main page.

**Note for Translators**

* The author encourages translation of the guide into another language and invites translators to contact him at beej@beej.us.
* He offers to host translations and will link to them if desired.

**Copyright, Distribution, and Legal**

* Beej's Guide to Network Programming is Copyright 2019 Brian "Beej Jorgensen" Hall.
* The work is licensed under the Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 License.
* The author provides information on how to view a copy of this license or contact Creative Commons for more information.
**License Exception**

The guide can be translated into any language as long as it is accurate and reprinted in its entirety. The translation must include the name and contact information for the translator, and the same license restrictions apply to the translation as they do to the original guide.

**C Source Code**

The C source code presented in this document is granted to the public domain and is completely free of any license restriction.

**Educational Use**

Educators are freely encouraged to recommend or supply copies of this guide to their students.

**Disclaimers and Liability**

Unless otherwise agreed upon, the author offers the work as-is with no representations or warranties. The author will not be liable for any damages arising out of the use of the work, including special, incidental, consequential, punitive, or exemplary damages.

**Dedication**

The guide is dedicated to various individuals who have helped with its creation, as well as those who produce Free and Open Source software that was used in its production. The author also dedicates it to their heroes and inspirations in the world of computers.

**Publishing Information**

The book is written in Markdown using the vim editor on an Arch Linux box loaded with GNU tools. The cover "art" and diagrams are produced with Inkscape, and the Markdown is converted to HTML and LaTex/PDF by Python, Pandoc, and XeLaTeX using Liberation fonts.
A socket is a way to communicate with other programs using standard Unix file descriptors. In Unix, everything can be treated as a file, including network connections, pipes, and terminals. To make a network connection, you use the socket() system routine to get a socket descriptor, which you then use with specialized send() and recv() calls.

There are multiple types of sockets, but this chapter focuses on two: Stream Sockets (reliable, connected communication streams) and Datagram Sockets (connectionless).
**Stream Sockets**

* Stream sockets are used by applications such as telnet, ssh, and web browsers that use HTTP.
* They achieve error-free and sequential data transmission through the Transmission Control Protocol (TCP).
* TCP ensures that data arrives in the same order it was sent and without errors.

**Datagram Sockets**

* Datagram sockets are connectionless and unreliable.
* They use the User Datagram Protocol (UDP) for routing, but do not guarantee delivery or order of packets.
* UDP does not maintain an open connection like TCP; instead, packets are sent individually with destination information.
* Datagram sockets are often used in applications that require fast data transfer, such as multiplayer games, streaming audio and video conferencing.

**Reliability**

* Some applications, such as tftp and dhcpcd, use a protocol on top of UDP to ensure reliable data transfer by requesting acknowledgment packets from the recipient.
* In unreliable applications like games and multimedia, dropped packets are often ignored or compensated for.

**Why Use Unreliable Protocols?**

* The main reasons are speed and speed. Firing-and-forgetting packets is faster than keeping track of safe arrival and order.
* If data transfer speed is more important than ensuring error-free transmission, UDP may be a better choice.
Chapter 2: What is a Socket?

The chapter explains how networks work by layering protocols. It introduces data encapsulation, where a packet is wrapped in headers by each protocol (e.g., TFTP, UDP, IP, and Ethernet) before transmission.

When a computer receives the packet, the hardware strips the Ethernet header, the kernel strips the IP and UDP headers, and the TFTP program strips the TFTP header to reveal the original data.

The chapter also explains the Layered Network Model (ISO/OSI), which describes a system of network functionality. The model consists of seven layers:

1. Application
2. Presentation
3. Session
4. Transport
5. Network
6. Data Link
7. Physical

The Physical Layer is the hardware, and the Application Layer is where users interact with the network.

The chapter also presents an alternative layered model used in Unix, which consists of four layers:

1. Application Layer (telnet, ftp, etc.)
2. Host-to-Host Transport Layer (TCP, UDP)
3. Internet Layer (IP and routing)
4. Network Access Layer (Ethernet, wi-fi, or whatever)

The chapter concludes by explaining how sockets work: for stream sockets, you send data using the `send()` function; for datagram sockets, you encapsulate the packet in your chosen method and use `sendto()` to send it out. The kernel builds the Transport Layer and Internet Layer on for you, and the hardware handles the Network Access Layer.
Chapter 2: What is a socket?

* The chapter briefly touches on network theory before moving on to the topic of sockets.
* The author mentions that they won't be discussing routing, stating that it's not relevant to their discussion. They suggest checking out RFC4 (Internet Protocol) if readers are interested in learning more about routing.
* A link to the IP RFC4 is provided: https://tools.ietf.org/html/rfc791
Chapter 3: IP Addresses, structs, and Data Munging

The chapter starts by discussing IP addresses and ports. It explains that in the past, there was Internet Protocol Version 4 (IPv4) which used four bytes (or octets) to form an address, typically written in "dots and numbers" format such as 192.0.2.111.

It is mentioned that IPv4 has been widely used until recently, when Vint Cerf warned about running out of addresses due to generous allocations given to organizations in the past. Despite having billions of possible IP addresses in a 32-bit IPv4 address, the reality is that there are indeed many computers and devices connected to the internet.

The chapter also touches on the idea that with the increasing number of devices and humans having IP addresses, stopgap measures have been implemented to prevent running out of addresses.
IPv6 was developed to provide more addresses than IPv4, with the ability to support many more devices and networks. The chapter explains that IPv6 uses 128 bits instead of 32 bits like IPv4, resulting in a much larger number of possible addresses (340 trillion trillion trillion compared to 4 billion).

The chapter also discusses the representation of IPv6 addresses, which use hexadecimal notation with colons separating two-byte chunks. It shows examples of how leading zeros can be omitted and multiple consecutive zeros can be compressed between colons.

Additionally, the chapter explains that some IPv6 addresses may have an IPv4-compatibility mode, where an IPv4 address is represented in a similar way using the notation "::ffff:IPv4_address".

Finally, the chapter touches on subnets, which are used to organize IP addresses by dividing them into network and host portions. It gives an example of how this works with IPv4, but notes that it can also be applied to IPv6 addresses.
**IP Addresses**

* In the past, there were "classes" of subnets where the first one, two, or three bytes of an address was the network part.
* Class A networks had one byte for the network and three for the host (16 million hosts), while Class C networks had three bytes of network and one byte of host (256 hosts minus a few reserved).
* The network portion of an IP address is described by the netmask, which can be represented as a string of numbers or as a slash followed by the number of network bits in decimal.
* For example, a netmask of 255.255.255.0 represents a network with 24 bits of host and 8 bits of network.

**Port Numbers**

* Port numbers are used by TCP (stream sockets) and UDP (datagram sockets) to differentiate between services on the same computer.
* Each service has a well-known port number, which can be found in the IANA Port List or in the /etc/services file on Unix boxes.
* For example, HTTP uses port 80, telnet uses port 23, and SMTP uses port 25.

**Byte Order**

* There are two byte orderings: Lame and Magnificent (just kidding).
* The actual byte ordering is not specified.
The chapter discusses IP addresses, structs, and data munging. It explains that there are two types of byte ordering: Big-Endian (also known as Network Byte Order) and Little-Endian. Most computers store bytes in reverse order, but some, like those with Intel or Intel-compatible processors, store them in the correct order.

The chapter introduces several functions to convert between Host Byte Order and Network Byte Order:

* htons(): converts a short (two bytes) from Host Byte Order to Network Byte Order
* htonl(): converts a long (four bytes) from Host Byte Order to Network Byte Order
* ntohs(): converts a short (two bytes) from Network Byte Order to Host Byte Order
* ntohl(): converts a long (four bytes) from Network Byte Order to Host Byte Order

The chapter advises that it's generally recommended to convert numbers to Network Byte Order before sending them over the wire and convert them back to Host Byte Order when receiving them. It also notes that there is no 64-bit variant of these functions, and floating point conversions are discussed in a separate section on Serialization.

Finally, the chapter states that unless otherwise specified, numbers in this document will be assumed to be in Host Byte Order.
**Socket Descriptors**

* A socket descriptor is an integer (int) type.

**struct addrinfo**

* A structure used to prepare socket address structures for subsequent use.
* It's also used in host name lookups and service name lookups.
* The struct contains the following fields:
	+ ai_flags: integer
	+ ai_family: integer (AF_INET, AF_INET6, AF_UNSPEC)
	+ ai_socktype: integer (SOCK_STREAM, SOCK_DGRAM)
	+ ai_protocol: integer (use 0 for "any")
	+ ai_addrlen: size_t (size of ai_addr in bytes)
	+ ai_addr: pointer to struct sockaddr
	+ ai_canonname: char* (full canonical hostname)
	+ ai_next: struct addrinfo* (linked list, next node)

**struct sockaddr**

* Holds socket address information for many types of sockets.
* The struct contains the following fields:
	+ sa_family: unsigned short (address family, AF_xxx)
	+ sa_data: char[14] (14 bytes of protocol address)
* The `sa_family` field in `struct sockaddr` can be either `AF_INET` (IPv4) or `AF_INET6` (IPv6), and is used to indicate the address family.
* The `sa_data` field in `struct sockaddr` contains a destination address and port number for the socket, but this is unwieldy and requires manual packing.
* To deal with `struct sockaddr`, programmers created parallel structures such as `struct sockaddr_in` (IPv4) and `struct sockaddr_in6` (IPv6).
* A pointer to `struct sockaddr_in` can be cast to a pointer to `struct sockaddr` and vice versa, allowing the use of `struct sockaddr_in` even when `connect()` requires a `struct sockaddr*`.
* `struct sockaddr_in` has three fields: `sin_family`, which should be set to `AF_INET`; `sin_port`, which must be in Network Byte Order; and `sin_addr`, which is a `struct in_addr` containing the IP address.
* `struct in_addr` has one field, `s_addr`, which is a 32-bit integer representing the IP address in Network Byte Order.
* There are similar structs for IPv6: `struct sockaddr_in6`, which contains fields such as `sin6_family`, `sin6_port`, `sin6_flowinfo`, `sin6_addr`, and `sin6_scope_id`.
**IPv6 Address Structure**

* `struct in6_addr` contains an IPv6 address and port number.
* Note that IPv6 has both an IPv6 address and port number, similar to IPv4.

**Struct sockaddr_storage**

* `struct sockaddr_storage` is a structure designed to hold both IPv4 and IPv6 addresses.
* It contains the following fields:
	+ `ss_family`: address family (e.g. AF_INET or AF_INET6)
	+ Padding fields (`__ss_pad1`, `__ss_align`, and `__ss_pad2`)
* You can cast `struct sockaddr_storage` to either `struct sockaddr_in` or `struct sockaddr_in6` depending on the value of `ss_family`.

**IP Address Manipulation**

* The `inet_pton()` function converts an IP address in numbers-and-dots notation to a binary representation (either `struct in_addr` or `struct in6_addr`).
* Example usage:
	+ IPv4: `inet_pton(AF_INET, "10.12.110.57", &(sa.sin_addr));`
	+ IPv6: `inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &(sa6.sin6_addr));`
* The function returns -1 on error or 0 if the address is invalid.
* It's recommended to check the return value before using the converted address.

This summary covers the core information provided in Chapter 3, including the structure of IPv6 addresses, `struct sockaddr_storage`, and the `inet_pton()` function for IP address manipulation.
**inet_ntop() function**

* Converts a network address to a printable string (IPv4 or IPv6)
* Takes four arguments: address type (AF_INET or AF_INET6), address, pointer to string to hold result, and maximum length of that string
* Macros INET_ADDRSTRLEN and INET6_ADDRSTRLEN define the size of strings needed for largest IPv4 and IPv6 addresses

**IPv4 and IPv6 conversion**

* Example code shows converting an IPv4 and IPv6 address using inet_ntop()

**Private (Disconnected) Networks**

* Firewalls often hide internal networks from the outside world using Network Address Translation (NAT)
* Private networks, such as 10.x.x.x, are reserved for use on fully disconnected networks or behind firewalls
* NAT translates internal IP addresses to external ones, allowing multiple devices to share a single public IP address
* IP Addresses:
	+ Common private networks: 10.x.x.x, 192.168.x.x (where x is 0-255)
	+ Less common private network: 172.y.x.x (where y is between 16 and 31)
	+ Networks behind a NATing firewall often use these reserved networks
* IPv6 Private Networks:
	+ Start with fdXX: (or possibly fcXX:)
	+ Defined in RFC 4193
	+ Note that IPv6 and NAT generally don't mix, except for IPv6 to IPv4 gateways
1. Use `getaddrinfo()` instead of packing structures by hand.
2. Wrap hardcoded IP version-related code into helper functions.
3. Replace `AF_INET` with `AF_INET6`.
4. Replace `PF_INET` with `PF_INET6`.
5. Replace `INADDR_ANY` assignments with `in6addr_any` assignments, or use the initializer `IN6ADDR_ANY_INIT`.
6. Use `struct sockaddr_in6` instead of `struct sockaddr_in`, and add "6" to the fields as appropriate.
7. Use `struct in6_addr` instead of `struct in_addr`, and add "6" to the fields as appropriate.
8. Replace `inet_aton()` or `inet_addr()` with `inet_pton()`.
9. Replace `inet_ntoa()` with `inet_ntop()`.
10. Replace `gethostbyname()` with `getaddrinfo()`.
Chapter 4: Jumping from IPv4 to IPv6

1. Replace gethostbyaddr() with getnameinfo().
2. INADDR_BROADCAST is no longer applicable, use IPv6 multicast instead.

Note: This summary only includes the exact information provided in the original text and does not add any assumptions or extra information.
This chapter discusses system calls and library calls that allow access to network functionality on Unix boxes and other platforms that support the sockets API.

The author notes that people often get stuck when trying to use these functions in the correct order, as the man pages do not provide clear guidance. To help with this, the author has organized the system calls into sections in the same order they would need to be called in a program.

The chapter starts by discussing the `getaddrinfo()` function, which is used to set up structs needed for later use and can perform DNS lookups and service name lookups. The author notes that this function replaced older functions like `gethostbyname()` and provides examples of its usage.

The code snippet provided includes:

```
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *node,
               const char *service,
```
The `getaddrinfo` function takes three input parameters: `hints`, `node`, and `service`. The function returns a pointer to a linked-list, `res`, of results. The parameters are:

* `hints`: points to a struct addrinfo that has been filled out with relevant information.
* `node`: the host name to connect to, or an IP address.
* `service`: can be a port number (e.g., "80") or the name of a particular service (e.g., "http", "ftp", etc.).

The function is used to set up structures for network operations. Here are two examples:

1. Server example: listen on host's IP address, port 3490.

* Initialize `hints` struct with `ai_family = AF_UNSPEC`, `ai_socktype = SOCK_STREAM`, and `ai_flags = AI_PASSIVE`.
* Call `getaddrinfo(NULL, "3490", &hints, &servinfo)` to get a linked list of results.
* Check for errors using `gai_strerror(status)`. If no error, `servinfo` points to a linked list of struct addrinfos.
* Free the linked list with `freeaddrinfo(servinfo)` when done.

2. Client example: connect to a server (e.g., "www.example.net", port 3490).

* Initialize `hints` struct with `ai_family = AF_UNSPEC`, `ai_socktype = SOCK_STREAM`.
* Call `getaddrinfo(NULL, NULL, &hints, &servinfo)` to get a linked list of results.
* Check for errors using `gai_strerror(status)`. If no error, `servinfo` points to a linked list of struct addrinfos.
* Free the linked list with `freeaddrinfo(servinfo)` when done.
**Chapter 5: System Calls or Bust**

**Code Snippet 1**
```
int status;
struct addrinfo hints;
struct addrinfo *servinfo;

memset(&hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC; // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

status = getaddrinfo("www.example.net", "3490", &hints, &servinfo);
```

**Code Snippet 2: showip.c program**
```
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <netinet/in.h>

int main(int argc, char *argv[]) {
    struct addrinfo hints, *res, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"usage: showip hostname\n");
        return 1;
    }

    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(argv[1], NULL, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
        return 2;
    }
}
```

The code snippets show the use of the `getaddrinfo()` function to retrieve information about a host and its IP addresses. The first snippet demonstrates the basic usage of `getaddrinfo()`, while the second snippet provides a simple program (`showip.c`) that prints the IP addresses for a specified hostname.
The code defines a function called `showip` that takes an argument `argv[1]`, which is expected to be a domain name or IP address. The function uses the `getaddrinfo()` system call to retrieve a list of IP addresses associated with the input, and then iterates over the list to print out the IP addresses.

The iteration involves checking the type of IP address (IPv4 or IPv6) and using the corresponding struct (`sockaddr_in` for IPv4 and `sockaddr_in6` for IPv6) to extract the IP address string. The `inet_ntop()` function is used to convert the binary IP address to a human-readable string, which is then printed out along with a label indicating whether it's an IPv4 or IPv6 address.

The sample run demonstrates how the code works when given two different input arguments: `www.example.net` and `ipv6.example.com`. The output shows both the IPv4 and IPv6 addresses associated with each domain name.
**Chapter 5: System Calls or Bust**

* The `socket()` function allows creation of a socket with specified domain, type, and protocol.
	+ Domain: IPv4 (PF_INET) or IPv6 (PF_INET6)
	+ Type: Stream (SOCK_STREAM) or Datagram (SOCK_DGRAM)
	+ Protocol: Can be set to 0 for automatic selection or obtained using `getprotobyname()` with "tcp" or "udp"
* The `socket()` function returns a socket descriptor or -1 on error, and sets the global variable `errno` to the error value.
* Example usage of `socket()` with values from `getaddrinfo()`:
	+ `s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);`
* The created socket is not useful by itself and requires further system calls for it to make sense.

**5.3: bind() - What port am I on?**

* The `bind()` function associates a socket with a port on the local machine.
* Port number is used by the kernel to match incoming packets to a specific process's socket descriptor.
* `bind()` may not be necessary for clients that only do a `connect()` (i.e., are not servers).
* Reading about `bind()` is still recommended for understanding the function.
**Synopsis for the bind() system call**

* The `bind()` function takes three parameters:
	+ `sockfd`: the socket file descriptor returned by `socket()`
	+ `my_addr`: a pointer to a struct sockaddr that contains information about your address (port and IP address)
	+ `addrlen`: the length in bytes of the address

**Example code**

* Uses the `getaddrinfo()` function to load up address structs
* Creates a socket using the `socket()` function
* Binds the socket to the host's IP address and port 3490 using the `bind()` function
* The `AI_PASSIVE` flag is used to bind to the host's IP address

**Old code (IPv4-specific)**

* Manually packs the struct sockaddr_in before calling `bind()`
* Uses `socket()` with PF_INET, SOCK_STREAM, and 0
* Fills in the struct sockaddr_in fields:
	+ sin_family = AF_INET
	+ sin_port = htons(MYPORT)
	+ sin_addr.s_addr = inet_addr("10.12.110.57")

Note that this summary only includes the information provided in the text, without any additional assumptions or commentary.
**Code Snippet**

* `memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);` initializes the `sin_zero` field of a `struct sockaddr_in` to all zeros.
* `bind(sockfd, (struct sockaddr *)&my_addr, sizeof my_addr);` binds a socket to an address and port.

**Notes**

* When binding a socket, use `INADDR_ANY` or `in6addr_any` for the local IP address.
* Port numbers below 1024 are reserved unless running as superuser. Use any port number above 1024 (up to 65535) if not already in use by another program.
* If `bind()` fails with "Address already in use", it may mean a previous socket is still holding the port; either wait for it to clear or add code to reuse the port using `setsockopt()`.
* In some cases, you don't need to call `bind()` if connecting to a remote machine and not caring about the local port. `connect()` will bind an unused local port if necessary.

**Function Description**

* `int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);` connects a socket to a remote host.
	+ `sockfd`: socket file descriptor returned by `socket()`.
	+ `serv_addr`: `struct sockaddr` containing the destination port and IP address.
	+ `addrlen`: length in bytes of the server address structure.

**Related Topic**

* The `getaddrinfo()` call can be used to obtain information needed for the `connect()` function.
The chapter discusses two types of socket connections: making a connection to a remote host and waiting for incoming connections.

Making a Connection:
* Use the getaddrinfo() system call to load address structs with information about the remote host.
* Create a socket using the socket() system call, passing in the family, type, and protocol from the addrinfo struct.
* Connect to the remote host using the connect() system call, passing in the socket file descriptor, remote address, and remote address length.

Waiting for Incoming Connections:
* Use the listen() system call to set up a server that listens for incoming connections. The system call takes two arguments: the socket file descriptor and the maximum number of connections allowed on the queue.
* The backlog argument sets the limit on how many incoming connections can wait in the queue before being accepted by the accept() system call (not shown in this chapter).

The chapter also notes that bind() must be called before listen(), as it specifies which port the server is running on.
Chapter 5: System Calls or Bust

* Code snippet:
	+ bind()
	+ listen()
	+ accept() (with sample code)
* Explanation of accept() call:
	+ Someone tries to connect to your machine on a port you're listening on
	+ Connection is queued up waiting to be accepted
	+ You call accept() and it returns a new socket file descriptor for the connection
	+ The original socket remains listening for more connections
	+ The newly created socket can be used for send() and recv()
* Syntax of accept() call:
	+ `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
	+ Parameters: `sockfd` (listen()ing socket descriptor), `addr` (pointer to local `struct sockaddr_storage`), `addrlen` (local integer variable set to `sizeof(struct sockaddr_storage)`)
* Return value of accept(): -1 and sets errno if an error occurs
* Sample code fragment:
	+ Includes necessary headers
	+ Defines constants for port number and backlog queue size
	+ Declares variables for socket file descriptors, address structures, and other variables
	+ (Code snippet ends here)
**System Calls or Bust**

1. Create a hints structure and initialize it:
	* `hints.ai_family = AF_UNSPEC`
	* `hints.ai_socktype = SOCK_STREAM`
	* `hints.ai_flags = AI_PASSIVE`
2. Use `getaddrinfo` to fill in the IP address for the socket:
	* `getaddrinfo(NULL, MYPORT, &hints, &res)`
3. Create a socket and bind it to the filled-in IP address:
	* `sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)`
	* `bind(sockfd, res->ai_addr, res->ai_addrlen)`
	* `listen(sockfd, BACKLOG)`
4. Accept an incoming connection:
	* `addr_size = sizeof their_addr`
	* `new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &addr_size)`
5. Use the socket descriptor `new_fd` for all send() and recv() calls.

**send() and recv() Functions**

1. The `send()` function:
	* `int send(int sockfd, const void *msg, int len, int flags);`
		+ `sockfd`: socket descriptor
		+ `msg`: pointer to data to send
		+ `len`: length of data in bytes
		+ `flags`: set to 0 (see man page for more information)
2. Sample code:
	* Create a message string: `char *msg = "Beej was here!";`
	* Calculate the length of the message: `int len = strlen(msg);`
	* Send the message using send(): `bytes_sent = send(sockfd, msg, len, 0);`

No assumptions or extra information has been added.
**send()**

* Returns the number of bytes actually sent, which may be less than the specified length
* If the value returned by send() doesn't match the value in len, it's up to the programmer to send the rest of the string
* Returns -1 on error, with errno set accordingly

**recv()**

* Similar to send(), returns the number of bytes actually read into the buffer
* Returns 0 if the remote side has closed the connection
* Returns -1 on error, with errno set accordingly

**sendto() and recvfrom() for unconnected datagram sockets**

* sendto():
	+ Takes additional parameters: destination address (struct sockaddr *), length of address (socklen_t tolen)
	+ Returns the number of bytes actually sent, or -1 on error
* recvfrom():
	+ Takes additional parameters: source address (struct sockaddr *), pointer to length of address (int *fromlen)
	+ Fills local struct sockaddr_storage with IP address and port of originating machine
	+ Returns the number of bytes received, or -1 on error
Chapter 5: System Calls or Bust

* The reason for using `struct sockaddr_storage` as the socket type instead of `struct sockaddr_in` is to avoid tying oneself down to IPv4 or IPv6. `struct sockaddr_storage` is guaranteed to be big enough to hold either.
* However, it's unclear why `struct sockaddr` itself isn't big enough to hold any address.
* When connecting a datagram socket using `connect()`, one can use `send()` and `recv()` for transactions without worrying about adding destination and source information.

Section 5.9: close() and shutdown()—Get outta my face!

* To close a connection on a socket descriptor, one can simply use the regular Unix file descriptor `close()` function: `close(sockfd)`.
* This will prevent any further reads or writes to the socket.
* Alternatively, the `shutdown()` function can be used to cut off communication in a certain direction or both ways. Synopsis: `int shutdown(int sockfd, int how);`.
* The `shutdown()` function returns 0 on success and -1 on error (with errno set accordingly).
* If used on an unconnected datagram socket, `shutdown()` will make the socket unavailable for further `send()` and `recv()` calls.
* Note that `shutdown()` does not close the file descriptor; it only changes its usability. To free a socket descriptor, one must use `close()`.
* On Windows using Winsock, one should call `closesocket()` instead of `close()`.

Section 5.10: getpeername()—Who are you?

* This function is described as easy to use.
**Chapter 5: System Calls or Bust**

* **getpeername()**: Returns information about the other end of a connected stream socket.
	+ Synopsis: `int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);`
	+ Parameters:
		- `sockfd`: Descriptor of the connected stream socket
		- `addr`: Pointer to a `struct sockaddr` (or `struct sockaddr_in`) that holds information about the other side of the connection
		- `addrlen`: Pointer to an `int`, initialized to `sizeof *addr` or `sizeof(struct sockaddr)`
	+ Returns: -1 on error, sets `errno` accordingly
	+ Can be used with `inet_ntop()`, `getnameinfo()`, or `gethostbyaddr()` to print or get more information
* **gethostname()**: Returns the name of the computer that the program is running on.
	+ Synopsis: `int gethostname(char *hostname, size_t size);`
	+ Parameters:
		- `hostname`: Pointer to an array of chars that will contain the hostname upon return
		- `size`: Length in bytes of the hostname array
	+ Returns: 0 on successful completion, -1 on error, sets `errno` as usual
It's a client-server world where clients talk to server processes and vice versa. An example is telnet, where a client (telnet) connects to a remote host on port 23, which triggers the server program (telnetd) to handle the connection.

The exchange of information between client and server is illustrated in Figure 6.1:

* Client sends request
* Server receives request and responds
* Client receives response

A client-server pair can use different communication protocols as long as they are speaking the same thing. Examples include telnet/telnetd, ftp/ftpd, or Firefox/Apache.

In many cases, there is only one server on a machine, which handles multiple clients using fork(). The basic routine is:

1. Server waits for a connection
2. Accepts the connection
3. Forks a child process to handle it

A simple stream server example sends the string "Hello, world!" over a stream connection and can be tested by running the server and then telnetting to it from another window using the command: $ telnet remotehostname 3490.
**Server Code**

The server code, written in C, is a stream socket server demo. It includes various header files and defines two constants: `PORT` set to "3490" and `BACKLOG` set to 10.

The code also defines two functions:

1. `sigchld_handler(int s)`: handles child process termination.
2. `get_in_addr(struct sockaddr *sa)`: returns a pointer to the address information of the socket family (IPv4 or IPv6).

The main function initializes several variables, including socket file descriptors (`sockfd` and `new_fd`) and various structures. It then sets up a signal action for child process termination using the `sigaction` structure.

That's the summary!
The chapter 6 code snippet provides a client-server background. The script starts by initializing variables such as `yes` and `s`, then sets hints for the getaddrinfo function using `AF_UNSPEC`, `SOCK_STREAM`, and `AI_PASSIVE`. It then calls getaddrinfo to retrieve a list of addresses, loops through this list, and attempts to bind to the first available address. If an error occurs during binding or socket setup, it will print an error message and continue with the next iteration. The script also sets up a signal handler to reap dead processes using sigaction.

The following variables are used:

* `yes`: an integer initialized to 1
* `s`: a character array of length INET6_ADDRSTRLEN
* `rv`: an integer variable
* `hints`: a struct hints initialized with zeros and set to AF_UNSPEC, SOCK_STREAM, and AI_PASSIVE
* `p`: a pointer used in the loop through servinfo
* `sockfd`: a socket file descriptor
* `servinfo`: a struct servinfo retrieved from getaddrinfo
* `sa`: a signal action structure
Chapter 6. Client-Server Background

Code snippet for a server program:
```
37-133
```

The code initializes a socket and listens for connections on port 3490. When a connection is accepted, it forks a new process to handle the connection. The child process sends the string "Hello, world!" back to the client and then exits. The parent process closes the socket descriptor.

Note: The `sigaction` function is used to reap zombie processes that are created by the forked child processes.

There is no additional information provided beyond this code snippet.
This chapter provides code for a client-server background in C programming. It includes various header files, defines constants for port number and maximum data size, and declares functions.

The `get_in_addr` function takes a struct sockaddr as input and returns a pointer to either the IPv4 or IPv6 address depending on the family of the socket.

The `main` function is the entry point of the program. It checks if the correct number of command-line arguments have been provided, sets up the hints for the getaddrinfo function, and calls getaddrinfo to retrieve information about the server.

If an error occurs during getaddrinfo, it prints an error message and exits the program. Otherwise, it loops through the results returned by getaddrinfo and connects to the first available server using a socket.

The code stops at line 57, which is where the connection attempt fails with an error message "client: socket".
**Chapter 6: Client-Server Background**

* A client connects to a server using a socket ( sockfd ) and checks if it's successful. If not, it closes the socket and prints an error message.
* The client receives data from the server, stores it in a buffer ( buf ), and prints the received data.
* If the connection is refused, the client returns with an exit status of 2.

**Datagram Sockets**

* Two sample programs are presented: talker.c and listener.c.
* The listener sits on a machine waiting for incoming packets on port 4950.
* The talker sends a packet to that port on a specified machine containing user input from the command line.
* Datagram sockets are connectionless, so they don't care about success or failure of sending packets.
* To avoid issues with IPv4 vs. IPv6, the client and server will use specifically IPv6 for datagram sockets.

Note: The summary only includes the information provided in the text without adding any extra details or assumptions.
**File:** listener.c (a datagram sockets "server" demo)

**Contents:**

* Includes various header files for socket programming
* Defines two constants: `MYPORT` (set to "4950") and `MAXBUFLEN` (set to 100)
* Function `get_in_addr` is defined to convert a `struct sockaddr` to a `void *`
* The main function:
	1. Declares several variables, including an integer for the socket file descriptor (`sockfd`)
	2. Initializes a `struct addrinfo` and sets its family to `AF_INET6`, socktype to `SOCK_DGRAM`, and flags to `AI_PASSIVE`
	3. Calls `getaddrinfo` with NULL as the host name, `MYPORT` as the service name, and the initialized `hints` struct
	4. Checks the return value of `getaddrinfo` and prints an error message if it's not 0

**Note:** This summary does not include any external links or comments that may be present in the original file.
**Code from listener.c**

The code defines a function called `listener` that sets up an unconnected datagram socket using `getaddrinfo`. The function iterates through the results and binds to the first available socket. If binding fails, it prints an error message and continues to the next result.

If no suitable socket is found, it prints an error message and returns 2.

Once a socket is bound, the function waits for a packet to be received using `recvfrom`. It prints the source IP address of the packet and the length of the packet. The received data is printed out as well.

Finally, the function closes the socket and returns 0.

**Note**: This code uses unconnected datagram sockets, which means there's no need for `listen()` or `accept()`.
The code snippet appears to be for a datagram "client" demo program called "talker.c". It includes various header files and defines a constant `SERVERPORT` set to the value `"4950"`.

The `main` function takes three command-line arguments: `argc`, `argv[]`. If the number of arguments is not exactly 3, it prints an error message and exits. Otherwise, it initializes several variables, including:

* `sockfd`: a file descriptor for a socket
* `hints`: a struct to hold hints for getting address information
* `servinfo`: a pointer to a linked list of address information
* `rv`: an integer return value from the `getaddrinfo` function
* `numbytes`: an integer variable

The program then calls the `getaddrinfo` function to get address information for a server with the specified hostname and port number. If this fails, it prints an error message and exits.

If the `getaddrinfo` call is successful, the program loops through the results and attempts to create a socket using the `socket` function. If this fails, it prints an error message and continues to the next iteration of the loop. If the socket creation is successful, it breaks out of the loop.

Finally, if no address information was found or if the socket could not be created, the program prints an error message and returns a non-zero exit code.
Chapter 6: Client-Server Background

Code snippet:
```
43
54
55
if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
56
p->ai_addr, p->ai_addrlen)) == -1) {
57
perror("talker: sendto");
58
exit(1);
59
}
60
61
freeaddrinfo(servinfo);
62
63
printf("talker: sent %d bytes to %s\n", numbytes, argv[1]);
64
close(sockfd);
65
66
return 0;
67
}
```
The code is part of a client-server program called "talker" that uses UDP datagram sockets. It sends data using the `sendto` function and prints a message indicating how many bytes were sent.

Additional information:

* The program can be run independently, sending packets into the network where they will disappear if no one is ready to receive them.
* Data sent using UDP datagram sockets is not guaranteed to arrive.
* The program mentions connected datagram sockets, which allow the client to specify a particular address with `connect()` and then only send and receive data from that address. In this case, `sendto` and `recvfrom` can be replaced with `send` and `recv`.
**Slightly Advanced Techniques**

This chapter covers slightly advanced techniques related to Unix network programming, building upon the basics already covered. It introduces blocking and non-blocking sockets.

**Blocking**

* "Block" means "sleep" in technical terms.
* Functions like recvfrom(), accept(), and all recv() functions block until data arrives or an error occurs.
* By default, a socket is set to blocking when created with socket(). To change this, use fcntl() to set the socket to non-blocking (O_NONBLOCK).
* A non-blocking socket will return -1 and errno set to EAGAIN or EWOULDBLOCK if there's no data available.

**Non-Blocking**

* Checking for both EAGAIN and EWOULDBLOCK is recommended for portability, as the specification doesn't specify which error will be returned.
* However, busy-waiting on a non-blocking socket can waste CPU time. A better approach is discussed in the next section on poll().
**poll() - Synchronous I/O Multiplexing**

The chapter explains how to use the poll() system call to monitor multiple sockets at once and handle those that have data ready without continuously polling each socket. This technique avoids slow performance when dealing with many connections.

To use poll(), you create an array of struct pollfds, which contain information about the socket descriptors you want to monitor and the types of events you're interested in (e.g., "socket ready to read"). The OS blocks on the poll() call until one of these events occurs or a user-specified timeout expires.

The struct pollfd contains three fields:

* `fd`: the socket descriptor
* `events`: a bitmap of events you're interested in (bitwise-OR of POLLIN and POLLOUT)
* `revents`: a bitmap of events that occurred when poll() returns

To use poll(), you pass an array of struct pollfds, the size of the array, and a timeout value in milliseconds to the poll() function. The function returns the number of elements in the array that have had an event occur.

Note: Using poll() can be slow with many connections; consider using an event library like libevent for better performance.
**Summary**

After using the `poll()` function, you can check the `revents` field to see if `POLLIN` or `POLLOUT` is set, indicating that an event occurred.

**Example Code**

The example code demonstrates how to use `poll()` to wait for 2.5 seconds for data to be ready to read from standard input (i.e., when the user hits RETURN). The code includes:

1. Defining a struct `pfds` with one element to monitor standard input.
2. Setting the `fd` field of `pfds[0]` to 0 (standard input) and the `events` field to `POLLIN`.
3. Calling `poll()` with `pfds`, 1, and 2500 (2.5 seconds) as arguments.
4. Checking if the poll timed out or not.
5. If it didn't timeout, checking if `POLLIN` occurred by scanning the `revents` field.

**Additional Information**

* `poll()` returns the number of elements in the `pfds` array for which events have occurred.
* To add new file descriptors to the set, make sure there is enough space in the array or use `realloc()`.
* To delete items from the set, copy the last element over the one being deleted and pass one fewer as the count to `poll()` or set any `fd` field to a negative number for `poll()` to ignore.

**Final Thoughts**

The text also mentions that this is just an introduction to using `poll()` and suggests reading the `poll()` man page for more information. Additionally, it hints at how to put all this together into a chat server that can be accessed via telnet.
The chapter discusses creating a listener socket and using it with the `poll()` function. The steps involve:

1. Creating a listener socket and adding it to an array of file descriptors.
2. Dynamically growing the array if necessary.
3. Removing connections from the array when they are closed.
4. Reading data from ready-to-read connections and sending that data to all other connections.

The example is provided in a C program called `pollserver.c`, which includes various header files for socket programming and the `poll()` function. The program listens on port 9034, detects incoming connections, and sends data between connections.
**Chapter 7: Slightly Advanced Techniques**

**Code Snippet 1: Creating a Socket and Binding it**

Lines 38-44:
- Set up socket hints with AF_UNSPEC, SOCK_STREAM, and AI_PASSIVE flags
- Use getaddrinfo() to get the address info for a socket
- Check if the getaddrinfo() call was successful and exit if not
- Loop through the list of addresses returned by getaddrinfo()
- Create a socket using the address information
- Set SO_REUSEADDR option on the socket to prevent "address already in use" error

Lines 46-62:
- Loop through the list of addresses again
- Bind the socket to an address
- Check if the bind() call was successful and close the socket if not
- Break out of the loop when a successful binding occurs

**Code Snippet 2: Adding a New File Descriptor to a Set**

Lines 80-89:
- Function add_to_pfds() adds a new file descriptor to an array of pollfd structures
- Check if there is room in the array, and if not, double its size using realloc()
- Add the new file descriptor to the array at the current count position
**Chapter 7: Slightly Advanced Techniques**

**Functions:**

* `del_from_pfds`: Removes an index from the set of poll file descriptors (`pfds`) and decrements the count of file descriptors (`fd_count`).
* `main`: The main function that initializes a listener socket, sets up a poll file descriptor array, and enters a main loop to monitor for incoming connections.

**Variables:**

* `listener`: A listening socket descriptor.
* `newfd`: A newly accept()ed socket descriptor.
* `remoteaddr`: A client address stored in a `sockaddr_storage` structure.
* `addrlen`: The length of the `remoteaddr` structure.
* `buf`: A buffer for client data with a size of 256 characters.
* `remoteIP`: A character array to store the remote IP address with a size of `INET6_ADDRSTRLEN`.
* `fd_count`: An integer that keeps track of the number of file descriptors in the set.
* `fd_size`: The initial size of the poll file descriptor array.
* `pfds`: A pointer to an array of poll file descriptors.

**Main Loop:**

1. Initialize the listener socket and add it to the poll file descriptor array (`pfds`).
2. Enter a main loop that uses the `poll()` function to monitor for incoming connections.
3. If an error occurs during the polling process, print an error message and exit the program.

Note that this summary only includes the provided data without adding any assumptions or extra information.
Chapter 7. Slightly Advanced Techniques

1. Exit the program with an error status.
2. A loop runs through existing connections looking for data to read.
3. For each connection, check if it's ready to read using POLLIN.
4. If a listener is ready to read (i.e., new connection), handle the new connection:
	* Accept the connection and get the address of the remote host.
	* Add the new file descriptor to the list of active connections.
	* Print a message indicating a new connection from a specific IP address on a specific socket.
5. If the connection is not the listener, it's a regular client:
	* Receive data from the client using recv() function.
	* Check if there was an error or the connection was closed by the client.
	* If there was an error, print an error message and close the file descriptor.
	* Remove the file descriptor from the list of active connections.
6. If the connection is still open:
	* Send data to all other clients.

Note: I did not add any assumptions or extra information, only summarized the provided code without altering its original content.
**Section 7.1 Slightly Advanced Techniques**

The chapter discusses two functions: poll() and select(). Both offer similar functionality and performance, but differ in how they are used.

**Section 7.3 select() - Synchronous I/O Multiplexing, Old School**

This section introduces the select() function, which allows a program to monitor multiple sockets at once, determining which ones are ready for reading, writing, or have raised exceptions.

The synopsis of the select() function is provided:

```c
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int numfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, struct timeval *timeout);
```

The function monitors "sets" of file descriptors, specifically readfds, writefds, and exceptfds.
* The `select()` function is used to monitor multiple file descriptors for readiness.
* To use `select()`, you need to create a set of file descriptors using `fd_set` and add or remove file descriptors from it using macros such as `FD_SET()` and `FD_CLR()`.
* You can test which file descriptors are ready by using the macro `FD_ISSET()`.
* The `struct timeval` is used to specify a timeout period, allowing you to set a limit on how long you wait for data.
* The `struct timeval` has two fields: `tv_sec` (seconds) and `tv_usec` (microseconds).
* If you set both fields to 0, `select()` will return immediately, effectively polling all the file descriptors in your sets.
**Chapter 7: Slightly Advanced Techniques**

* Code snippet:
```
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#define STDIN 0

int main(void) {
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&readfds);
    FD_SET(STDIN, &readfds);

    select(STDIN+1, &readfds, NULL, NULL, &tv);

    if (FD_ISSET(STDIN, &readfts))
        printf("A key was pressed!\n");
    else
        printf("Timed out.\n");

    return 0;
}
```
* Explanation:
	+ The code uses the `select` function to wait for input on standard input (`STDIN`) for up to 2 seconds and 500 microseconds.
	+ If a key is pressed, it prints "A key was pressed!" to the console. Otherwise, it prints "Timed out."
	+ Note that this code may not work as expected if run on a line-buffered terminal, and that `select` may not work with datagram sockets on all Unix systems.
* Additional information:
	+ If a socket in the read set closes the connection, `select` will return with that socket descriptor set as "ready to read", and subsequent calls to `recv` will return 0.
	+ The code also mentions that if you have a socket that is listening, you can check for new connections by putting its file descriptor in the read set.

**Example Program: Simple Multi-User Chat Server**

* The program acts like a simple multi-user chat server and allows multiple users to connect using telnet.
* When one user types something in their telnet session, it appears in all other connected sessions.
**Source Code:**

This is the source code for a "cheezy multiperson chat server" called `selectserver.c`.

**Includes:**

The code includes various standard libraries, such as:
* `<stdio.h>`
* `<stdlib.h>`
* `<string.h>`
* `<unistd.h>`
* `<sys/types.h>`
* `<sys/socket.h>`
* `<netinet/in.h>`
* `<arpa/inet.h>`
* `<netdb.h>`

**Define:**

The code defines a constant `PORT` with the value `"9034"`, which is the port the server will listen on.

**Function:** `get_in_addr`

This function takes a `struct sockaddr *sa` as input and returns a pointer to either the IPv4 or IPv6 address of the socket, depending on the value of `sa->sa_family`.

**Main Function:**

The main function initializes several variables:
* `master`: an fd_set for storing file descriptors
* `read_fds`: a temporary fd_set for select()
* `fdmax`: the maximum file descriptor number
* `listener`: the listening socket descriptor
* `newfd`: a newly accept()ed socket descriptor
* `remoteaddr`: client address storage
* `addrlen`: the length of the remote address
* `buf`: a buffer for client data
* `nbytes`: the number of bytes received from the client
* `remoteIP`: a buffer to store the client's IP address

The code also initializes several variables with default values:
* `yes=1` (for setsockopt() SO_REUSEADDR)
* `i`, `j`, and `rv` are initialized with unspecified values.

**Structures:**

The code defines two structures:
* `hints`: an addrinfo structure for getting socket information
* `ai`: a pointer to the first address in the result of getaddrinfo()
* `p`: a pointer to the next address in the result of getaddrinfo()

**Functions:**

The code initializes the master and read_fds fd_sets using FD_ZERO().

This is the entirety of the provided data, without any additional information or assumptions.
The code is designed to create a network server that listens on a specific port. The following steps are performed:

1. Getaddrinfo is used to retrieve information about the address and port.
2. A socket is created using the retrieved information.
3. The socket is set to allow reuse of the address in case it's already in use.
4. The socket is bound to the retrieved address and port.
5. If the binding fails, the process continues with the next address in the list.
6. If no addresses are available, an error message is printed and the program exits.
7. The listener is set to listen for incoming connections.
8. The listener is added to a master set of file descriptors.
9. The file descriptor of the listener is kept track of as the maximum so far.
10. A main loop begins, where:
	* The read_fds are copied from the master set.
	* Select is used to monitor the file descriptors for incoming data.

The program exits if an error occurs during any of these steps.
The code is a part of a server program using select() system call for multiplexing. It handles both new connections and existing connections.

**Handling New Connections**

1. The code loops through all file descriptors (fdmax) in a set called `read_fds`.
2. If a file descriptor is found to be readable, it checks if the fd is the listener socket.
3. If the fd is the listener socket, it accepts a new connection using accept() function and adds the new socket to the master set of file descriptors.
4. It also updates the maximum file descriptor (fdmax) if necessary.

**Handling Existing Connections**

1. The code loops through all file descriptors in the `read_fds` set.
2. If a file descriptor is found to be readable, it checks if the fd is not the listener socket and not itself.
3. If the fd is neither the listener nor itself, it receives data from the client using recv() function.
4. If there's an error or the connection is closed by the client, it closes the fd and removes it from the master set.
5. Otherwise, it sends the received data to all other connected clients (except the listener and itself) using send() function.

The code continues looping through file descriptors until all tasks are completed.
**Chapter 7: Slightly Advanced Techniques**

* The code uses two file descriptor sets: `master` and `read_fds`.
	+ `master` holds all socket descriptors that are currently connected, as well as the socket descriptor listening for new connections.
	+ `read_fds` is used to store the sockets that are ready to read after calling `select()`.
* When a new connection is established, it is added to the `master` set. When a connection closes, it is removed from the `master` set.
* The code checks if the listener socket is ready to read and accepts new connections when it is. It also removes sockets from the `master` set when they are closed (i.e., when `recv()` returns 0).
* If `recv()` returns a non-zero value, the code gets the received data and sends it to all connected clients.
* A note is provided about Linux's `select()` function sometimes returning "ready-to-read" even though the socket is not actually ready. The workaround is to set the O_NONBLOCK flag on the receiving socket.
* An alternative function called `poll()` is mentioned, which behaves similarly to `select()`.
* The chapter also discusses handling partial sends using the `sendall()` function.

That's a summary of the provided data without any additional information or assumptions!
**Function: sendall()**

The `sendall()` function sends data from a buffer to a socket. It takes three parameters: `s` (the socket), `buf` (the buffer containing the data), and `len` (a pointer to an integer containing the number of bytes in the buffer).

Here is the code for the function:
```
while(total < *len) {
  n = send(s, buf+total, bytesleft, 0);
  if (n == -1) { break; }
  total += n;
  bytesleft -= n;
}
*len = total; // return number actually sent here
return n==-1?-1:0; // return -1 on failure, 0 on success
```
The function returns -1 on error and the number of bytes actually sent in `len`. If there is an error, it sets `errno` from the call to `send()`.

**Example usage**

Here is an example of how to use the `sendall()` function:
```
char buf[10] = "Beej!";
int len;
len = strlen(buf);
if (sendall(s, buf, &len) == -1) {
  perror("sendall");
  printf("We only sent %d bytes because of the error!\n", len);
}
```
**Serialization**

The chapter discusses serialization, which is the process of converting data into a format that can be sent over a network. There are three options for serializing binary data:

1. Convert the number to text using `sprintf()` and then send the text.
2. Send the data raw using `send()`.
3. Encode the number into a portable binary form, which will need to be decoded by the receiver.

The author prefers method 3.
The chapter discusses slightly advanced techniques for sending and receiving data over a network. The author warns that implementing these techniques can be challenging and recommends using existing libraries instead.

The first method discussed is encoding numbers as text before sending, which has the advantage of being human-readable but is slow and takes up more space. The second method is passing raw data, which is fast but non-portable due to differences in bit representation and byte ordering between architectures.

The author then discusses packing (or marshaling) data into a known binary format for transmission. This approach is similar to using the htons() function to transform integers into Network Byte Order. However, there are no standard functions for transforming float types, so the author suggests packing floats into a known format and sending them over the wire for decoding.

The chapter includes an example of how to pack floats using the following code:
```
#include <stdint.h>

uint32_t htonf(float f)
{
  uint32_t p;
}
```
This is described as "quick and dirty" with plenty of room for improvement.
**Code**

The code includes two functions: `htonf` and `ntohf`. The first function converts a float to a 32-bit number, storing the sign bit in the high bit (31), the whole number portion in bits 30-16, and the fractional portion in bits 15-0. The second function does the reverse conversion.

**Example Code**

The example code demonstrates the use of these functions by converting a float to a 32-bit number (`netf = htonf(f)`), storing it, and then converting it back to a float (`f2 = ntohf(netf)`). The original float value is `3.1415926`, which is converted to `0x0003243F` and then back to `3.141586`.

**Notes**

The code has some limitations, such as not being an efficient use of space and having a restricted range (e.g., numbers greater than 32767 will not be correctly stored). Additionally, the last couple decimal places are not preserved during conversion. The IEEE-754 standard is mentioned as a more efficient way to store floating-point numbers, but it may require additional processing for portability.
The chapter discusses slightly advanced techniques for encoding and decoding floating-point numbers in IEEE-754 format. The code provided defines two functions, `pack754` and `unpack754`, which are used to encode and decode floating-point numbers.

The `pack754` function takes a long double value `f`, an unsigned integer `bits` representing the total number of bits, and an unsigned integer `expbits` representing the number of exponent bits. The function returns a uint64_t value representing the encoded IEEE-754 format.

The `unpack754` function takes a uint64_t value `i`, an unsigned integer `bits` representing the total number of bits, and an unsigned integer `expbits` representing the number of exponent bits. The function returns a long double value representing the decoded floating-point number.

The code provides two macros, `pack754_32` and `pack754_64`, which call the `pack754` function with the corresponding bit counts. Similarly, it provides two macros, `unpack754_32` and `unpack754_64`, which call the `unpack754` function with the corresponding bit counts.

The chapter also notes that the code does not encode NaN (Not a Number) or Infinity values, but could be modified to do so.
**Code**

* A C function `pack754` that packs a floating-point number into a binary format.
* The function takes an integer `i` as input and returns a float result.
* The code includes two versions: `pack754_32` for 32-bit floats and `pack754_64` for 64-bit doubles.
* Macros are provided for packing and unpacking 32-bit and 64-bit numbers.

**Sample Usage**

* A C program that demonstrates the use of the `pack754` function.
* The program defines two variables: a float `f` and a double `d`.
* It packs the values of `f` and `d` using the `pack754_32` and `pack754_64` functions, respectively.
* The packed values are printed in hexadecimal format using the `PRIx` macros.
* The program also unpacks the packed values back into their original floating-point forms using the `unpack754_32` and `unpack754_64` functions.
* The unpacked values are printed as floats.

**Output**

* The output of the sample usage shows the before and after values for both the float and double variables.
* For the float, the encoded value is shown in hexadecimal format: `0x40490FDA`.
The chapter discusses slightly advanced techniques for packing and unpacking data. The first example shows how to pack and unpack a float and double type using C code.

The text then explains that it's not possible to portably send structs over the wire because compilers can add padding, making it necessary to pack each field independently and then unpack them when they arrive on the other side.

To achieve this, a helper function can be written to help pack the data. The book "The Practice of Programming" by Kernighan and Pike provides an example of such functions called `pack()` and `unpack()`. However, these functions are not online with the rest of the source from the book.

Alternative solutions include using Protocol Buffers in C, Python's `pack()` and `unpack()` functions, or Perl's equivalent functions. Java also has a `Serializable` interface that can be used for similar purposes.

The chapter then provides an example code in C that uses variable argument lists to create `printf()`-like functions to build packets. The code includes functions like `packi16()` and `packi32()` that pack 16-bit and 32-bit integers into a char buffer, respectively.
**packi64()**

* A function that stores a 64-bit integer `i` into a character buffer `buf`.
* The function uses bitwise operations to shift and extract the bits from `i` and store them in `buf`.

**unpacki16()**

* A function that unpacks a 16-bit unsigned integer from a character buffer `buf`.
* It combines two bytes (`buf[0]` and `buf[1]`) into an unsigned integer using bitwise operations.
* If the resulting integer is greater than 32767, it is converted to a signed integer.

**unpacku16()**

* A function that unpacks a 16-bit unsigned integer from a character buffer `buf`.
* It combines two bytes (`buf[0]` and `buf[1]`) into an unsigned integer using bitwise operations.
* No conversion is performed on the resulting integer.

**unpacki32()**

* A function that unpacks a 32-bit signed integer from a character buffer `buf`.
* It combines four bytes (`buf[0]`, `buf[1]`, `buf[2]`, and `buf[3]`) into an unsigned long integer using bitwise operations.
* If the resulting integer is greater than 2147483647, it is converted to a signed integer.
**Code**

1. Chapter 7: Slightly Advanced Techniques
2-4. Empty lines
5. A function definition with no code (`return i;`)
6-8. Comment and empty lines
9-84. Function `unpacku32` to unpack a 32-bit unsigned integer from a char buffer
85-122. Three functions:
	* `unpacki64`: unpacks a 64-bit signed integer from a char buffer
	* `unpacku64`: unpacks a 64-bit unsigned integer from a char buffer
	* Empty lines

Note: The code is written in C and appears to be related to network programming or data processing.
**pack() function**

The `pack()` function stores data dictated by a format string in a buffer. It takes three arguments: `buf` (a pointer to an unsigned char), `format` (a character pointer), and variable arguments (`...`).

**Format String**

The format string can contain the following characters:

* `c`: 8-bit signed char
* `C`: 8-bit unsigned char
* `h`: 16-bit int
* `H`: 16-bit unsigned int
* `l`: 32-bit int
* `L`: 32-bit unsigned int
* `q`: 64-bit long long int
* `Q`: 64-bit unsigned long long int
* `f`: float
* `d`: double
* `g`: long double
* `s`: string (16-bit unsigned length is automatically prepended)

**Function Implementation**

The function uses a variable argument list (`va_list ap`) to access the variables. It iterates through the format string, and for each character:

* If the character is 'c' or 'C', it reads an 8-bit value from the variable arguments and stores it in the buffer.
* If the character is one of the other specified types (e.g., 'h', 'L', etc.), it reads a corresponding type value from the variable arguments and stores it in the buffer.

The function returns the size of the data stored in the buffer.
Chapter 7: Slightly Advanced Techniques

The chapter contains switch cases for various types of variables and their corresponding packing into a buffer.

Cases:
* 'h' (16-bit): packs an integer value into the buffer, increments the buffer pointer by 2.
* 'H' (16-bit unsigned): packs an unsigned integer value into the buffer, increments the buffer pointer by 2.
* 'l' (32-bit): packs a long integer value into the buffer, increments the buffer pointer by 4.
* 'L' (32-bit unsigned): packs an unsigned long integer value into the buffer, increments the buffer pointer by 4.
* 'q' (64-bit): packs a long long integer value into the buffer, increments the buffer pointer by 8.
* 'Q' (64-bit unsigned): packs an unsigned long long integer value into the buffer, increments the buffer pointer by 8.
* 'f' (float-16): packs a float value into the buffer, converts it to IEEE 754 format and then packs it, increments the buffer pointer by 2.
* 'd' (float-32): [no information provided]

Note: The chapter seems to be incomplete, as there is no code for the 'd' case.
Chapter 7. Slightly Advanced Techniques

```
void pack(unsigned char *buf, char *format, ...)
{
    // ...
    case 'c': // char
        size += 1;
        c = va_arg(ap, signed char);
        packi8(buf, c);
        buf += 1;
        break;

    case 'C': // unsigned char
        size += 1;
        C = va_arg(ap, unsigned char);
        packu8(buf, C);
        buf += 1;
        break;

    // ...
}

void unpack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    // ...
    case 'c': // char
        c = va_arg(ap, signed char);
        // ...

    case 'C': // unsigned char
        C = va_arg(ap, unsigned char);
        // ...
}
```

Note: The code is not fully listed in the provided data, but I have summarized what is available.
The code appears to be parsing a formatted string and extracting values from it. The string contains various format specifiers (e.g. 'c', 'C', 'h', 'H', etc.) that indicate how to interpret the following value.

The code uses variadic arguments (`va_start`, `va_arg`) to retrieve values of different types, including:

* Signed and unsigned 8-bit integers
* Signed and unsigned 16-bit integers (int, unsigned int)
* Signed and unsigned 32-bit integers (long int, unsigned long int)
* 64-bit integers (long long int, unsigned long long int)
* Floats (float), doubles (double), and long doubles (long double)
* Characters (char)

The code also defines several variables:

* `fhold`: an unsigned long long integer
* `len` and `maxstrlen`: integers used to store string lengths
* `count`: an integer used for counting something

The code iterates through the formatted string, using a switch statement to determine how to handle each format specifier. For example, when encountering a 'c' or 'C' format specifier, it retrieves a signed or unsigned 8-bit integer from the variadic arguments and assigns it to a corresponding pointer (`c` or `C`).
The chapter discusses slightly advanced techniques. The code defines a switch statement with several cases that handle different types of data.

Cases:
* 'L': unpacks 32-bit unsigned integer and increments buffer by 4.
* 'q', 'Q': unpacks 64-bit signed/unsigned integers and increments buffer by 8.
* 'f': unpacks float, converts it to host byte order using unpack754_16, and increments buffer by 2.
* 'd': unpacks double-precision floating-point number, converts it to host byte order using unpack754_32, and increments buffer by 4.
* 'g': unpacks long double, converts it to host byte order using unpack754_64, and increments buffer by 8.
* 's': unpacks string length, copies the corresponding bytes from the buffer into a character array, and appends a null-terminator.

If the case is not one of these specific types, the code checks if the format character is a digit and updates a variable maxstrlen accordingly.
**Chapter 7: Slightly Advanced Techniques**

The chapter discusses packing and unpacking data using format strings.

**Code Snippet**

The code snippet shows an example of packing data into a buffer `buf` and then unpacking it into variables using the `pack()` and `unpack()` functions. The code uses various data types, including `int8_t`, `int16_t`, `int32_t`, `float32_t`, and `char`.

**Demonstration Program**

The demonstration program packs some data into `buf` and then unpacks it into variables using the format strings `"chhlsf"` and `"chhl96sf"`. The program prints the packed data to the console.

**Security Warning**

The chapter warns about the potential risks of packing and unpacking data from untrusted sources, such as over a network, where malicious users may send badly-constructed packets in an effort to attack the system.
The chapter discusses data encapsulation and how to encode data before sending it. It emphasizes that conforming to specific formats, such as floating point types, integer types, arrays, and raw data, is recommended but not required.

The concept of data encapsulation is explained, which involves adding a header with identifying information or packet length (or both) to the data. The header can be any binary data necessary for the project.

An example of data encapsulation is given in the context of a multi-user chat program that uses SOCK_STREAMs. The program needs to transmit user names and messages to the server, but messages can vary in length. To solve this problem, a packet structure is defined, which includes:

1. len (1 byte, unsigned) - The total length of the packet.
2. name (8 bytes) - The user's name, padded with '\0' if necessary.
3. chatdata (n-bytes) - The data itself, up to 128 bytes.

The example shows how this packet structure would look like for two sample packets.
Chapter 7 discusses slightly advanced techniques for sending and receiving data packets. When sending data, use a command like `sendall()` to ensure that all data is sent even if it takes multiple calls to `send()`. When receiving data, assume that you might receive a partial packet and need to call `recv()` repeatedly until the packet is complete.

Two methods are described for handling incomplete packets:

1. Call `recv()` once to get the packet length, then call it again specifying the remaining length of the packet (possibly repeatedly) until the complete packet is received.
2. Use a buffer large enough to hold two packets and append incoming data to it. Check if the packet is complete by comparing the number of bytes in the buffer with the length specified in the header. If the packet is not complete, keep appending incoming data to the buffer.

Additionally, it's possible that `recv()` might return some of the next packet along with the current packet. To handle this, declare a work array large enough for two packets and append incoming data to it. Check if the packet is complete by comparing the number of bytes in the buffer with the length specified in the header. If the packet is not complete, calculate how many bytes belong to the next packet and clear out the completed packet from the buffer before processing the next one.

The text also mentions that a circular buffer can be used instead of moving the partial second packet to the front of the work buffer, but this topic is considered beyond the scope of the article.
The chapter discusses broadcasting packets using UDP (only) and standard IPv4. Broadcasting allows sending data to multiple hosts at the same time, but requires setting the socket option SO_BROADCAST before sending. This is necessary because broadcasting packets can be received by all systems on the local network, which must then undo encapsulation layers to determine the destination port.

There are two ways to specify the destination address for a broadcast message:

1. Send data to a specific subnet's broadcast address, which is the subnet's network number with all one-bits set for the host portion of the address.
2. Send data to the "global" broadcast address (255.255.255.255), also known as INADDR_BROADCAST.

If SO_BROADCAST is not set before sending a broadcast packet, it will be denied. To send a broadcast packet, the socket option must be set first. This is demonstrated in the example program broadcaster.c, which sets the SO_BROADCAST option and allows broadcasting.
**Code File:** broadcaster.c

**Description:** A datagram "client" like talker.c, but can broadcast.

**Includes:**

* stdio.h
*stdlib.h
*unistd.h
*errno.h
*string.h
*sys/types.h
*sys/socket.h
*netinet/in.h
<arpa/inet.h>
<netdb.h>

**Constants:**

* SERVERPORT (defined as 4950)

**Main Function:**

* argc and argv are used to check the command line arguments.
* sockfd, their_addr, he, numbytes, and broadcast variables are declared.
* If the number of command line arguments is not 3, an error message is printed and the program exits.
* The gethostbyname function is called to retrieve host information.
* A socket is created using the AF_INET address family, SOCK_DGRAM socket type, and 0 protocol.
* setsockopt is used to enable broadcast packets to be sent.
* their_addr is initialized with the address family, port number, and IP address of the server.

**Note:** The code does not contain any executable statements beyond line 53.
Chapter 7: Slightly Advanced Techniques

The code snippet demonstrates a UDP broadcaster program that sends packets to specific IP addresses, including broadcast addresses.

```
76-67:
    Send packet to a specified IP address using sendto()
    Check if sendto() was successful and exit if not
    Print the number of bytes sent and the destination IP address
    Close the socket
    Return 0

Examples:

* broadcaster 192.168.1.2 foo: sends 3 bytes to 192.168.1.2
* broadcaster 192.168.1.255 foo: sends 3 bytes to 192.168.1.255 (broadcast address)
* broadcaster 255.255.255.255 foo: sends 3 bytes to 255.255.255.255 (all hosts on the network)

Notes:

* The listener program can respond to packets sent by the broadcaster.
* Running multiple copies of the listener program on different machines allows it to receive broadcast packets even if only one copy is called.
* Firewalls may block direct packets to a machine, but not broadcast packets.
* Broadcast packets can be a load on the network and should be used sparingly.
```

No assumptions or extra information has been added.
* Common questions and answers:
	+ Header files: Check the manual for your platform, or #include <winsock.h> for Windows.
	+ "Address already in use" error with bind(): Use setsockopt() with SO_REUSEADDR option on listening socket.
	+ List of open sockets: Use netstat command.
	+ View routing table: Run route command (in /sbin), netstat -r, or ip route.
	+ Running client and server programs on one computer: Use loopback network device ("lo" in the routing table) to pretend a network card. Client can talk to server with "client goat" or "client localhost".
	+ Remote side closing connection: recv() will return 0 when remote side has closed connection.
	+ Implementing "ping" utility and raw sockets: Further information available elsewhere (not provided in this chapter).
1. How to change or shorten the timeout on a call to connect():
	* Refer to lib/connect_nonb.c in UNIX Network Programming source code for detailed information.
	* Make a socket descriptor with socket(), set it to non-blocking, and call connect().
	* Use select() with a desired timeout, passing the socket descriptor in both read and write sets.
	* If connection is successful, getsockopt() with SO_ERROR option will return zero if there was no error.
2. How to build for Windows:
	* Delete Windows and install Linux or BSD (jokingly).
	* See the section on building for Windows in the introduction for actual instructions.
3. How to build for Solaris/SunOS:
	* The linker errors occur because Sun boxes don't automatically compile socket libraries.
	* Refer to the section on building for Solaris/SunOS in the introduction for an example of how to resolve this issue.
4. Why select() keeps falling out on a signal:
	* Signals can cause blocked system calls, such as select(), to return -1 with errno set to EINTR.
	* One solution is to use a goto statement to restart the system call after it was interrupted.

Note that the summary only includes the provided text without adding any assumptions or extra information.
* A reader asks how to implement a timeout on a call to recv().
* The response suggests using select() with a timeout parameter for socket descriptors.
* An example implementation of a function called "recvtimeout()" is provided, which wraps the functionality of recv() in a timeout mechanism.
* The function takes four parameters: a socket descriptor (s), a buffer to receive data into (buf), the length of the buffer (len), and a timeout value (timeout).
* The function uses select() to wait until either the specified time has passed or data is available to be received. If the timeout occurs, the function returns -2; if an error occurs, it returns -1.
* A sample call to recvtimeout() is shown, demonstrating how to use the function with a 10-second timeout and handling the return values accordingly (error, timeout, or successful reception of data).
* The return value 0 on a call to recv() indicates that the remote side closed the connection, while -1 means "error". The author chose -2 as their timeout indicator.
* To encrypt or compress data before sending it through a socket, you can use SSL (Secure Sockets Layer) or implement your own compressor/encryption system. The author suggests adding encryption/compression steps to the sequence of operations between the server and client.
* Compressing first, then encrypting, is recommended.
* "PF_INET" and "AF_INET" are related and explained in more detail in the section on socket().
* To write a server that accepts shell commands from a client and executes them, the client sends the command string using send() and closes the connection, while the server receives the command string using recv(), closes the connection, and runs it using system(). The author warns about security risks of allowing arbitrary commands to be executed on the server.

That's the summary!
* Chapter 8: Common Questions

1. Safe execution of commands: It's recommended to add an escape character before non-alphanumeric characters in command arguments to ensure safety.
2. Limited data reception: When receiving data, it may be limited due to Maximum Transmission Unit (MTU) restrictions on physical media. This can be resolved by ensuring all data is sent and using recv() in a loop until all data is read.

3. Missing fork() and sigaction(): On Windows, these functions are not available. Instead, use CreateProcess() or search for POSIX libraries that may have shipped with the compiler.
4. Firewall restrictions: Firewalls are designed to prevent external connections. To bypass this, initiate connections from within the firewall using NAT, proxy, or ask system administrators to create a hole in the firewall.
5. Writing a packet sniffer: A network card can be put into "promiscuous mode" to forward all packets to the operating system. This allows for packet sniffing, but requires knowledge of low-level networking and IP addresses.

Note: No assumptions or extra information has been added.
**Packet Sniffing**

* A packet sniffer works by putting the interface into promiscuous mode, allowing the OS to capture every packet on the wire.
* The method for doing this varies depending on the platform and can be found through online search (e.g. "windows promiscuous ioctl" or Linux man pages).

**Customizing Socket Timeout**

* Setting a custom timeout value for a TCP or UDP socket depends on the system and may require searching for SO_RCVTIMEO and SO_SNDTIMEO.
* On Linux, alarm() or setitimer() can be used as a substitute.

**Available Ports**

* Choosing an available port is not usually an issue, but if using a well-known port (e.g. 80), it's recommended to use the official port number.
* If trying to bind to a port that is already in use, an "Address already in use" error will occur; choose another port.
* A list of official port numbers is maintained by IANA and can be found online.
* Any port over 1023 can be used, but it's recommended to choose one not already in use on the same machine.
The chapter discusses man pages in the Unix world, which are manuals that describe individual functions available for use. The author notes that their own "man pages" are incomplete, only showing basic information from the guide, and may not be relevant to all systems. They also mention that there are many more man pages than what is provided, and that they may differ between systems.

The chapter then introduces a specific man page for the "accept()" function, which accepts an incoming connection on a listening socket. The author notes that their version of the man page is geared towards network programming and includes examples.

Finally, the author warns readers to always include error checking when making system calls, unless they are absolutely sure it will not fail.
**Synopsis**

* `accept(int s, struct sockaddr *addr, socklen_t *addrlen)`

**Description**

* Accepts an incoming connection on a listening socket (`s`) and returns a new socket descriptor for subsequent communication with the client.
* The old socket remains available for further `accept()` calls.

**Parameters**

* `s`: The listen()ing socket descriptor
* `addr`: Filled in with the address of the connecting site
* `addrlen`: Filled in with the size of the structure returned in `addr`

**Return Value**

* Returns the newly connected socket descriptor, or -1 on error with errno set appropriately.

Note: This summary does not include any additional information beyond what is provided in the original text.
**Chapter 9: Man Pages**

**Section: bind()**

* Synopsis: `int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen);`
* Description: The `bind()` call associates a socket with an IP address and port number.
* Usage:
	1. Call `getaddrinfo()` to load up a `struct sockaddr` with destination address and port information.
	2. Call `socket()` to get a socket descriptor.
	3. Pass the socket and address into `bind()`.
* Notes:
	+ If you don't know your IP address, pass the `AI_PASSIVE` flag in the hints parameter to `getaddrinfo()`.
	+ The special value loaded into the struct sockaddr's IP address is:
		- In IPv4: `INADDR_ANY`
		- In IPv6: `in6addr_any` or `IN6ADDR_ANY_INIT`
	+ Set the `addrlen` parameter to `sizeof my_addr`.

**See Also**

* `socket()`, `getaddrinfo()`, `listen()`, `struct sockaddr_in`

Let me know if you'd like me to help with anything else!
**Chapter 9. Man Pages**

**Return Value**
Returns zero on success, or -1 on error (and errno will be set accordingly).

**Example**

1. Modern way of doing things with `getaddrinfo()`:
	* Load up address structs with `getaddrinfo()`.
	* Make a socket.
	* Bind it to the port passed in to `getaddrinfo()`.

2. Example of packing a struct by hand, IPv4:
	* Create a `sockaddr_in` structure.
	* Set the family, port, and IP address (or use `INADDR_ANY` for automatic selection).
	* Make a socket and bind it to the packed struct.

**See Also**

* `getaddrinfo()`
* `socket()`
* `struct sockaddr_in`
* `struct in_addr`

Note: I did not add any explanations or descriptions, only summarized the core information provided.
**connect()**

* Synopsis: `int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);`
* Description: Once a socket descriptor is built with the `socket()` call, use `connect()` to connect it to a remote server. Pass the socket descriptor and the address of the server, along with the length of the address.
* If not bound, the socket is automatically bound to the local IP address and a random port.
* Once connected, you can send and receive data using `send()` and `recv()`.
* Special note: For UDP sockets, you can also use `sendto()` and `recvfrom()`.
* Return Value: Returns 0 on success or -1 on error (with errno set accordingly).
* Example:
```c
struct addrinfo hints, *res;
int sockfd;

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo("www.example.com", "http", &hints, &res);

// make a socket:
```
Note: This summary only includes the information provided in the original text and does not add any assumptions or extra information.
**Man Pages**

* Chapter 9: Man Pages
* sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)
* connect(sockfd, res->ai_addr, res->ai_addrlen)

**close() Function**

* Synopsis: Close a socket descriptor
* Description:
	+ After using a socket, you can close it to free up resources.
	+ The remote side can detect the closure by checking for return values of recv() or send().
* Return Value: Returns zero on success, or -1 on error (errno set accordingly)
* Example:

```c
s = socket(PF_INET, SOCK_DGRAM, 0);
// a whole lotta stuff...
close(s);
```

**Note**: For Windows users, the function to use is called `closesocket()`, not `close()`.
**getaddrinfo()**

* Synopsis:
```
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *nodename, const char *servname,
                const struct addrinfo *hints, struct addrinfo **res);
```
* Description: Returns information about a host name and/or service and loads up a `struct sockaddr` with the result.
* Parameters:
	+ `nodename`: The host name (e.g. "www.example.com") or IP address (e.g. "192.0.2.1").
	+ `servname`: The port number (e.g. "80") or service name (e.g. "http", "tftp", etc.).
	+ `hints`: A pointer to a `struct addrinfo` that specifies the type of information to return.
	+ `res`: A pointer to a `struct addrinfo` that will be filled with the result.

**Structures**

* `struct addrinfo`:
	+ `ai_flags`: Flags (e.g. AI_PASSIVE, AI_CANONNAME).
	+ `ai_family`: Address family (e.g. AF_INET, AF_INET6).
	+ `ai_socktype`: Socket type (e.g. SOCK_STREAM, SOCK_DGRAM).
	+ `ai_protocol`: Protocol number (e.g. 0 for auto, IPPROTO_TCP, IPPROTO_UDP).
	+ `ai_addrlen`: Length of the `ai_addr` field.
	+ `ai_canonname`: Canonical name for the host name.
	+ `ai_addr`: A binary address.
	+ `ai_next`: Pointer to the next structure in a linked list.

**Functions**

* `freeaddrinfo(struct addrinfo *ai)`: Frees memory allocated by `getaddrinfo()`.
* `gai_strerror(int ecode)`: Returns an error message for a specific error code.
The chapter discusses the use of hints in the getaddrinfo() function. The hints structure has several fields that need to be set up before use, including:

* ai_flags: which can be set to various flags using bitwise-ORing, such as AI_CANONNAME and AI_PASSIVE.
* ai_family: which should be set to AF_UNSPEC for both IPv4 and IPv6 addresses, or AF_INET or AF_INET6 for one specific type of address.
* socktype: which should be set to SOCK_STREAM or SOCK_DGRAM depending on the type of socket desired.
* protocol: which can be left at 0 to automatically choose the protocol.

After setting up the hints structure, the getaddrinfo() function is called with the hints and other parameters. The result is a linked list of struct addrinfos, which contains information about the addresses that match the hints.

The text also discusses error handling, stating that if the function returns nonzero, it can be used to determine the printable version of the error code using gai_strerror(). An example is provided for a client connecting to a server using a stream socket.
Chapter 9. Man Pages

Code for a client and server waiting for connections.

**Client Code:**

* Uses `getaddrinfo` to get a list of addresses that match the server's IP address.
* Loops through the results, trying to connect to each one using `socket` and `connect`.
* If connection fails, prints an error message and continues to next result.
* If connection succeeds, breaks out of loop.

**Server Code:**

* Uses `getaddrinfo` to get a list of addresses that match the server's IP address on port 3490.
* Loops through the results, trying to bind to each one using `socket`.
* If binding fails, prints an error message and continues to next result.

Note: The code provided is incomplete for the server side, it seems like there might be some missing parts.
**Man Pages**

* 92: No content
* 25-27: No content
* 26: If `bind` fails, close the socket and print an error message.
* 28-31: Error handling for failed bind operation
* 32-34: Exit if a successful bind is not achieved
* 35-40: Error handling for failed bind or list iteration

**gethostname()**

* Returns the name of the system
* Synopsis: `int gethostname(char *name, size_t len);`
* Description: Get the host name and use it to find the IP address with `gethostbyname()`
* Parameters:
	+ `name`: pointer to a buffer to hold the host name
	+ `len`: size of the buffer in bytes
* Return Value: 0 on success, -1 on error (with `errno` set accordingly)
**Man Pages: gethostbyname() and gethostbyaddr()**

**Example**
```c
char hostname[128];
gethostname(hostname, sizeof hostname);
printf("My hostname: %s\n", hostname);
```
**See Also**
* `gethostbyname()`
* `gethostbyaddr()`

**Synopsis**

`#include <sys/socket.h>`
`#include <netdb.h>`

```c
struct hostent *gethostbyname(const char *name); // DEPRECATED!
struct hostent *gethostbyaddr(const char *addr, int len, int type);
```
**Description**
These functions map back and forth between host names and IP addresses.

* `gethostbyname()` maps a hostname to an IP address and returns a struct hostent.
* `gethostbyaddr()` maps an IP address (struct in_addr or struct in6_addr) to a hostname.

Note: These functions are superseded by `getaddrinfo()` and `getnameinfo()`.
**Field Descriptions**

* `char *h_name`: The real canonical host name.
* `char **h_aliases`: A list of aliases that can be accessed with arrays—the last element is NULL.
* `int h_addrtype`: The result's address type, which really should be AF_INET for our purposes.
* `int length`: The length of the addresses in bytes, which is 4 for IP (version 4) addresses.
* `char **h_addr_list`: A list of IP addresses for this host. Although this is a char**, it's really an array of struct in_addr*s in disguise. The last array element is NULL.
* `h_addr`: A commonly defined alias for h_addr_list[0]. If you just want any old IP address for this host (yeah, they can have more than one) just use this field.

**Return Value**

* Returns a pointer to a resultant struct hostent on success, or NULL on error.

**Error Reporting**

* Instead of the normal perror() and all that stuff you'd normally use for error reporting, these functions have parallel results in the variable h_errno, which can be printed using the functions herror() or hstrerror().
* These work just like the classic errno, perror(), and strerror() functions you're used to.

**Example**

1. This is a deprecated method of getting host names; use getaddrinfo() instead!
2-27. Code snippet showing how to use the gethostbyname() function.
**Chapter 9: Man Pages**

* A C program that prints information about a host:
	+ Prints the official name of the host
	+ Prints IP addresses of the host
* Note: This has been superseded by getnameinfo()
* Example code using `gethostbyaddr()` function:
	1. Convert IPv4 address "192.0.2.34" to `struct in_addr`
	2. Use `gethostbyaddr()` to get host name for the IP address
	3. Print the host name
* Example code using `gethostbyaddr()` function (IPv6):
	1. Convert IPv6 address "2001:db8:63b3:1::beef" to `struct in6_addr`
	2. Use `gethostbyaddr()` to get host name for the IP address
	3. Print the host name

**getnameinfo()**

* Synopsis:
	+ `#include <sys/socket.h>`
	+ `#include <netdb.h>`
	+ `int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, size_t servlen, int flags);`
* Description:
	+ The opposite of `getaddrinfo()`, takes an already loaded `struct sockaddr` and does a name and service name lookup on it.
	+ Replaces the old `gethostbyaddr()` and `getservbyport()` functions.
**getnameinfo()**

* Takes a pointer to a struct sockaddr (which can be casted to struct sockaddr_in or struct sockaddr_in6) in the sa parameter, and the length of that struct in salen.
* Writes the resultant host name and service name to the area pointed to by the host and serv parameters.
* Requires specification of max lengths of these buffers in hostlen and servlen.
* Flags can be passed: NI_NOFQDN for just the host name, NI_NAMEREQD for failure if DNS lookup fails.
* Returns zero on success or non-zero on error, with non-zero values passable to gai_strerror().

**Example**
```c
struct sockaddr_in6 sa;
char host[1024];
char service[20];

getnameinfo(&sa, sizeof sa, host, sizeof host, service, sizeof service, 0);
printf("host: %s\n", host); // e.g. "www.example.com"
printf("service: %s\n", service); // e.g. "http"
```

**See Also**
* getaddrinfo()
* gethostbyaddr()
**getpeername()**

Returns a struct sockaddr_in filled with information about the machine you're connected to.

**Why it's called "name"**: The term "name" covers all cases of sockets, including IP address and port for Internet Sockets like those used in this guide.

**Return Value**: Returns zero on success or -1 on error (with errno set accordingly).

**Example Code**

```c
// assume s is a connected socket
socklen_t len;
struct sockaddr_storage addr;
char ipstr[INET6_ADDRSTRLEN];
int port;

len = sizeof addr;
getpeername(s, (struct sockaddr*)&addr, &len);

if (addr.ss_family == AF_INET) {
    struct sockaddr_in *s = (struct sockaddr_in *)&addr;
    port = ntohs(s->sin_port);
    inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);
} else { // AF_INET6
    struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;
    port = ntohs(s->sin6_port);
    inet_ntop(AF_INET6, &s->sin6_addr, ipstr, sizeof ipstr);
}
printf("Peer IP address: %s\n", ipstr);
printf("Peer port: %d\n", port);
```

**See Also**: gethostname(), gethostbyname(), gethostbyaddr()

**errno**: Holds the error code for the last system call.
**Synopsis**
The `errno` variable holds error information for system calls, such as socket() and listen(). It returns -1 on error and sets the exact value to indicate which error occurred.

**Description**
Error codes are listed in the header file errno.h. perror() or strerror() can be used to get a human-readable version of the error. For multithreading, `errno` is defined in a threadsafe manner.

**Return Value**
The value of `errno` is the latest error that occurred, which might be "success" if the last action succeeded.

**Example**
A simple example of using `perror()` to handle an error when calling socket() and select().
**Chapter 9: Man Pages**

**fcntl() Function**

* Synopsis: `int fcntl(int s, int cmd, long arg);`
* Description: Used for file locking and other file-oriented operations, including socket-related functions.
* Parameters:
	+ `s`: Socket descriptor
	+ `cmd`: Command to be executed (e.g. F_SETFL)
	+ `arg`: Argument corresponding to the command

**Socket-Related Commands**

* `O_NONBLOCK`: Set the socket to non-blocking mode
* `O_ASYNC`: Set the socket for asynchronous I/O, which raises SIGIO when data is ready to be received

**Return Value**

* Returns 0 on success, -1 on error with errno set accordingly

**Example Code**

```
int s = socket(PF_INET, SOCK_STREAM, 0);
fcntl(s, F_SETFL, O_NONBLOCK); // Set to non-blocking
fcntl(s, F_SETFL, O_ASYNC); // Set to asynchronous I/O
```

**See Also**

* Blocking
* send()
**Synopsis**

The chapter discusses five functions: `htonl`, `htons`, `ntohl`, and `ntohs` that convert between host byte order and network byte order for 16-bit (short) and 32-bit (long) integers.

**Description**

Different computers use different byte orderings, which can cause issues when exchanging data. To resolve this, a standard "big-endian" or "network byte order" was agreed upon. The functions in this chapter convert between host byte order and network byte order.

**Functions**

* `htonl`: host to network long
* `htons`: host to network short
* `ntohl`: network to host long
* `ntohs`: network to host short

**Return Value**

Each function returns the converted value.

**Example**

An example is provided, but it is incomplete. It shows the declaration of variables and calls to the functions, but does not show how they are used in a complete program.
**Functions:**

1. `inet_ntoa(struct in_addr in)`: Converts a network address in a struct in_addr to a dots-and-numbers format string.
2. `int inet_aton(const char *cp, struct in_addr *inp)`: Converts from a dots-and-numbers string into a in_addr_t (the type of the field s_addr in struct in_addr).
3. `in_addr_t inet_addr(const char *cp)`: Older function that does basically the same thing as inet_aton(). Theoretically deprecated, but widely used.

**Synopsis:**

* Includes `<sys/socket.h>`, `<netinet/in.h>`, and `<arpa/inet.h>` headers.
* Use of these functions is deprecated because they don't handle IPv6; use `inet_pton()` or `inet_ntop()` instead.

**Description:**

These functions convert between a struct in_addr (part of struct sockaddr_in) and a string in dots-and-numbers format. They are useful for converting IP addresses from strings to structs and vice versa.

**Return Value:**

* `inet_aton()` returns non-zero if the address is valid, zero if invalid.
* `inet_ntoa()` returns a static buffer that is overwritten with each call to the function.

Note: The text warns against using these functions due to their lack of IPv6 support and suggests using `inet_pton()` or `inet_ntop()` instead.
**inet_addr()**

* Returns the address as an in_addr_t, or -1 if there's an error.
* Example: `antelope.sin_addr.s_addr = inet_addr("10.0.0.1");`

**Example using inet_aton() and inet_ntoa()**

1. Define a struct sockaddr_in antelope.
2. Convert the string "10.0.0.1" to an IP address using inet_aton().
3. Store the IP address in antelope.sin_addr.
4. Convert the IP address back to a string using inet_ntoa().
5. Print the resulting string.

**See Also**

* inet_ntop(), inet_pton(), gethostbyname(), gethostbyaddr()

**inet_ntop() and inet_pton()**

* Synopsis: `#include <arpa/inet.h>` `const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);` `int inet_pton(int af, const char *src, void *dst);`
* Description: Convert IP addresses to human-readable form and back.
* Notes:
	+ "n" stands for "network", and "p" for "presentation".
	+ Inet_ntop() takes the address family in the af parameter (either AF_INET or AF_INET6).
	+ The src parameter should be a pointer to either a struct in_addr or struct in6_addr containing the address to convert.
	+ The dst and size parameters are the pointer to the destination string and the maximum length of that string.
Chapter 9. Man Pages

What should the maximum length of the dst string be?
The maximum lengths are INET_ADDRSTRLEN for IPv4 and INET6_ADDRSTRLEN for IPv6.

What is the opposite function to inet_ntop()?
The opposite function is inet_pton(), which takes an address family, a pointer to a string containing the IP address in printable form, and a destination parameter to store the result.

Return Value
inet_ntop() returns the dst parameter on success or NULL on failure (and sets errno).
inet_pton() returns 1 on success, -1 if there was an error (sets errno), or 0 if the input isn’t a valid IP address.

Example
IPv4 demo of inet_ntop() and inet_pton():
- Store IP address in struct sockaddr_in.
- Use inet_pton() to convert string to struct sockaddr_in.
- Use inet_ntop() to convert struct sockaddr_in back to string.
Prints "192.0.2.33".

IPv6 demo of inet_ntop() and inet_pton():
- Store IP address in struct sockaddr_in6.
- Use inet_pton() to convert string to struct sockaddr_in6.
- Use inet_ntop() to convert struct sockaddr_in6 back to string.
Prints "2001:db8:8714:3a90::12".
**Man Page: get_ip_str**

* Function: `get_ip_str`
* Parameters:
	+ `sa`: `const struct sockaddr *` - a pointer to a socket address structure
	+ `s`: `char *` - a string buffer
	+ `maxlen`: `size_t` - the maximum length of the string buffer
* Returns: `char *`

The function converts a socket address into a string representation and returns it.

**Man Page: listen**

* Function: `listen`
* Parameters:
	+ `s`: `int` - a socket descriptor
	+ `backlog`: `int` - the maximum number of pending connections before rejecting new ones
* Returns: `int`

The function tells a socket to listen for incoming connections. It requires a socket descriptor created with `socket()` and specifies the maximum number of pending connections (backlog) before rejecting new ones. The function should be called after binding the socket with `bind()` to a specific port number.

Let me know if you have any further requests!
**Chapter 9: Man Pages**

**Return Value**
Returns zero on success, or -1 on error (and errno will be set accordingly).

**Example**
A code snippet demonstrating the use of `getaddrinfo()` and `socket()` to create a server socket:
```c
struct addrinfo hints, *res;
int sockfd;

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;

getaddrinfo(NULL, "3490", &hints, &res);

sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
bind(sockfd, res->ai_addr, res->ai_addrlen);
listen(sockfd, 10); // set up to be a server (listening) socket
```
**See Also**
`accept()`, `bind()`, `socket()` - related functions.
`perror()`, `strerror()` - functions for printing error messages.

**Synopsis**
Header files:
```c
#include <stdio.h>
#include <string.h> // for strerror()
```
Functions:
```c
void perror(const char *s);
char *strerror(int errnum);
```
Description: The `perror()` and `strerror()` functions print error messages in a human-readable format, making it easier to understand errors returned by other functions.
**perror()**

* A function that prints an error message given an errno value
* The parameter `s` can be passed to print additional description before the error message; if left as NULL, no additional text will be printed
* Returns nothing

**strerror()**

* Similar to perror(), but returns a pointer to the error message string for a given value (usually the variable `errno`)
* Return Value: a pointer to the error message string

**Example using perror() and strerror()**

* Example 1:
	+ Use perror() to print an error message when socket creation fails
	+ Use strerror() to print an error message when listening on a socket fails
* Examples:
	+ Code snippet using perror()
	+ Code snippet using strerror()

**poll()**

* Synopsis: `int poll(struct pollfd *ufds, unsigned int nfds, int timeout)`
* Description: Similar to select(), watches sets of file descriptors for events such as incoming data ready to recv(), socket ready to send() data to, etc.
**poll() Function**

* Pass an array of `struct pollfds` (`ufds`) with socket descriptors and a timeout in milliseconds (1000 milliseconds = 1 second)
* Timeout can be negative to wait forever
* If no event occurs on any descriptor by the timeout, `poll()` returns

**Struct pollfd**

* Each element represents one socket descriptor with three fields:
	+ `int fd`: socket descriptor (set to a negative number to ignore the struct and set `revents` to 0)
	+ `short events`: bitmap of events to monitor
	+ `short revents`: bitmap of events that occurred when `poll()` returns

**Events**

* Bitwise-OR the following macros in `events` field:
	+ `POLLIN`: alert for data ready to receive on socket
	+ `POLLOUT`: alert for ability to send data without blocking on socket
	+ `POLLPRI`: alert for out-of-band data ready to receive on socket

**Return Value**

* Returns the number of elements in `ufds` array with events that occurred; can be 0 if timeout occurred
* Returns -1 on error, with `errno` set accordingly
**Chapter 9: Man Pages**

* **recv() and recvfrom()**: Receive data on a socket
	+ Synopsis:
		- `#include <sys/types.h>`
		- `#include <sys/socket.h>`
		- `ssize_t recv(int s, void *buf, size_t len, int flags);`
		- `ssize_t recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);`

**Example Code**

* **Using poll() to wait for socket events**
	+ Create a set of file descriptors (ufds) and initialize them
		- `ufds[0].fd = s1;`
		- `ufds[0].events = POLLIN | POLLPRI;` (check for normal or out-of-band data)
		- `ufds[1].fd = s2;`
		- `ufds[1].events = POLLIN;` (check for just normal data)
	+ Wait for events on the sockets using poll() with a 3.5 second timeout
		- `rv = poll(ufds, 2, 3500);`
	+ Check for events on the sockets and handle accordingly
		- If an error occurs in poll(), print an error message
		- If no data is received after 3.5 seconds, print a timeout message
		- Otherwise, check for events on each socket and handle normal or out-of-band data using recv()
**Chapter 9: Man Pages**

**Description**: Once connected to a remote side using a socket, you can read incoming data using `recv()` for TCP SOCK_STREAM sockets and `recvfrom()` for UDP SOCK_DGRAM sockets.

**Functions**: Both functions take four parameters:

* `s`: the socket descriptor
* `buf`: a pointer to the buffer where data will be stored
* `len`: the size of the buffer in bytes
* `flags`: a set of flags that control how the function works

`recvfrom()` also takes two additional parameters:

* `from`: a struct sockaddr* that provides information about the sender
* `fromlen`: the size of the `from` struct sockaddr*

**Flags**: The following flags can be used to modify the behavior of `recv()` and `recvfrom()`:

* `MSG_OOB`: Receive out-of-band data
* `MSG_PEEK`: Peek at the buffer without removing the data
* `MSG_WAITALL`: Wait until all specified data is received

**Return Value**: The functions return the number of bytes actually received (which may be less than requested) or -1 on error.

**Example Code**: A sample code snippet demonstrating the use of `recv()` with stream sockets.
**Chapter 9: Man Pages**

**Code Snippets**

1. Using `getaddrinfo` and `connect` to establish a connection:
```
getaddrinfo("www.example.com", "3490", &hints, &res);
sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
connect(sockfd, res->ai_addr, res->ai_addrlen);
```

2. Using `recv` to receive data:
```
byte_count = recv(sockfd, buf, sizeof buf, 0);
printf("recv()'d %d bytes of data in buf\n", byte_count);
```

3. Using datagram sockets and `recvfrom`:
```
struct addrinfo hints, *res;
int sockfd;
int byte_count;
socklen_t fromlen;
struct sockaddr_storage addr;
char buf[512];
char ipstr[INET6_ADDRSTRLEN];

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;

getaddrinfo(NULL, "4950", &hints, &res);
sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
bind(sockfd, res->ai_addr, res->ai_addrlen);

fromlen = sizeof addr;
byte_count = recvfrom(sockfd, buf, sizeof buf, 0, &addr, &fromlen);
printf("recv()'d %d bytes of data in buf\n", byte_count);
printf("from IP address %s\n",
inet_ntop(addr.ss_family,
    addr.ss_family == AF_INET?
        ((struct sockaddr_in *)&addr)->sin_addr:
        ((struct sockaddr_in6 *)&addr)->sin6_addr,
    ipstr, sizeof ipstr));
```

**See Also**

* `send()`, `sendto()`, `select()`, `poll()`, Blocking

**Note**: There is also a separate section on `select()` that checks if socket descriptors are ready to read/write.
**Synopsis**

The `select` function allows checking multiple sockets for readiness without blocking. It takes four parameters: `n`, `readfds`, `writefds`, and `exceptfds`. The function returns the number of descriptors in the set on success, 0 if the timeout was reached, or -1 on error.

**Description**

The `select` function allows checking multiple sockets for readiness without blocking. It takes four parameters: `n`, `readfds`, `writefds`, and `exceptfds`. The function returns the number of descriptors in the set on success, 0 if the timeout was reached, or -1 on error.

**Macros**

* `FD_SET(int fd, fd_set *set)`: Add `fd` to the set.
* `FD_CLR(int fd, fd_set *set)`: Remove `fd` from the set.
* `FD_ISSET(int fd, fd_set *set)`: Return true if `fd` is in the set.
* `FD_ZERO(fd_set *set)`: Clear all entries from the set.

**Return Value**

The function returns:

* The number of descriptors in the set on success
* 0 if the timeout was reached
* -1 on error (and sets `errno` accordingly)

**Note for Linux users**

Linux's `select` function can return "ready-to-read" and then not actually be ready to read, causing a subsequent `read` call to block. This can be worked around by setting the O_NONBLOCK flag on the receiving socket.
**Example**
```c
int s1, s2, n;
fd_set readfds;
struct timeval tv;
char buf1[256], buf2[256];

// assume sockets connected to server
s1 = ...; // socket 1
s2 = ...; // socket 2
connect(s1, ...); // connect socket 1
connect(s2, ...); // connect socket 2

FD_ZERO(&readfds); // clear set ahead of time
FD_SET(s1, &readfds); // add descriptor s1 to set
FD_SET(s2, &readfds); // add descriptor s2 to set
n = s2 + 1; // use s2 as "greater" for select()

tv.tv_sec = 10;
tv.tv_usec = 500000; // wait until either socket has data ready (timeout 10.5 seconds)
rv = select(n, &readfds, NULL, NULL, &tv);

if (rv == -1) {
    perror("select"); // error occurred in select()
} else if (rv == 0) {
    printf("Timeout occurred! No data after 10.5 seconds.\n");
} else {
    // one or both of the descriptors have data
    if (FD_ISSET(s1, &readfds)) {
        recv(s1, buf1, sizeof buf1, 0);
    }
    if (FD_ISSET(s2, &readfds)) {
        recv(s2, buf2, sizeof buf2, 0);
    }
}
```
**See Also**

* poll()
* setsockopt(), getsockopt()
**Synopsis**

* Includes headers: `<sys/types.h>` and `<sys/socket.h>`
* Functions: `getsockopt` and `setsockopt`
	+ `getsockopt`: returns socket option value
	+ `setsockopt`: sets socket option value

**Description**

* Sockets are configurable using these functions
* Parameters:
	+ `s`: the socket being manipulated
	+ `level`: set to `SOL_SOCKET`
	+ `optname`: specifies the option name (e.g. SO_BINDTODEVICE, SO_REUSEADDR)
	+ `optval`: a pointer to an integer value or NULL if no value is needed
	+ `optlen`: length of `optval` (or maximum size for getsockopt())

**Options**

* `SO_BINDTODEVICE`: binds socket to symbolic device name (e.g. eth0)
* `SO_REUSEADDR`: allows multiple sockets to bind to same port (unless already in use)
* `SOCK_DGRAM`: enables sending/receiving UDP datagrams to/from broadcast address (only for SOCK_DGRAM sockets)

**Return Value**

* 0 on success, -1 on error with `errno` set accordingly
**Man Pages**

* **setsockopt**: Sets a socket option.
	+ Example 1: Setting SO_REUSEADDR to true (1).
	+ Example 2: Binding a socket to a device name ("eth1").
	+ Example 3: Checking if the SO_BROADCAST flag is set.
* **send** and **sendto**: Send data over a socket.
	+ Synopsis: `ssize_t send(int s, const void *buf, size_t len, int flags);` and `ssize_t sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);`
	+ Description: Send data to a socket. `send()` is used for TCP SOCK_STREAM connected sockets, while `sendto()` is used for UDP SOCK_DGRAM unconnected datagram sockets.
	+ Parameters:
		- `s`: The socket.
		- `buf`: A pointer to the data to be sent.
		- `len`: The number of bytes to be sent.
		- `flags`: Allows specification of additional information about how the data is to be sent.
**Macro**

* **MSG_OOB**: Send as “out of band” data. The receiver will receive the signal SIGURG and can then receive this data without first receiving all the normal data in the queue.
* **MSG_DONTROUTE**: Don’t send this data over a router, just keep it local.
* **MSG_DONTWAIT**: If send() would block because outbound traffic is clogged, have it return EAGAIN.
* **MSG_NOSIGNAL**: Prevents raising of the signal SIGPIPE if you send to a remote host which is no longer recv()ing.

**Return Value**

* Returns the number of bytes actually sent, or -1 on error (and errno will be set accordingly).
* The number of bytes actually sent might be less than the number you asked it to send.
* If the socket has been closed by either side, the process calling send() will get the signal SIGPIPE (unless MSG_NOSIGNAL flag is used).

**Example**

* Example code using TCP stream sockets and UDP datagram sockets to demonstrate sending data with various flags.
**Man Page: shutdown()**

* Synopsis: `int shutdown(int s, int how);`
* Description: Stop further sends and receives on a socket.
* Parameters:
	+ `s`: the socket to perform this action on
	+ `how`: specifies what action to take (SHUT_RD, SHUT_WR, or SHUT_RDWR)
* Return Value: returns 0 on success, -1 on error (with errno set accordingly)
* Example:
```
int s = socket(PF_INET, SOCK_STREAM, 0);
// ...do some send()s and stuff...
shutdown(s, SHUT_WR); // don't allow any more sends()
```
* See Also: `recv()`, `recvfrom()`, `close()`
**Synopsis**

`int socket(int domain, int type, int protocol);`

**Description**

Allocates a new socket descriptor that can be used for subsequent calls to `listen()`, `bind()`, `accept()`, and other functions.

**Parameters**

* `domain`: The type of socket (e.g. PF_INET for IPv4, PF_INET6 for IPv6)
* `type`: The type of socket (e.g. SOCK_STREAM for reliable TCP sockets, SOCK_DGRAM for unreliable fast UDP sockets)
* `protocol`: The protocol to use with the socket (e.g. 0 for automatic selection)

**Return Value**

The new socket descriptor, or -1 on error with errno set accordingly.

**Example**

A sample code snippet showing how to use `getaddrinfo()` to fill in the parameters and create a socket:

```c
struct addrinfo hints;
int sockfd;

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // AF_INET, AF_INET6, or AF_UNSPEC
hints.ai_socktype = SOCK_STREAM; // SOCK_STREAM or SOCK_DGRAM

getaddrinfo("www.example.com", "3490", &hints, &res);
```
**Chapter 9: Man Pages**

* **Section:** Man Pages
* **Pages:** 118, 12
* **Code:**
	+ `sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);`
	+ See Also: `accept()`, `bind()`, `getaddrinfo()`, `listen()`

**Structures for handling internet addresses**

* **Synopsis:** `#include <netinet/in.h>`
* **struct sockaddr**
	+ `unsigned short sa_family;` // address family, AF_xxx
	+ `char sa_data[14];` // 14 bytes of protocol address
* **IPv4 structures:**
	+ `struct sockaddr_in`
		- `short sin_family;` // e.g. AF_INET, AF_INET6
		- `unsigned short sin_port;` // e.g. htons(3490)
		- `struct in_addr sin_addr;` // see struct in_addr, below
		- `char sin_zero[8];` // zero this if you want to
	+ `struct in_addr`
		- `unsigned long s_addr;` // load with inet_pton()
* **IPv6 structures:**
	+ `struct sockaddr_in6`
		- `u_int16_t sin6_family;` // address family, AF_INET6
		- `u_int16_t sin6_port;` // port number, Network Byte Order
		- `u_int32_t sin6_flowinfo;` // IPv6 flow information
		- `struct in6_addr sin6_addr;` // IPv6 address
		- `u_int32_t sin6_scope_id;` // Scope ID
	+ `struct in6_addr`
		- [no description provided]
**Chapter 9: Man Pages**

* **Structures**
	+ `struct sockaddr`: general socket address holding structure, big enough to hold either `struct sockaddr_in` or `struct sockaddr_in6` data.
	+ `struct sockaddr_in`: used with IPv4 addresses (e.g. "192.0.2.10"), holds an address family (AF_INET), a port in `sin_port`, and an IPv4 address in `sin_addr`.
	+ `struct sockaddr_in6`: used for IPv6, similar to `struct sockaddr_in` but with different fields.
	+ `struct sockaddr_storage`: large enough to hold both `struct sockaddr_in` and `struct sockaddr_in6` data, can be passed to `accept()` or `recvfrom()` for IP version-agnostic code.

**Description**

* These structures are used in syscalls and functions that deal with internet addresses.
* `getaddrinfo()` is often used to fill these structures out.
* It's safe to cast a pointer of one type (e.g. `struct sockaddr_in*`) to another type (e.g. `struct sockaddr*`) without harm.

**Notes**

* The `sin_zero` field in `struct sockaddr_in` doesn't seem to be necessary, but setting it to zero using `memset()` may be done if desired.
* The `struct in_addr` is a weird beast on different systems, and only the `s_addr` field should be used.
**IPv4:**

1. Define `ip4addr` structure:
	* `sin_family = AF_INET`
	* `sin_port = htons(3490)`
	* `sin_addr = inet_pton(AF_INET, "10.0.0.1", &ip4addr.sin_addr)`
2. Create socket `s`:
	* `socket(PF_INET, SOCK_STREAM, 0)`
3. Bind `s` to address and port:
	* `bind(s, (struct sockaddr*)&ip4addr, sizeof ip4addr)`

**IPv6:**

1. Define `ip6addr` structure:
	* `sin6_family = AF_INET6`
	* `sin6_port = htons(4950)`
	* `sin6_addr = inet_pton(AF_INET6, "2001:db8:8714:3a90::12", &ip6addr.sin6_addr)`
2. Create socket `s`:
	* `socket(PF_INET6, SOCK_STREAM, 0)`
3. Bind `s` to address and port:
	* `bind(s, (struct sockaddr*)&ip6addr, sizeof ip6addr)`

**See Also**

* `accept()`
* `bind()`
* `connect()`
* `inet_aton()`
* `inet_ntoa()`
**Chapter 10: More References**

This chapter provides additional resources for learning more about Unix network programming.

**Books**

* "Unix Network Programming, volumes 1-2" by W. Richard Stevens (ISBNs: 978-01314115551 and 978-01308108162)
* "Internetworking with TCP/IP, volume I" by Douglas E. Comer (ISBN: 978-01360853003)
* "TCP/IP Illustrated, volumes 1-3" by W. Richard Stevens and Gary R. Wright (ISBNs: 978-02016334674, 978-02016335425, and 978-02016349526; also available as a 3-volume set with ISBN 978-02017763177)
* "TCP/IP Network Administration" by Craig Hunt (ISBN: 978-05960029788)
* "Advanced Programming in the UNIX Environment" by W. Richard Stevens (ISBN: 978-03216377349)

**Web References**

The following web links are provided:

1. BSD Sockets: A Quick And Dirty Primer
2-10. URLs for various Unix system programming resources, including tutorials and documentation on TCP/IP and socket programming.

11. An additional URL to a page on sockets: https://cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html
The chapter provides additional references for understanding Unix sockets, TCP/IP, and related protocols.

* Relevant FAQs:
	+ Unix Socket FAQ
	+ TCP/IP FAQ
	+ Winsock FAQ
* Relevant Wikipedia pages:
	+ Berkeley Sockets
	+ Internet Protocol (IP)
	+ Transmission Control Protocol (TCP)
	+ User Datagram Protocol (UDP)
	+ Client-Server
	+ Serialization
* RFCs (Requests for Comments):
	+ Links to several RFCs, including:
		- RFC 121: The First RFC
		- RFC 768: User Datagram Protocol (UDP)
		- RFC 791: Internet Protocol (IP)
		- RFC 793: Transmission Control Protocol (TCP)
		- RFC 854: Telnet Protocol
		- RFC 959: File Transfer Protocol (FTP)
		- RFC 1350: Trivial File Transfer Protocol (TFTP)
		- RFC 1459: Internet Relay Chat Protocol (IRC)
		- RFC 1918: Address Allocation for Private Internets

Note that I did not add any assumptions or extra information, and only summarized the provided data.
**List of RFCs**

1. RFC 2131 - Dynamic Host Configuration Protocol (DHCP)
2. RFC 2616 - Hypertext Transfer Protocol (HTTP)
3. RFC 2821 - Simple Mail Transfer Protocol (SMTP)
4. RFC 3330 - Special-Use IPv4 Addresses
5. RFC 3493 - Basic Socket Interface Extensions for IPv6
6. RFC 3542 - Advanced Sockets Application Program Interface (API) for IPv6
7. RFC 3849 - IPv6 Address Prefix Reserved for Documentation
8. RFC 3920 - Extensible Messaging and Presence Protocol (XMPP)
9. RFC 3977 - Network News Transfer Protocol (NNTP)
10. RFC 4193 - Unique Local IPv6 Unicast Addresses
11. RFC 4506 - External Data Representation Standard (XDR)

**IETF Online Tool for Searching and Browsing RFCs**

https://tools.ietf.org/rfc/
**IP Addresses**

* Index: 10.x.x.x, 18
* 192.168.x.x, 18
* 255.255.255.255, 74, 102

**Functions**

* accept() function: 28, 29, 83
* bind() function: 25, 27, 77, 85
* close() function: 32, 88
* closesocket() function: 3, 32, 88
* connect() function: 6, 27, 87
* CreateProcess() function: 3, 81
* CreateThread() function: 4
* fcntl() function: 44, 84, 99
* freeaddrinfo() function: 89
* getaddrinfo() function: 14, 19, 21, 33, 89
* gethostbyaddr() function: 33, 93
* gethostbyname() function: 92, 93
* gethostname() function: 33, 92
* getnameinfo() function: 20, 33, 95
* getpeername() function: 32, 96
* getprotobyname() function: 117
* getsockopt() function: 112
* gettimeofday() function: 53

**Macros**

* AF_INET macro: 15, 25, 80
* AF_INET6 macro: 15
* EAGAIN macro: 44, 115
* EPIPE macro: 88
* EWOULDBLOCK macro: 44
* F_SETFL macro: 99
* FD_CLR() macro: 52, 111
* FD_ISSET() macro: 52, 111
* FD_SET() macro: 52, 111
* FD_ZERO() macro: 52, 111
* INADDR_BROADCAST macro: 74

**Topics**

* Address already in use: 27, 77
* BSD: 2
* Byte ordering: 12, 15, 59, 100
* Client/Server: 34–43
* Compression: 80
* Encryption: 80
* Ethernet: 8
* Firewall: 17, 76, 81
* FTP: 122
* HTTP protocol: 7, 123
* ICMP: 77
* Index: 10.x.x.x, 18
* TCP/IP: 1

**Miscellaneous**

* Bapper: 76
* Blah blah blah: 9
* Donkeys: 58
* Excalibur: 73
* Goat: 77
* Header files: 77
* IEEE-754: 60
**Network Functions**

* inet_ntoa() function (17, 101)
* inet_ntop() function (17, 33, 102)
* inet_pton() function (16, 102)
* ioctl() function (82)

**Networking Concepts**

* IP address (10, 16, 26, 31, 33)
* IPv4 (10), IPv6 (11, 15, 18, 19)
* Layered network model (8)
* ISO/OSI (8)
* Linux (2)

**Network Programming**

* listen() function (25, 28, 104) with backlog
* select() function (3, 51-57, 77, 79, 110) with listen()
* socket() function (6, 24, 117)
* send() function (6, 8, 30, 114)
* recv() function (6, 31, 108) with timeout
* poll() function (44-51)

**Socket Options**

* SO_BINDTODEVICE macro (113)
* SO_BROADCAST macro (74, 113)
* SO_RCVTIMEO macro (82)
* SO_REUSEADDR macro (27, 77, 113)
* SO_SNDTIMEO macro (82)

**Error Handling**

* perror() function (98, 105)
* strerror() function (98, 105)

**Other**

* nat (17), NAT (17)
* packet sniffer (81)
* private network (17)
* promiscuous mode (81)
* raw sockets (6, 77)
* security (80)
* serialization (58-72)
* SMTP (123)
* SSL (80)
**INDEX**

* Various terms and concepts related to networking and programming.

**STRUCTURES**

* `struct sockaddr_in6` type (118)
* `struct sockaddr_storage` type (118)
* `struct timeval` type (52-53, 111)

**OPERATING SYSTEMS**

* SunOS (2, 113)
* Windows (2, 32, 77, 88, 113)

**PROTOCOLS**

* TCP (7, 122)
* telnet (7, 122)
* TFTP (8, 122)
* UDP (7, 8, 74, 122)

**FUNCTIONS**

* `WSAStartup()` function (3)
* `WSACleanup()` function (3)
* `write()` function (6)

**TECHNOLOGIES**

* Winsock (2, 32)
* Windows Subsystem For Linux (2)
* XDR (71, 123)
* XMPP (123)
* TRON (27)

**OTHER TERMS**

* Timeout setting (82)
* Zombie process (37)
