**2.7 Other Simulation Concepts**

This section describes various simulation concepts implemented by VR-Link.

### 2.7.1 Managing Time

VR-Link maintains a concept of simulation time for dead-reckoning and thresholding of entities. The `DtClock` class is used to manage simulation time, which can be advanced each frame in proportion to the amount of real time that has elapsed since the previous frame.

Example code:
```cpp
DtTime dt = .05; // Each time step is 0.05 seconds
DtTime simTime = 0.0; // Represents current time
DtClock* clock = exConn.clock();
...
while (...) {
    clock->setSimTime(simTime);
    ...
    simTime = simTime + dt;
    DtTime timeTillNextFrame = simTime - clock->elapsedRealTime();
    DtSleep(timeTillNextFrame);
}
```
In a floating frame rate application, the current time can be passed to `setSimTime()` each frame:
```cpp
DtClock* clock = exConn.clock();
...
while (...) {
    clock -> setSimTime(clock -> absRealTime());
    ...
}
```
### 2.7.2 Identifying Objects

HLA and DIS handle object identification differently. In HLA, objects have several identifiers, including an Object Handle and an Object Name. VR-Link accounts for these differences.

For more information, see 4.7 - Identifying Objects.

### 2.7.3 Using Callbacks

Callback functions are used to respond to events in VR-Link. They can be registered with VR-Link using the `addCallback()` static member function of a class. For example, to process incoming interactions or DIS PDUs, a user registers an interaction callback or PDU callback.

Example code:
```cpp
class MyInteractionCallback {
public:
    void operator()(const Interaction& interaction) {
        // Process the interaction
    }
};

// Register the callback with VR-Link
MyInteractionCallback callback;
exConn.addInteractionCallback(callback);
```
Other ways to use callbacks in VR-Link include responding to entity addition or removal, and general purposes.

### 2.7.4 Coordinate Systems

This section is not summarized as it contains no code examples or additional information.

### 2.7.5 Dead-Reckoning and Smoothing

This section is not summarized as it contains no code examples or additional information.

### 2.7.6 Timestamps

For more information on timestamps, see the next section.

Note: The text does not contain any further information on these topics beyond the initial summary provided.
The text discusses various aspects of VR-Link, including callback functions, coordinate systems, dead-reckoning and smoothing, and timestamps.

Callback Functions:
* Callback functions are executed after VR-Link finishes reading data and executing other callbacks.
* They can be global (C-style) functions or static class members, but not non-static member functions.
* The callback function signature has a trailing void* argument called "usr" that passes an arbitrary pointer to the registered callback.

Coordinate Systems:
* By default, DtEntityStateRepository works with geocentric coordinates.
* VR-Link has coordinate conversion routines and views that support UTM, Cartesian, and Topographic coordinates.

Dead-Reckoning and Smoothing:
* Dead-reckoning estimates the location of an entity based on its acceleration and velocity.
* When updated location information arrives, VR-Link uses smoothing to ensure a smooth transition between the dead-reckoned position and the actual position.

Timestamps:
* Timestamps are sent with or within messages using sendStamped() and indicate only a time (in seconds) past a particular hour.
* The timestamp type indicator indicates whether the clock used is synchronized to a global exercise clock, which can be "absolute" or "relative".

Here is the original text without any changes:

These callbacks are executed after VR-Link finishes reading data and executes other, more specific callbacks. Because callback functions are passed as regular function pointers to VR-Link's callback registration functions, the callback functions themselves cannot be non-static member functions of a class. They can be global (C-style) functions, or static class members. In order to have a non-static member function of a class be executed as a result of some VR-Link event, you can call the member function from within your callback.

VR-Link callback functions have strict function signatures, but most types of VR-Link callback functions have a trailing void* argument that is usually called usr. Corresponding callback registration functions also have a trailing usr argument. This lets you register an arbitrary pointer with VR-Link along with your callback function. When VR-Link executes your callback function, the pointer that you registered is passed to your function as usr. Often, the usr argument passes a pointer to an object on which you want to call a member function. Simply cast usr back to the object's type within the callback.

For example:

class MyObj
{
public:
   // The function we want to call. void someFunc();
   // A static member function to be registered as an interaction
   // callback with the DtFireInteraction class. When this function
   // is called by VR-Link, usr will contain a pointer to the object
   // passed to addCallback. static void theCallback(DtFireInteraction* inter, void* usr)
   {
      MyObjType* obj = static_cast<MyObj *>(usr);
      obj->someFunc();
   }
};

int main()
{
   DtExerciseConn exConn(...);
   ...
   MyObj obj;
   // Register our callback function, passing a pointer to obj as usr. DtFireInteraction::addCallback(&exConn, MyObj::theCallback, &obj);
   ...
}

In cases where you want to pass more than one object to your callback, you must create a simple structure consisting of pointers to your objects, then pass a pointer to the structure as usr.

Note
Any pointer you pass as usr must be the address of a variable whose lifetime is at least as long as the period for which the callback function is registered.

2.7.4 Coordinate Systems

By default, DtEntityStateRepository works with geocentric coordinates. VR-Link has coordinate conversion routines that let you convert incoming and outgoing entity information to other coordinates systems. VR-Link also has coordinate views that allow you to use various coordinate systems without explicitly calling coordinate conversion routines.

The view classes support:

UTM coordinates
Cartesian coordinates
Topographic coordinates.

For more information about views and coordinate conversion, please see 4.9 - Coordinate Views, and 13.3 - Coordinate Conversions.

2.7.5 Dead-Reckoning and Smoothing

To represent the behavior of entities in between state updates, VR-Link uses dead-reckoning, a process of estimating the location of an entity based on its acceleration and velocity. When updated location information arrives, VR-Link must move the simulated entity to its actual position.

To ensure that transitions from an entity's dead-reckoned position to its actual position are not so abrupt as to be noticeable, VR-Link uses smoothing. This involves averaging the dead-reckoned position with the actual position over a period of time.

2.7.6 Timestamps

Timestamps are sent with or within messages using sendStamped() and indicate only a time (in seconds) past a particular hour.

The timestamp type indicator indicates whether the clock used to generate the timestamp is synchronized to a global exercise clock, which can be "absolute" or "relative".

Participants in a DIS or HLA exercise do not have to synchronize their clocks. In fact, in most exercises, clocks are not synchronized. If participants choose to synchronize their clocks, they do so using a method outside the scope of both DIS and HLA.

(The HLA RTI has a set of time management services, but synchronizing clocks is not what they do.)
**Timestamping**

When both sender and receiver use absolute timestamping, the receiver can immediately understand the sender's timestamp. In this case, VR-Link uses the timestamp in dead-reckoning calculations. If one or both parties use relative timestamping, the sender's timestamp is meaningless to the receiver unless they know the time difference between their clocks.

**Big and Little Endian Wire Formats**

VR-Link provides a mechanism for setting and inspecting the current wire format at runtime using DtSetNetworkByteOrdering() and DtNetworkByteOrdering(). Big endian is the default. To use little endian byte ordering, call:

DtSetNetworkByteOrdering(DtLittleEndian);

To change it back to the default, call:

DtSetNetworkByteOrdering(DtBigEndian);

**Basic VR-Link Examples**

The section lists two simple VR-Link applications: a listen-only example and a send-only program.

**Listen-Only Example**

This application listens to the network without simulating any entities. The code is included with VR-Link and can be compiled for either DIS or HLA.

**Connect to an Exercise**

In this example, the program creates an exercise connection (DtExerciseConn) using a DtVrlApplicationInitializer, which provides support for command line arguments.
The protocol-specific part of the code initializes a connection to an exercise or federation execution using the DtExerciseConn class. Two scenarios are shown: one for HLA (High-Level Architecture) and another for DIS (Distributed Interactive Simulation).

For HLA:
```c
int main()
{
   // Create a connection to the exercise or federation execution
   DtString execName("VR-Link");
   DtString fedName("VR-Link listen"); 
   DtExerciseConn exConn(execName, fedName, new DtSimpleRprFomMapper);
}
```

For DIS:
```c
int main()
{
   // Create a connection to the exercise or federation execution
#if DtDIS
   int port           = 3000;
   int exerciseId     = 1; 
   int siteId         = 1;
   int applicationNum = 15;
   DtExerciseConn exConn(port, exerciseId, siteId, applicationNum,
                              0,             // No Status, any error will be fatal
                              true);            // use Async IO
#endif
```

The code also discusses the following aspects:

* Managing state and interaction information using callbacks (e.g., fireCb)
* Tracking entities using a reflected entity list
* Managing time by obtaining a pointer to the simulation clock from the exercise connection
* Listening to the network by setting VR-Link simulation time at the start of each iteration
