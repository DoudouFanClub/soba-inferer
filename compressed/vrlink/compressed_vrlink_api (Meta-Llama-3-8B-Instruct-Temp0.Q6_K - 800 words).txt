The VR-Link toolkit is an object-oriented library that simplifies the development of networked simulators and virtual reality applications. It provides a protocol-independent API for creating HLA and DIS applications, allowing developers to switch between protocols by changing only a few lines of initialization code.

VR-Link features include:

* Exercise Connection: An interface to exchange simulation information with other applications
* Object Tracking: Processing incoming attribute updates and providing a protocol-independent interface to remote entities
* Object Publishing: Automatically sending state updates when data changes or exceeds configurable thresholds
* Interaction Classes: Sending and receiving interaction messages that describe simulation events
* FOM-Agility: Mapping VR-Link's API to another FOM's parameters, attributes, and object or interaction classes
* User Extensibility: Overriding default functionality through subclassing
* Access to Low-Level Details: Direct access to the HLA RTI and network configuration in DIS
* Utility Functions: Vector and matrix manipulation functions, system clock interface, discreet simulation time support, and coordinate conversion utilities

VR-Link includes a range of features and tools, including:

* Header files and libraries for building applications
* Executables and source code for utility applications such as F18, DIS Netdump, Talk, and Listen
* Source code and executables for sample applications that demonstrate the use of VR-Link's functionality
* Test applications that show how to extend the features of VR-Link by creating custom PDUs, interactions, encoders, and decoders

The text does not make any assumptions not within the provided information.

VR-Link supports various simulation standards, including HLA RTI 1.3 and RTI 1516 specifications, as well as DIS.

**HLA Support**

* VR-Link supports HLA 1.3 specification, HLA 1516 specification (SISO DLC HLA API), and HLA Evolved (IEEE 1516-2010) specification.
* The protocol-independent interface allows for creating applications that can be used with any version of HLA without significant changes.

**FOM Support**

* VR-Link provides built-in support for the Real-Time Platform Reference FOM (RPR FOM).
* Supported RPR FOM versions include 0.5, 0.7, 0.8, 1.0, 2.0, drafts 6, 14, 17, and 20.
* By default, all VR-Link examples use RPR FOM 2.0.

**Interoperability**

* Applications built using the VR-Link 1516 APIs can interoperate with applications built with the VR-Link 1.3 API.
* VR-Link supports HLA configuration files in both FED and FDD (XML) formats.

**Code Examples**

* The DtVrlApplicationInitializer class defaults to using RPR FOM 1.0, but you can specify a different version by passing it to the constructor.
* You can use the DtRprFomMapper constructor to map a specific RPR FOM version and pass the resulting object to the DtExerciseConn constructor.

Note that this summary does not make any assumptions not within the text and keeps all code examples intact.

The text discusses VR-Link, a toolkit for developing simulation applications. It provides classes, functions, and utilities to write a simulation application, but does not provide a structure that must be used.

VR-Link has built-in support for the Real Time Platform Reference FOM (RPR FOM) and can be configured to work with other FOMs using its FOM Mapper. The RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group.

The text also discusses HLA, DIS, and protocol independence. HLA is required by the Department of Defense for use in all DoD simulations, while DIS is a protocol used for exchanging data among simulators. VR-Link supports both HLA and DIS protocols.

Here are some key points:

* VR-Link has built-in support for the RPR FOM.
* The RPR FOM is implemented through a Federation Execution Data (FED) file, which contains a subset of the FOM that is required by the RTI.
* VR-Link supports the FOM defined within the FED file called VR-Link.fed, which represents the RPR FOM plus a few extra classes added by VR-Link.
* The text provides examples of how to use VR-Link, including code snippets.

Here are some code examples:

* `DtExerciseConn conn("MAK-RPR20017-1-1.fed", "MyApp", new DtRprFomMapper(2.0017-1));`
* `VR-Link has a FOM Mapper for the MATREX FOM. For details, please contact your MAK salesperson.`

Note that these code examples are provided as-is and may require additional context or modifications to work correctly.

The RPR FOM (Reference Physics Reference Federation Object Model) aims to facilitate interoperability among HLA simulations that use it. Using the RPR FOM ensures compatibility with other simulations that also use this FOM. Many simulation tools, including VT MAK products, support the RPR FOM.

VR-Link supports only the RPR FOM but has features for working with new or modified FOMs and extending them to meet specific needs. This is called FOM-agility. VR-Link can be configured to work with other FOMs using the VR-Link FOM Mapper, which defines mappings between VR-Link's protocol-independent interface and objects, interactions, parameters, and attributes defined in the FOM.

The Run-Time Infrastructure (RTI) is an implementation of the HLA interface specification that provides services for exchanging simulation data. Federates must use the RTI to exchange data according to the HLA rules.

The DIS (Distributed Interactive Simulation) protocol specifies a set of standards for sharing information about a virtual world, including packets called Protocol Data Units (PDUs). The table lists the DIS version numbers and their corresponding formal specifications.

Protocol independence refers to a set of classes in VR-Link that allow developers to create applications that work with both DIS and HLA without significant modification. This is achieved by writing one application and compiling it for each protocol at compile time.

The text also provides information on obtaining further information about HLA and DIS, including documentation for the RTI interface specifications and general DIS information from the Simulation Interoperability Standards Organization (SISO).

Finally, the text describes VR-Link's protocol-independent classes, which include object management classes that perform tasks such as connecting to an exercise, managing state information, and managing information about events.

VR-Link provides classes that facilitate tasks such as connecting to an exercise, managing state information, and interacting with objects. These classes are categorized into protocol-independent classes and protocol-specific classes.

Protocol-independent classes include:

* Exercise Connection: A class that serves as the application's interface to the RTI or DIS network.
* Object management classes:
	+ Object publisher classes (e.g., DtEntityPublisher) manage sending updates for locally simulated objects to the exercise.
	+ Reflected object classes (e.g., DtReflectedEntity) represent remote objects and maintain their current state based on updates received from the exercise.
	+ Reflected object list classes (e.g., DtReflectedEntityList) keep track of remote objects and create or destroy reflected objects based on information received from the exercise.
	+ State repository classes (e.g., DtEntityStateRepository) store the state of an object.

Protocol-specific classes are not typically used directly by application code, but rather through conversion routines and other utility functions provided by VR-Link.

The structure of a typical VR-Link application is shown in the figure below:

vrlinkappstructure.png

To connect to an exercise, a VR-Link application uses the DtExerciseConn class, which allows for sending interactions to the exercise, reading input from the network, generating event IDs, registering callback functions, and managing the simulation clock.

Managing state information involves maintaining information about locally simulated entities and communicating this information to other participants in an exercise. This is done through the use of object publishers, reflected objects, and state repositories.

The figure below illustrates how a VR-Link application manages state information:

managingstateinformation.png

In HLA federation execution, state updates are sent only when update conditions (specified by FOM) have been met and a federate has subscribed to the entity attribute that changed.

For remote entities, VR-Link receives information through the exercise connection using DtExerciseConn::drainInput(). It maintains a list of remote entities in a DtReflectedEntityList, with each entity represented by a DtReflectedEntity. The state of each entity is stored in a DtEntityStateRepository.

Interactions (e.g., firing of a munition) are managed through classes derived from DtInteraction. Locally-defined interactions can be sent through the exercise connection using an instance of the appropriate interaction class, while remote interactions are received and processed by VR-Link.

The text also covers other simulation concepts, including:

* Managing time: VR-Link maintains its own simulation time, which is typically advanced each frame to approximate real time. The DtClock class implements this functionality.
* Object identification
* Callbacks: used to react to remote interactions
* Coordinate systems
* Dead-reckoning and smoothing
* Timestamps

Note that the text uses HLA terminology (publishing and reflecting) for its protocol-independent classes, but sends proper PDUs for state updates or interactions in DIS.

**Simulation Time Management**

In a fixed frame rate application, the simulation time is managed by setting a time step (`dt`) and advancing the current simulation time (`simTime`) in each iteration of the main loop. The `setSimTime` function is used to tell VR-Link the current value of the simulation time.

In a floating frame rate application, the current time is passed to `setSimTime` each frame.

**Object Identification**

HLA and DIS handle object identification differently. In DIS, entities are identified by a triplet (site, application, entity), while in HLA, objects have several different identifiers, including Object Handle and Object Name.

**Callbacks**

Callback functions are used to respond to events in VR-Link. They can be registered with VR-Link using the `addCallback` static member function of a class. Callbacks can be used to process incoming interactions or DIS PDUs, respond to entity addition or removal, or for general purposes.

Here is an example of a callback function:
```
class MyObj
{
public:
    void myCallback(void* usr) {
        // Cast the usr argument back to the object's type
        MyObj* obj = static_cast<MyObj*>(usr);
        // Call a member function on the object
        obj->doSomething();
    }
};
```

1. **Callback Functions**: A static member function `theCallback` is registered with the `DtFireInteraction` class to be called when an interaction occurs. The callback function takes two parameters: `inter` (a pointer to `DtFireInteraction`) and `usr` (a user-defined pointer). In this case, `usr` points to a `MyObjType` object, which is cast to the correct type and then calls its own member function `someFunc`.

2. **Coordinate Systems**: VR-Link supports various coordinate systems, including geocentric coordinates, UTM coordinates, Cartesian coordinates, and topographic coordinates. The framework provides conversion routines for converting between these systems.

3. **Dead-Reckoning and Smoothing**: Dead-reckoning is a process used to estimate the location of an entity based on its acceleration and velocity. To ensure smooth transitions between dead-reckoned positions and actual positions, VR-Link implements smoothing.

4. **Timestamps**: When sending interactions or object state updates through a `DtExerciseConn`, a timestamp is sent with the message. The timestamp indicates only a time past a particular hour, but not the specific hour. The framework provides functions to guess the full time intended by the sender.

5. **Big and Little Endian Wire Formats**: In rare cases, simulations may need to communicate with applications that use little endian wire formats instead of big endian. VR-Link provides functions `DtSetNetworkByteOrdering()` and `DtNetworkByteOrdering()` to set and inspect the current wire format at runtime.

The provided code examples demonstrate how to register a callback function with the `DtFireInteraction` class and how to pass additional objects as user-defined pointers (`usr`).

The text discusses two basic VR-Link examples: a listen-only application that observes an exercise without simulating any entity on the network, and a send-only program that does not process information about remote entities. The source code for both examples is included with VR-Link.

The listen-only example is an application that just listens to the network. It can be compiled for either DIS or HLA. The only protocol-specific code is contained in the #if statement that starts at line 27. With each iteration of the loop, the program prints an entity's updated, dead-reckoned position in topographic coordinates. In addition, if a fire PDU or interaction is detected on the network, the program prints a message showing the entity ID of the attacker.

The code for the listen-only example is provided below:

```c
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vlutil/vlProcessControl.h>
#include <vl/reflectedEntityList.h>
#include <vl/entityStateRepository.h>
#include <vl/reflectedEntity.h>
#include <vl/fireInteraction.h>
#include <vl/topoView.h>
#include <iostream>

int keybrdTick(void);

void fireCb(DtFireInteraction* fire, void* /*usr*/)
{
    std::cout << "Fire Interaction from " 
          <<  fire->attackerId().string() << std::endl;
}

int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");

        #if DtDIS
            appInit.setUseAsynchIO(true);
        #endif

        appInit.parseCmdLine();

        DtExerciseConn exConn(appInit);

        // Register a callback to handle fire interactions.
        DtFireInteraction::addCallback(&exConn, fireCb, NULL);

        // Create an object to manage entities that we hear about 
        // on the network.
        DtReflectedEntityList rel(&exConn);

        // Initialize VR-Link time.
        DtClock* clock = exConn.clock();

        int forever = 1;
        while (forever)
        {
            // Check if user hit 'q' to quit.
            if (keybrdTick() == -1)
                break;

            // Tell VR-Link the current value of simulation time.
            clock->setSimTime(clock->elapsedRealTime());

            // Process any incoming messages
            exConn.drainInput();

            // Find the first entity in the reflected entity list
            DtReflectedEntity *first = rel.first();

            if (first)
            {
                // Grab its state repository, where we can inspect its data.
                DtEntityStateRepository *esr = first->entityStateRep();

                // Create a topographic view on the state repository, so we 
                // can look at position information in topographic
                // coordinates.
                double refLatitude  = DtDeg2Rad(  35.699760);
                double refLongitude = DtDeg2Rad(-121.326577);
                DtTopoView topoView(esr, refLatitude, refLongitude);

                // Print the position.
                // Since it returns a DtString, we need to force it to 
                // const char* with a cast.
                std::cout << "Position of first entity: "
                    <<  topoView.location().string() << std::endl;
            }

            // Sleep till next iteration.
            DtSleep(0.1);
        }
        return 0;
    }
    DtCATCH_AND_WARN(std::cout);
}
```

The text also discusses how to connect to an exercise and manage state and interaction information using callbacks.

The text describes two examples of using VR-Link, a simulation platform for distributed interactive simulations (DIS) and high-level architecture (HLA). The first example is a listen-only application that tracks entities on the network, manages time, and listens to the network. The second example is a send-only application that simulates the flight of an F18 aircraft.

The code examples provided are in C++ and demonstrate how to create a connection to the exercise or federation execution, define an entity type, create an entity publisher, set up a topographic view on the entity state repository, and send interactions using the exercise connection's sendStamped() function.

Here is the summary without losing any core information:

* The listen-only application tracks entities on the network, manages time, and listens to the network.
* The send-only application simulates the flight of an F18 aircraft by sending a fire PDU or HLA fire interaction, then updating its position by sending DIS entity state PDUs or HLA attribute updates.

Here is the code example for the send-only application:

```c
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>
#include <vl/fireInteraction.h>
#include <vl/iffPublisher.h>
#include <vlpi/EntityTypes.h>
#include <vlutil/vlProcessControl.h>
#include <iostream>

int main(int argc, char** argv) {
    // Create a connection to the exercise or federation execution.
    DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");

    // Change some defaults
    #if DtDIS
        appInit.setUseAsynchIO(true);
    #endif

    appInit.parseCmdLine();

    DtExerciseConn exConn(appInit);

    DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
        DtUnitedStates, DtFighter, DtF18, 0, 0);

    // Create an entity publisher for the entity we are simulating.
    DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
        DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 

    // Hold on to the entity's state repository, where we can set data.
    DtEntityStateRepository *esr = entityPub.entityStateRep();

    // Create a topographic view on the state repository, so we 
    // can set position information in topographic coordinates.
    double refLatitude  = DtDeg2Rad(  35.699760);
    double refLongitude = DtDeg2Rad(-121.326577);
    DtTopoView topoView(esr, refLatitude, refLongitude);

    // We can use the ESR to set state.
    esr->setMarkingText("VR-Link");
    topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));

    // Initialize VR-Link time.
    DtClock* clock = exConn.clock();

    DtVector position(0, 0, -100);
    DtVector velocity(20, 0, 0);

    // Send a Fire Interaction.
    DtFireInteraction fire;
    fire.setAttackerId(entityPub.globalId());
    exConn.sendStamped(fire);

    // Main loop
    DtTime dt = 0.05;
    DtTime simTime = 0;
    while (simTime <= 10.0) {
        // Tell VR-Link the current value of simulation time.
        clock->setSimTime(simTime);

        // Process any incoming messages.
        exConn.drainInput();

        // Set the current position information.
        topoView.setLocation(position);
        topoView.setVelocity(velocity);

        // Call tick, which insures that any data that needs to be 
        // updated is sent.
        entityPub.tick();

        // Set up for next iteration.
        position[0] += velocity[0] * dt;
        simTime     += dt;

        // Wait till real time equals simulation time of next step
        DtSleep(simTime - clock->elapsedRealTime()); 
    }
}
```

Note that the code examples are provided in their entirety, without any modifications or assumptions not within the text.

**Sending State Updates**

The main loop executes 20 times per second for 10 seconds, setting simulation time at the start of each iteration. The program sends state updates to the network by ticking the entity publisher in line 77.

**Compiling and Linking a VR-Link Application**

To compile and link a VR-Link application, you need to:

1. Tell the compiler where to find the VR-Link header files (and for HLA, the RTI header files).
2. Link with VR-Link's libraries (and for HLA, the RTI's libraries).

**Libraries and Header Files**

VR-Link consists of four libraries: mtl, vl, matrix, vlpi, and vlutil.

**Compiling for a Particular Simulation Standard Under Linux**

To build a VR-Link application for Linux using MAK's build system, you need to use gmake 3.81 or later.

**HLA Compilation Flags**

For HLA compilation:

* `-I{VLHOME}/include` (VR-Link headers)
* `-I{VLHOME}/RTI/include` (path to MAK RTI include directory)
* `-DDtHLA=1` for conditional compilation
* `-DDtHLA_1516=1` Use only if compiling for IEEE 1516 - 2000.
* `-DDtHLA_1516_EVOLVED=1` Use only if compiling for IEEE 1516 - 2010 (HLA Evolved).

**Link Flags for HLA**

For HLA 1.3:

* `-lvrhome/lib`
* `-lvl`
* `-lvlHLA13`
* `-lmatrix`
* `-lmtl`
* `-lvlutil`
* `-lxml2`
* `-lRTI-NG`
* `-lfedtime`

For HLA 1516:

* `-Lvrhome/lib`
* `-lvl`
* `-lvlHLA1516`
* `-lmatrix`
* `-lmtl`
* `-lvlutil`
* `-lxml2`
* `-lrti1516`
* `-lfedtime1516`

For HLA Evolved:

* `-Lvrhome/lib`
* `-lvl`
* `-lvlHLA1516e`
* `-lmatrix`
* `-lmtl`
* `-lvlutil`
* `-lxml2`
* `-lrti1516e`
* `-lfedtime1516e`

**DIS Compilation Flags**

For DIS compilation:

* `-Ivlhome/include` (VR-Link headers)
* `-DDtDIS=1` for conditional compilation

**Link Flags for DIS**

* `-Lvlhome/lib`
* `-lvl`
* `-lmtl`
* `-lvlDIS`
* `-lmatrix`
* `-lvlutil`
* `-lxml2`

**Compiling for a Particular Protocol Version under Windows**

Under Windows, you can set your program's protocol by providing build settings in Microsoft Developer Studio to define constants and specify paths for header files and RTI libraries.

**Compiling for HLA**

* Choose Project -> Properties, then select the C/C++ folder.
* Enter the following #define symbols in the space provided for preprocessor definitions: `DtHLA=1`, `DtHLA_1516=1`, `RTI_USES_STD_FSTREAM=1`.
* In the C/C++ -> General section, enter your VR-Link include path and the path to your RTI include directory.
* Select the Linker folder. In the Linker -> Input section, enter the appropriate RTI, VR-Link, and Visual C++ library files.

**Compiling for DIS**

* In the C/C++ -> General section, enter your VR-Link include path.
* In the Linker -> Input section, enter the appropriate VR-Link and Visual C++ library files.

**Using VR-Link from C**

* The directory `/examples/simpleC` contains an example of using VR-Link with an application written in C.
* To call C++ functions from C, you need at least one C++ file that can be compiled to be callable from C. In our example, the file `interface.cxx` serves this purpose.
* To alert the C++ compiler that a function should be compiled to be callable from C, its declaration is surrounded by `extern "C" { }`.
* You can create a C++ function that interfaces with VR-Link code and calls C functions. For example, in `interface.cxx`, the callback `on Fire PDUs (fireCb)` is a C++ function which calls the C function `firePrint()`.

**Header Files**

* When C and C++ code interact, the declarations of many of the same functions must be included by both C and C++ code. These declarations need to be surrounded by `extern "C" { }` when presented to the C++ compiler.
* However, these keywords are meaningless to a C compiler, so they should always be surrounded by `#ifdef __cplusplus #endif`.

**Delivering VR-Link Applications to Users**

* A VR-Link developer's license allows you to compile applications using the VR-Link libraries and run one such application.
* After developing an application that uses the VR-Link libraries, you may need to deliver that application to an internal or external customer. The end user of the application needs a VR-Link run-time license to use it.

The customer only needs the VR-Link application, libraries, license management files, and run-time licenses for each instance of the application to be run. They do not need the developer's license unless they need to recompile the application.

The protocol-independent interface (PII) is a set of classes that provide most of the features of VR-Link and allow applications to work with both DIS and HLA without significant modification. The PII shields developers from the intricacies of the underlying protocol-specific classes and functions.

To create an exercise connection, you need to use the DtExerciseConn class, which is a simulation application's interface to an exercise. There are HLA and DIS versions of DtExerciseConn, but most public member function names and signatures are shared by both versions.

Here is an example of creating an exercise connection for HLA:
```
DtExerciseConn* conn = new DtExerciseConn("Federation Execution Name", "Federate Name");
```
You can also specify the name of the FED file that you want to use in one of the other constructors. If you do not provide the name of a FED file, VR-Link assumes that you are using a file with the same name as the federation execution, but with a .fed extension.

The text also provides information on connecting to exercises, working with interactions, entities, and other types of objects, as well as controlling MAK products remotely.

1. Federation Execution Name and FED File: The federation execution name is assumed to be "VR-Link", and the corresponding FED file is "VR-Link.fed". The FED file should be in the same directory as the application.

2. Federate Name and RTI Ambassadors: The federate name is a user-defined name for the application, used for RTI diagnostics. The DtExerciseConn constructors initialize the RTI ambassadors, create the named federation execution if it does not exist, and join the federation execution.

3. Creating an Exercise Connection for DIS: To create an exercise connection for DIS, you need to specify a UDP port number, exercise ID number, site number, and application number. These values can be specified in the DtExerciseConnInitializer or directly in the constructor.

4. Initializing Applications: The text describes how to initialize applications using the DtVrlApplicationInitializer class. This includes parsing command line input, loading XML or MTL files, and saving the state of the initializer class to an XML file.

5. Command Line Options: The text lists various command line options that can be used with VR-Link-based applications. These options include protocol-independent options, HLA-specific options, and DIS-specific options.

Here is a summary of the code examples provided:

```c
// Create a connection to the exercise or federation execution.
DtVrlApplicationInitializer appInit(argc, argv, "VR-Link application");
appInit.parseCmdLine();
DtExerciseConn exConn(appInit);
```

This code creates an instance of DtVrlApplicationInitializer and uses it to initialize a DtExerciseConn object.

**HLA Evolved Local Settings Designator**

* `-S` or `--localSettingsDesignator` <string>

**Default DIS Command Line Options**

* Parameter: Syntax, MTL Parameter, Default
	+ DIS port: `-P` or `--disPort` port, `disPort`, 3000
	+ Exercise ID: `-x` or `--exerciseId` ID, `exerciseId`, 1
	+ Application number: `-a` or `--appNumber` number, `appNumber`, 2
	+ Site ID: `--siteId` ID, `siteId`, 1
	+ Destination address: `-A` or `--destAddrString` address, `destAddrString`, ""
	+ Device address: `--deviceAddress` address, `deviceAddress`
	+ Send buffer size: `--sendBufferSize` size, `sendBufferSize`, -1 (use system default)
	+ Receive buffer size: `--recvBufferSize` size, `recvBufferSize`, -1 (use system default)
	+ Multicast TTL: `--mcastTtl` ttl, `mcastTtl`, -1 (use system default)
	+ Multicast address: `-S` or `--mcastAddresses` addresses
	+ Suppress self-reflection: `--suppressSelfReflect`, `suppressSelfReflect`, false
	+ Use IPv6: `--useIpv6`, `useIpv6`, false
	+ DIS Version: `--disVersion` <version>
	+ Use Asynchronous I/O: `--useAsyncIO`, `useAsyncIO`, 0
	+ Subnet mask to use: `<--subnetMask <mask>/TD>`

**DtExerciseConn Member Functions**

* Function: Description
	+ addPostDrainCallback(): Lets you register functions (with the DtExerciseConn) that you want to have called automatically each time drainInput() is called.
	+ removePostDrainCallback(): Lets you unregister functions that you no longer want to have called each time drainInput() is called.
	+ drainInput(): Causes to read and process input from the exercise. Most user callbacks are executed from within drainInput().
	+ nextEventID(): Generates consecutive event IDs for use in fire, detonate, or collision interactions.
	+ send(): Sends interaction messages, object updates, and DIS PDUs to the exercise.
	+ sendStamped(): Includes a time stamp with outgoing messages.
	+ setTimeStampType(): Lets you specify the type of time stamp being sent.
	+ timeStampType(): Returns the time stamp type.
	+ vrlinkVersion(): This static function returns the version of VR-Link that you are running.

**Sending Data to the Exercise**

* The send() and sendStamped() member functions are used to send interactions to the exercise. For more information, please see 4.3.1 Sending Interactions.

**Receiving Data from the Exercise**

* The DtExerciseConn::drainInput() function receives and processes information from the RTI or the DIS network.
* From within DtExerciseConn::drainInput(), VR-Link executes any callbacks that you have registered on DtInteractions (for either HLA or DIS), DtPdus (for DIS), or various RTI services (for HLA).

**Post-Drain Callbacks**

* Post-drain callbacks are callback functions that you can register with a DtExerciseConn, and have called automatically by DtExerciseConn::drainInput() immediately before it returns.
* The function signature for post-drain callbacks is: `void myCallback(void* usr);`
* They are registered with a DtExerciseConn using addPostDrainCallback(), and unregistered using removePostDrainCallback().

The text discusses various aspects of VR-Link, a simulation technology used in exercises. It covers topics such as setting timestamp types, initialization status, and working with interactions.

**Timestamp Type**: The `setTimeStampType()` function can be used to set the time stamp type of an application to either `DtTimeStampAbsolute` or `DtTimeStampRelative`. This is important for dead-reckoning calculations.

**Initialization Status**: If VR-Link fails during initialization, the default behavior is to abort. However, the constructor has an optional argument (`status`) that can be used to store the result of initialization and prevent the exercise connection from exiting if a non-license management related problem occurs.

**Interactions**: Interactions are data exchanged among simulation applications in an exercise to describe events such as firing a munition or collision of entities. Each type of interaction has its own class, derived from `DtInteraction`. The text provides information on how to send and receive interactions using the `sendStamped()` function.

Here is an example code snippet for sending a fire interaction:
```c
// Create an instance of the fire interaction class
DtFireInteraction* fire = new DtFireInteraction();

// Set values for the different parameters
fire->setSenderId(myId);
fire->setTargetId(targetId);
fire->setMissileId(missileId);

// Send it using sendStamped() function
exerciseConn.sendStamped(fire, timestamp);
```
Note that `myId`, `targetId`, and `missileId` are existing objects.

The text discusses how to send and receive interactions in a Distributed Interactive Simulation (DIS) or High-Level Architecture (HLA) environment using VR-Link.

**Sending Interactions**

To send an interaction, you create a `DtFireInteraction` object and fill it with data. Then, you use the `sendStamped()` method of the `DtExerciseConn` object to send the interaction. The `sendStamped()` method includes a timestamp with outgoing interactions, which is usually desired.

**Receiving Interactions**

Incoming interactions are handled through interaction callbacks. You write and register callback functions for a particular interaction type using the `addCallback()` method of the `DtInteraction` class. When an interaction is received, VR-Link calls your callback function, passing the received interaction as an argument.

Here is an example of a callback function:
```cpp
void myFireCallback(DtFireInteraction* inter, void* usr) {
    std::cout << "Got a Fire Interaction from " << inter->attackerId().string() << std::endl;
}
```
You register the callback function using the `addCallback()` method:
```cpp
DtFireInteraction::addCallback(exerciseConn, myFireCallback, NULL);
```
**Making RTI Calls in Response to Interactions**

In HLA applications, interaction callbacks are called from within `RTI::tick()`. However, some RTIs do not allow calls to RTI services from within other RTI service calls. To make RTI calls based on the receipt of a `DtInteraction`, you can use `DtExerciseConn::addPostDrainCallback()` to register a function that will be executed right before `drainInput()` returns.

Here is an example:
```cpp
void sendFire(void *usr) {
    // ...
    exConn->sendStamped(fireInter);
    exConn->removePostDrainCallback(sendFire, exConn);
}
```
In the main function, you register the callback function and pass a pointer to the `DtExerciseConn` object as the `usr` argument:
```cpp
main() {
    DtExerciseConn exerciseConn(...);
    // ...
    DtFireInteraction::addCallback(&exerciseConn, fireCb, &exerciseConn);
    // ...
}
```
Note that you should not attempt to delete or save a pointer to the `DtInteraction` passed to your callback function. Instead, make a copy of the interaction if you need to save its data.

The chapter discusses how to manage entities in VR-Link, which includes creating a DtEntityPublisher for each locally-simulated entity, updating its current state through its DtEntityStateRepository, and calling the tick() function to send updates to other participants.

To create a DtEntityPublisher, you can use one of two protocol-independent constructors: one that takes a DtExerciseConn and DtEntityType as arguments, or another that takes three attributes of an entity (dead-reckoning algorithm, guise, and force ID) as arguments. The constructor also allows you to choose an identifier for the entity.

Here is an example of creating a DtEntityPublisher:
```
DtExerciseConn exConn(...);
DtEntityType tankType(1, 1, 225, 1, 1, 0, 0);
DtEntityPublisher tankPub(tankType, &exConn);
```
The DtEntityType represents a seven-component enumeration defined by the DIS protocol and reused by DIS-based FOMs like the RPR FOM. It is used in outgoing entity state PDUs and in HLA updates.

The tick() function ensures that any needed information is sent to other participants through the exercise connection. You can also set an entity's state, coordinates, and position and orientation thresholds using various methods provided by the DtEntityPublisher class.

Here is an example of setting the state of an entity:
```
tankPub.setState(tankState);
```
You can also remove a locally-simulated entity by calling the remove() method on the DtEntityPublisher instance.

To reserve a name for an object, you need to call the RTIambassador as follows:
```
ExConn->rtiAmb()->reserveObjectInstanceName(theName);
```
Then, tick the RTI. The RTI will then call the Federate Ambassador to let the federate know if the name reservation succeeded or failed.

When creating a publisher for an object and specifying a name, VR-Link checks the list of reserved names. If the name is not found, it requests the reservation and ticks the RTI until it gets a response or times out.

You can set the number of times the publisher ticks the RTI and the duration of the ticks using static methods in DtHlaObjectManager:
```
static double requestNameTickTime();
static void setRequestNameTickTime(double time);
static int numberOfRequestNameTries();
static void setNumberOfRequestNameTries(int tries);
```
If the publisher does not get a successful name reservation after several tries, it allows the RTI to pick the name.

You can also make RTI calls to reserve names before creating publishers. It is recommended to batch these requests for better performance.

In DIS, you need to choose an identifier for each entity using DtEntityIdentifier:
```
DtGlobalObjectDesignator id = "Object1";
#elif DtDIS
DtGlobalObjectDesignator id = DtEntityIdentifier(1, 2, 3);
#endif
```
You can also use the following functions to find out the identifier that was chosen:
```
globalId() returns the global identifier of the object – the object name in HLA; the entity identifier triplet in DIS
localId() or id() returns the local identifier of the object – the object handle in HLA; the entity identifier triplet in DIS.
```
You can set a DtEntityPublisher's state through its DtEntityStateRepository:
```
DtEntityStateRepository esr = tankPub.entityStateRep();
esr.setLocation(DtVector(x, y, z));
esr.setVelocity(DtVector(vx, vy, vz));
esr.setAcceleration(DtVector(ax, ay, az));
```
You can also set components that affect the outward appearance of an entity using functions such as:
```
setDamageState()
setFlamesPresent()
setEngineSmokeOn()
setHatchState()
```
Positions, velocities, and accelerations must be set in geocentric coordinates. Use the DtVector class to set coordinates. Orientation is specified as a DtTaitBryan, which represents three angles needed to transform from the geocentric coordinate system to the entity coordinate system.

Note that some mutator functions take enumerations as arguments, and values for these enumerations are in disEnums.h.

The text discusses the entity coordinate system used in VR-Link, which provides various View classes for setting data in a DtEntityStateRepository without performing explicit conversions.

It then provides an example of using DtEntityStateRepository's mutator functions to set the current state of an entity:
```c
DtEntityPublisher tankPub(...);
...
// Grab a pointer to our entity publisher's ESR
DtEntityStateRepository *esr = tankPub.entityStateRep();
// Set location, velocity, acceleration, orientation, and angular velocity
esr->setLocation(DtVector(-2696545.0, -4430407.0, 3701906.0));
esr->setVelocity(DtVector(100.0, 100.0, 100.0));
esr->setAcceleration(DtVector(0.0, 0.0, 0.0));
esr->setOrientation(DtTaitBryan(-2.11, 0.948, 2.469));
esr->setRotationalVelocity(DtVector(0.0, 0.10, -0.125));
// Indicate that the entity is on fire and slightly damaged
esr->setFlamesPresent(true);
esr->setDamageState(DtDamageSlight);
...
```
The text also explains how to use DtEntityPublisher::tick() function, which decides what data needs to be sent to other exercise participants and formats and sends that data through the exercise connection.

Additionally, it discusses how position and orientation thresholds are used to determine when position and orientation data needs to be sent to other exercise participants. The text also explains how to set these thresholds using the DtThresholder class.

Finally, it provides information on removing a locally-simulated entity by deleting a DtEntityPublisher, which removes an entity from the exercise in HLA or sends a final Entity State PDU with the FinalPdu appearance bit set in DIS.

The chapter discusses working with remote entities in VR-Link. A `DtReflectedEntityList` maintains the current state of entities learned about through updates received from other participants in an exercise. Each entity in the list is represented by an instance of `DtReflectedEntity`.

**Creating Reflected Entity Lists**

A `DtReflectedEntityList` is created on an exercise connection as follows:
```c
DtExerciseConn exConn(...);
...
DtReflectedEntityList(&exConn);
```
The list automatically creates a new `DtReflectedEntity` to represent each new entity and updates the corresponding entity when it receives a state update.

**Iterating Through a DtReflectedEntityList**

To iterate through a `DtReflectedEntityList`, use the following functions:
```c
for (DtReflectedEntity* ent = rel.first();
    ent;
    ent = ent->next())
{
    ...
}
```
You can also use `wrapNext()` and `wrapPrev()` to loop back to the first or last entity in the list.

**Looking Up a DtReflectedEntity by ID**

Use the `lookup()` function to look up an entity by its global or local ID:
```c
DtGlobalObjectDesignator id = fireInteraction.targetId();
DtReflectedEntity* ent = reflectedEntityList.lookup(id);

#elif DtDIS
DtObjectId id = DtEntityIdentifier(1, 2, 3);
#endif
DtReflectedEntity* ent = reflectedEntityList.lookup(id);
```
**Delayed Discovery of Reflected Objects**

You can delay discovery of reflected objects until a user-defined condition is met. Use the `setDiscoveryCondition()` function to specify the discovery condition:
```c
predicate_function(bool) {
    // return true when the object should be discovered
};
reflectedEntityList.setDiscoveryCondition(predicate_function);
```
This functionality is useful in HLA applications when an object is discovered before attribute information arrives.

1. **Waiting for Entity Type**: To wait until an entity type is known before discovering entities, you can set a discovery condition using `setDiscoveryCondition()` and provide a callback function that returns `true` when the desired entity type is reached.

Example:
```c
bool criteria(DtReflectedObject* obj, void* usr)
{
   DtReflectedEntity* ent = (DtReflectedEntity*) obj;
   if (ent->esr()->entityType() == DtEntityType(0,0,0,0,0,0,0))
   {
      return false;
   }
   return true;
}

DtReflectedEntityList rel(&exConn);
rel.setDiscoveryCondition(criteria, NULL);
```

2. **Inspecting Entity State**: The `DtEntityStateRepository` class is used to store the current state of an entity. You can inspect various components of an entity's state using inspector functions such as `location()`, `velocity()`, `acceleration()`, `orientation()`, and more.

Example:
```c
void printStateOfFirstEnt(DtReflectedEntityList *rel)
{
   // ...
   DtEntityStateRepository *esr = firstEnt->entityStateRep();
   cout << "ID: " << firstEnt->globalId().string() << '\n'
        << "Loc: " << esr->location().string() << '\n'
        << "Vel: " << esr->velocity().string() << '\n'
        << "Accel: " << esr->acceleration().string() << '\n'
        << "Orient: " << esr->orientation().string() << '\n'
        << "AngVel: " << esr->rotationalVelocity().string() << endl;
   // ...
}
```

3. **Dead-Reckoning**: By default, the position, velocity, and orientation returned by `DtEntityStateRepository` are dead-reckoned values, which means they are extrapolated forward from acceleration, velocity, and angular velocity based on the entity's current dead-reckoning algorithm.

Note that this behavior can be changed by setting `discoverOnlyWhenEntityTypeKnown(true)` when creating a `DtReflectedEntityList`.

The current value of VR-Link simulation time is the last value passed to `setSimTime()`, which should be called once per frame by an application. This ensures that all entities are dead-reckoned to the same time within that frame, regardless of the order in which their locations are inspected.

Dead-reckoning is performed using a `DtDeadReckoner` object, which calculates the position and orientation of an entity based on its current rates of movement and the time that has passed since the last update. The `DtEntityStateRepository` uses a `DtDeadReckoner` to perform dead-reckoning calculations.

To change the way dead-reckoning is handled by a `DtEntityStateRepository`, you can create a subclass of `DtDeadReckoner` and override its virtual functions, or pass NULL to `setApproximator()` to disable dead-reckoning altogether.

The text also discusses different dead-reckoning algorithms, including rotational and fixed algorithms, as well as the use of smoothing to reduce jumps in entity position. Smoothing can be enabled globally using `DtSmoother`'s static function `setDfltSmoothPeriod()`, or individually using `setSmoothPeriod()`.

Finally, the text notes that dead-reckoning applies to entities and aggregates, but not to other objects, and provides information on how to learn when entities join or leave an exercise.

Here is the code examples mentioned in the text:

* `setSimTime()`
* `useDeadReckoner()`
* `DtEntityStateRepository`'s member functions (e.g. `lastSetLocation()`, `lastSetVelocity()`)
* `DtDeadReckoner`'s virtual functions (e.g. `deadReckonPosition()`, `deadReckonOrientation()`)
* `setApproximator()`
* `useSmoother()`
* `setDfltSmoothPeriod()`
* `setSmoothPeriod()`

The text discusses how to receive notifications when entities join or leave an exercise in a Distributed Simulation (DS) application using VR-Link. This is achieved by registering entity-addition and entity-removal callbacks with a `DtReflectedEntityList`. The callbacks are called by VR-Link just after an entity is added or removed from the list.

The text provides two methods for receiving notifications:

1. **Callback method**: Register entity-addition and entity-removal callbacks using `addEntityAdditionCallback()` and `addEntityRemovalCallback()`. These callbacks must have the signature `void func(DtReflectedEntity* ent, void* userData);`.
2. **Subclassing method**: Subclass `DtReflectedEntityList` and override the virtual functions `entityAdded()` and `removeAndDelete()`.

The text also discusses considerations for implementing these callbacks:

* Entity-addition and entity-removal callbacks are called from within RTI callbacks, so do not make any RTI calls or call any functions that make RTI calls.
* The state of an entity is available in the `entityAdded()` function, but it may not be available in the entity-addition callback for DIS applications.

Additionally, the text introduces post-update callbacks, which are called by VR-Link immediately after a state update message has been decoded into the reflected entity's `DtEntityStateRepository`. These callbacks can be registered using `addPostUpdateCallback()` and unregistered using `removePostUpdateCallback()`.

Here is an example of registering entity-addition and entity-removal callbacks:
```cpp
void printHello(DtReflectedEntity* ent, void* userData)
{
   assert(ent);
   cout << "HELLO " << ent->id().string() << endl;
}
void printGoodbye(DtReflectedEntity *ent, void *userData)
{
   assert(ent);
   cout << "GOODBYE " << ent->id().string() << endl;
}

int main()
{
   ...
   rel->addEntityAdditionCallback(printHello, 0);
   rel->addEntityRemovalCallback(printGoodbye, 0);
   ...
}
```
And here is an example of registering a post-update callback:
```cpp
void myPostUpdateCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // Check for entity type information in the ESR
}

void myEntityAdditionCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // A new entity has arrived, but its ESR is empty. Ask to be notified when an update has been processed.
   ent->addPostUpdateCallback(myPostUpdateCb, 0);
}
```

**Post-Update Callback**

A post-update callback can be registered to receive notifications when an entity's state has been updated. The callback function `myPostUpdateCb` is called after each update, but it does not have access to the update message itself.

```c
void myPostUpdateCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // ...
}
```

**Timing Out Entities**

Entities can be timed out if an update has not been received within a certain period of time. This is on by default in DIS, where entities must send periodic heartbeats (usually once every 5 seconds). If no heartbeat is received within 12 seconds, the entity can be safely assumed to have left the exercise.

**Subclassing DtReflectedEntity**

To associate additional data or functionality with a `DtReflectedEntity`, it can be subclassed. This requires subclassing `DtReflectedEntityList` as well, since `DtReflectedEntities` are created by `DtReflectedEntityList`. The example shows how to subclass both classes:

```c
class myReflectedEntity : public DtReflectedEntity
{
public:
   // Constructor
#if DtHLA
   myReflectedEntity(DtHlaObject* obj, DtExerciseConn* conn) : DtReflectedEntity(obj, conn)
#elif DtDIS
   myReflectedEntity(DtExerciseConn* conn,
      const DtEntityIdentifier& id, const DtEntityType& type) :
      DtReflectedEntity(conn, id, type)
#endif   
   {
      // ...
   }
   // Specifics of myReflectedEntity
   ...
};

class myREL : public DtReflectedEntityList
{
public:
   // Constructor (same for both DIS and HLA)
   myREL(DtExerciseConn* exConn) : DtReflectedEntityList(exConn) {}
#if DtHLA
   virtual DtReflectedEntity* newReflectedEntity(DtHlaObject* obj) const
   {
      return new myReflectedEntity(obj, exerciseConn());
   }
#elif DtDIS
   virtual DtReflectedEntity* newReflectedEntity(const DtEntityIdentifier& id, const DtEntityType& type) const
   {
      return new myReflectedEntity(exerciseConn(), id, type);
   }
#endif
};
```

**Identifying Objects**

Objects are identified differently in DIS and HLA. In DIS, entities are identified by a triplet (site:application:entity) known as an entity identifier, which can be represented using the `DtEntityIdentifier` class.

The text also discusses how VR-Link identifies objects and provides guidance on choosing a name for HLA objects.

The text discusses how non-entity objects are identified in various ways, including emitter systems, HLA (High Level Architecture), and VR-Link.

In HLA, an object can be identified by its object handle or object name. The object handle is unique within a federation execution and is used to identify a particular object in RTI service calls. The object name is a character string that can be used to identify an object and is known to the RTI.

VR-Link provides two types of identifiers: DtObjectId (local ID) and DtGlobalObjectDesignator (global ID). DtObjectId is a wrapper around an RTI::ObjectHandle and is used to identify an object within an application. DtGlobalObjectDesignator is a VR-Link wrapper around char* that can be used to store object names.

The text also discusses how reflected object lists allow you to look up reflected objects by local ID or global ID, and provides examples of using these identifiers in code.

In HLA, when constructing a publisher, you can choose a name for your object or pass a NULL name (the default) and let the RTI choose for you. The text provides an example of how to reserve a name in HLA and create a publisher with the reserved name.

Finally, the text mentions that most procedures for managing entities apply to managing other types of objects, but you use different subclasses of DtObjectPublisher, DtReflectedObjectList, DtReflectedObject, and DtStateRepository to manage the appropriate type of objects.

Here is the code example provided in the text:

* In HLA:
```c
fireInter.setAttackerId(entityPub.globalId());
```
* In DIS:
```c
DtEntityPublisher representing an entity that you are simulating, and you are sending a fire interaction, indicating that your entity is firing a munition, you might say:
```
fireInter.setAttackerId(entityPub.globalId());
```
* Looking up an object in a reflected entity list:
```c
DtReflectedEntity* ent = rel.lookup(fireInter.attackerId());
```
* Reserving a name in HLA:
```c
myExconn->rtiAmb()->reserveObjectInstanceName();
```
Note that these code examples are provided to illustrate how the identifiers are used, but they may not be complete or functional code.

For emitters, it is recommended to use the DtEmitterSystemPublisher class to create a publisher for an emitter system, and then add beams to the system repository using the addBeam() function. The state of each beam can be set using the corresponding DtEmitterBeamRepository class.

On the receiving side, you can create an instance of DtReflectedEmitterSystemList and iterate through or look up systems. When inspecting a DtEmitterSystemRepository, it contains a list of DtEmitterBeamRepositories for the system's beams, available through beamList().

Here is an example code snippet for managing emitters:

```c
// Create the system publisher
DtEmitterSystemPublisher sysPub(&conn);
// Get a pointer to its system state repository
DtEmitterSystemRepository* esr = sysPub.esr();
// Add a beam, and keep a pointer to its beam repository
// Give the beam a beam ID of 10. DtEmitterBeamRepository* bsr = esr->addBeam(10);
// Set the beam's parent system ID
bsr->setEmittingSystemId(sysPub.globalId());
while (...)
{
   // Each frame, you can set various attributes of the system's
   // state using esr, and of the beam's state using bsr. ...
   // Then just tick the system publisher. This will cause any
   // necessary system and beam data to be sent. sysPub.tick();
   ...
}
```

The text also mentions that beams can come and go while the system exists in HLA, and provides an example of looking up a DtEmitterBeamRepository:

```c
DtReflectedEmitterSystemList sysList(&conn);
while (...)
{
   ...
   // Get a pointer to the first system in the list. DtReflectedEmitterSystem* sys = sysList.first();
   // Get a pointer to the system's state repository. DtEmitterSystemRepository* esr = sys->esr();
   // Get a pointer to the system's first beam's state repository
   DtEmitterBeamRepository* bsr = 
      (DtEmitterBeamRepository*) esr->beamList()->first()->data();
   // Now you can use esr and bsr to inspect the state of the system
   // and its first beam. 
}
```

The text also mentions that VR-Link obtains HLA updates for a beam without having first discovered its parent system, it creates a phantom system with the object name indicated by the beam's emittingSystemId attribute, and adds a beam state repository representing the beam to that phantom system's repository.

1. DtUtmView: supports UTM coordinates
2. DtCartesianView: supports any arbitrary Cartesian coordinate system
3. DtTopoView: derived from DtCartesianView and supports topographic coordinate systems

The views provide access to the data in the desired coordinate system by calling down to the underlying `DtEntityStateRepository`'s functions before or after doing the conversions.

The text also provides examples of how to use these views, including:

* Creating a `DtTopoView` object and using its mutators to set positions and orientations specified with respect to a topographic coordinate system
* Using a `DtTopoView` object to inspect a remote entity's data in topographic coordinates
* Creating a `DtUtmView` object and using its inspectors and mutators to work with UTM coordinates

The text also mentions that rotational velocity is always specified in body rather than geocentric coordinates, so the views' `rotationalVelocity()` and `setRotationalVelocity()` functions pass the `DtEntityStateRepository` values through without any conversion.

Here is a summary of the code examples provided:

**Topographic Coordinate View**

* Creating a `DtTopoView` object:
```c
DtEntityPublisher entPub(...);
DtEntityStateRepository* esr = entPub.entityStateRep();
DtTopoView topoView(esr, DtDeg2Rad(36.0), DtDeg2Rad(-121.0));
```
* Setting positions and orientations using `topoView` mutators:
```c
topoView.setLocation(DtVector(100.0, 100.0, 0.0));
topoView.setVelocity(DtVector(10.0, 10.0, 0.0));
topoView.setAcceleration(DtVector(1.0, 1.0, 0.0));
topoView.setOrientation(DtTaitBryan(0.0, DtDeg2Rad(10.0), 0.0));
topoView.setRotationalVelocity(DtVector(0.0, 0.10, -0.125));
```
* Inspecting positions and orientations using `topoView` inspectors:
```c
DtVector topoLoc = topoView.location();
DtVector topoVel = topoView.velocity();
DtVector topoAccel = topoView.acceleration();
DtTaitBryan topoOrient = topoView.orientation();
DtDcm bodyToLocal = topoView.bodyToLocal();
DtVector angVel = topoView.rotationalVelocity();
```

**UTM Coordinate View**

* Creating a `DtUtmView` object:
```c
DtReflectedEntityList rel(...);
...
DtReflectedEntity* ent = rel.first();
DtEntityStateRepository* esr = ent->entityStateRep();
DtUtmView utmView(esr);
```
* Using `utmView` inspectors and mutators to work with UTM coordinates:
```c
// (no examples provided)
```

**Cartesian Coordinate View**

* Creating a `DtCartesianView` object:
```c
// (no examples provided)
```
* Using `DtCartesianView` inspectors and mutators to work with Cartesian coordinates:
```c
// (no examples provided)
```

Note that the text does not provide any code examples for creating or using `DtCartesianView` objects.

**Working with Articulated Parts**

Articulated parts are movable parts of an entity, such as a turret, gun, or landing gear. The state of an entity's articulated parts is part of its state and can be accessed through a `DtEntityStateRepository`.

**Inspecting Articulated Parts Data**

* Use the `partCount()` member function to get the number of articulated parts.
* Use the `totalParameterCount()` member function to get the number of articulation parameters.
* Iterate through the articulated parts using the `begin()` and `end()` member functions.
* Get a list of parameters set for a `DtArticulatedPart` using the `getParameterMetrics()` member function.
* Get the value of a particular parameter:
	+ Call `isParameterSet()` to check if the parameter is set.
	+ Call `getParameterValue()` to get the value of the parameter.
	+ Use `getParameter()` to retrieve the non-dead-reckoned value.

**Example Code**

```c
DtReflectedEntityList rel(...);
....
DtReflectedEntity* firstEnt = rel.first();
DtEntityStateRepository* esr = firstEnt->entityStateRep();
DtArticulatedPartCollection* artParts = esr->artPartList();
DtArticulatedPart* turret = artParts->findPart(DtPrimaryTurret1);
float turAz = 0.0;
if (turret)
{
   if (turret->isParameterSet(DtApAzimuth))
   {
      turAz = turret->getParameterValue(DtApAzimuth);
   }
   else
   {
      printf("Entity has no turret azimuth.\n");
   }
}
else
{
   printf("Entity has no turret.\n");
}
```

**The `DtArticulatedPart` Class**

* Get a pointer to a particular `DtArticulatedPart` using the `findPart()` member function.
* Get a reference to the `DtArticulatedPart` using the `getPart()` member function.
* Iterate through the `DtArticulatedPartCollection` as follows:
```c
for (DtArticulatedPartCollection::iterator artPartIter = parts->begin();
     artPartIter != parts->end();
     ++artPartIter)
{
   int currentPartType = artPartIter->first;
   DtArticulatedPart* currentPart = artPartIter->second;
}
```

**Setting Articulated Parts Data**

* An articulated parts collection is empty when it is first created.
* Create articulated or attached parts by calling the `getPart()` member function on the collection.

**Attaching Parts**

To attach a part to another, use `attachPart()` on the collection, passing in a pointer to the child part and a pointer to the parent part. For example:
```c
DtArticulatedPartCollection* artPartCollection = myESR->artPartList();
DtArticulatedPart& turret = artPartCollection->getPart(DtPrimaryTurret1);
DtArticulatedPart& gun = artPartCollection->getPart(DtPrimaryGun1);
artPartCollection->attachPart(&gun, &turret);
```
**Setting Parameters**

To specify a parameter value for an articulated part, use `setParameter()` on the part. For example:
```c
artPartCollection->getPart(DtPrimaryTurret1).setParameter(DtApAzimuth, DtDeg2Rad(myTurretAz));
artPartCollection->getPart(DtPrimaryTurret1).setParameter(
DtApAzimuthRate, DtDeg2Rad(myTurretAzRate));
artPartCollection->getPart(DtPrimaryGun1).setParameter(DtApElevation, DtDeg2Rad(myGunElev));
```
**Attached Parts**

An attached part is an entity that is attached to another entity. Use `DtEntityStateRepository::attPartList()` to get a pointer to a protocol-independent `DtAttachedPartCollection`. For example:
```c
// Create the publisher, and get its ESR's attached parts list
DtEntityPublisher pub(...);
DtEntityStateRepository* esr = pub.esr();
DtAttachedPartList* attList = esr->attPartList();
// Add a single attached part, a sidewinder missile attached to station number 15
DtAttachedPart& newPart = attList->getPart(15);
newPart->setEntityType(DtEntityType(2, 1, 225, 1, 1, 0, 0));
```
**Using Independent VR-Link Objects in Multiple Threads**

When using VR-Link in multi-threaded applications, be aware of the following:

* Static variables used for initialization should be treated with care if their values might be modified concurrently by multiple threads.
* License management communication with the license server can become confused if two objects try to check out licenses at the same time.

To avoid conflicts, stagger the creation of conflicting objects using `DtSleep()` or use global functions like `DtSetMapDatum()`, `DtCurrentMapDatum()`, and `DtUtmInit()`.

**Using Independent VR-Link Objects in Multiple Threads (continued)**

Two classes make it possible to use multiple reference data simultaneously: `DtReferenceEllipsoid` and `DtUtmReferencePoint`. For example:
```c
DtDegMinSec latRef = {35.0, 0.0, 0.0, DtNorth};
DtDegMinSec lonRef = {122.0, 0.0, 0.0, DtWest};
DtUseMapDatum(DtWGS84);
DtUtmInit(latRef, lonRef, 1);  // this will use the global map datum
DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0);
DtUtmCoord utm(geod);

// equivalent to:
DtReferenceEllipsoid ellipse(DtWGS84);
DtUtmReferencePoint refUtm(latRef, lonRef, 1, 0, DtWGS84);
DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0, &ellipse);
DtUtmCoord utm(geod, &refUtm);
```
**Controlling MAK Products Remotely**

MAK Data Logger, VR-Vantage, and VR-Forces have remote control APIs that allow you to control them from other applications. Use the `loggerControlToolkit` or `stealthControlToolkit` libraries provided with VR-Link for backward compatibility. The preferred method is to link against the libraries provided with the version of the application that you want to control.

The HLA-Specific Interface chapter describes the HLA-specific classes and features of VR-Link, which are used to interact with the RTI (Run-Time Infrastructure) directly.

**Introduction to the HLA-Specific Interface**

This section explains that most users will find the protocol-independent interface sufficient, but developers working only with HLA may want to use the HLA-specific classes. It also provides a note on how to enclose HLA-specific code within preprocessor directives to ensure compatibility with DIS.

**Interacting Directly with the RTI**

This section describes how to interact directly with the RTI using the RTIambassador and FederateAmbassador classes. It explains that most applications will not need to access the RTI directly, but some may want to mix and match VR-Link's functions with direct calls to the RTI.

**Building Applications for Use with the RTI 1516 Specification**

This section provides information on building applications compatible with the RTI 1516 specification. It explains that most types in the 1516 RTI API have the same name as in the 1.3 RTI API, but some exceptions exist (e.g., the elimination of AttributeHandleValuePairSet and the use of std::wstring instead of char* or std::string).

**Federate-Initiated Services**

This section explains how to invoke federate-initiated services using the RTI ambassador's member functions. It provides an example of calling the queryAttributeTransportationType() service.

**RTI-Initiated Services**

This section describes how to handle RTI-initiated services, which are invoked when the RTI calls virtual member functions of RTI::FederateAmbassador(). Federates must derive a class from RTI::FederateAmbassador and provide definitions for these pure virtual functions.

**Subclassing DtVrlFederateAmbassador**

This section explains how to subclass DtVrlFederateAmbassador to access the data provided by RTI-initiated services. It provides an example of deriving a class from DtVrlFederateAmbassador and implementing new definitions for the virtual functions.

Code examples:

* `#if DtHLA #if DtHLA_1516 #if DtHLA_1516_EVOLVED // 1516 evolved specific #else // 1516 specific #endif #else // 1.3 specific #endif #endif`
* `DtExerciseConn exConn(...); ... DtVrlRtiAmbassador* rtiAmb = exConn.rtiAmb(); rtiAmb.queryAttributeTransportationType(...);`
* `class MyFederateAmbassador : public DtVrlFederateAmbassador { ... };`

The text discusses how to create a subclass of `DtVrlFederateAmbassador` and use it with `DtExerciseConn`. It also explains how to get information about the FOM (Federal Object Model) using `DtFom`.

To create a subclass of `DtVrlFederateAmbassador`, you need to define your own implementation for the `initiatePause()` function. This function is called when the RTI initiates a pause.

You also need to tell `DtExerciseConn` about your derived class by using the static member function `setFedAmbCreator()`. This function expects a `DtFedAmbCreator()` function as an argument, which returns a new instance of a `DtVrlFederateAmbassador` or a subclass of it.

The text also explains how to get information about the FOM using `DtFom`. You can obtain a pointer to a `DtExerciseConn`'s `DtFom` using the member function `fom()`. A `DtFom` contains a list of object class and interaction class descriptors, which contain information about FOM classes.

The text also discusses how to publish and subscribe to FOM classes and attributes. Publishing involves telling the RTI the set of FOM classes and the set of attributes of object classes for which it is capable of sending data. Subscribing involves telling the RTI the set of FOM classes and the set of attributes of object classes that a federate wants to receive data about.

Here are the code examples:

```cpp
class MyFedAmb : public DtVrlFederateAmbassador {
public:
   virtual void initiatePause(const RTI::PauseLabel label)
      throw (RTI::FederateAlreadyPaused, RTI::FederateInternalError);
};

void MyFedAmb::initiatePause(const RTI::PauseLabel label)
      throw (RTI::FederateAlreadyPaused, RTI::FederateInternalError)
{
   // Your code to handle the pause
   ...
   // Call superclass version in case it's 
   // doing anything important
   DtVrlFederateAmbassador::initiatePause(label);
}

DtVrlFederateAmbassador* MyFedAmbCreator() {
   return new MyFedAmb();
}
```

```cpp
DtExerciseConn::setFedAmbCreator(MyFedAmbCreator);
...
// The DtExerciseConn we create here will use a MyFedAmb as 
// its federate ambassador
DtExerciseConn exConn(...);
```

```cpp
for (DtObjClassDesc* desc = fom->firstObjClass(); desc; 
desc = fom->nextObjClass(desc)) {
   std::cout << "ClassName: " << desc->name() << std::endl;
}
```

```cpp
#if DtHLA_1516
   DtListItem *item;
   for(item = objClassList()->first();
      item;
      item= item->next();
   {
      DtObjectClassDesc *objDesc =
         static_cast<DtObjClassDesc *>item->data();
#else
   for (DtObjClassDesc *objDesc = fom->firstObjClass()
      objDesc;
      objDesc = fom->nextObjClass(objDesc))
   {
#endif
      // Now code is independent
      std::cout << "ClassName: " << objDesc->name() << std::endl;
      ... 
```

Note that the text assumes that you have already created a `DtExerciseConn` instance and obtained its `DtFom` using the member function `fom()`.

HLA federates must indicate to the RTI (Run-Time Infrastructure) which FOM (Federate Object Model) classes and attributes they are interested in receiving data from other federates. This initialization activity is called "subscribing". VR-Link applications do not need to do anything special for publishing and subscribing, but if needed, it can be done through VR-Link.

**Publishing Classes and Attributes**

When creating an object publisher, VR-Link determines which FOM class should be used to represent the object. Before registering the new HLA object with the RTI, the federate publishes the object class if it has not already published the class or explicitly unpublished it. By default, the full set of valid attributes is published. To publish only a subset of an object class's attributes, the `DtObjClassDesc::publish()` method must be used.

**Example: Publishing only EntityType and Position attributes of GroundVehicle class**

```c
#include <vlutil/vlStringUtil.h> // For DtToWString

// ...

DtExerciseConn  exConn(...);
...
#if DtHLA
   DtObjClassDesc *desc = exConn.fom()->objClassByName(
      "BaseEntity.PhysicalEntity.Platform.GroundVehicle");
   assert(desc);
   RTI::ObjectClassHandle classHand = desc->handle();
#if DtHLA_1516
   // ...
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(classHand, L"EntityType"));
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(classHand, DtToWString("Position")));
   desc->publish(hSet);
#else
   RTI::AttributeHandleSet *hSet = RTI::AttributeHandleSetFactory::create(2);
   hSet->add(exConn.rtiAmb()->getAttributeHandle("EntityType", classHand));
   desc->publish(*hSet);
   delete hSet;
#endif
#endif
```

**Publishing Interactions**

Publishing interactions works differently from publishing objects. You cannot publish only a subset of the parameters of an interaction. You either publish an interaction class with all its parameters or not at all.

**Subscribing to Classes and Attributes**

A reflected object list's constructor typically subscribes to object classes. A particular kind of reflected object list (e.g., `DtReflectedEntityList`) determines which FOM classes it is interested in, then subscribes to each of those classes to which the federate is not already subscribed.

**Example: Subscribing to GroundVehicle and Munition FOM classes**

```c
...
#if DtHLA
   DtList handleList;
#if DtHLA_1516
   std::wstring hName(L"BaseEntity.PhysicalEntity.Platform.GroundVehicle");
   handleList.add(new RTI::ObjectClassHandle(exConn.rtiAmb()->getObjectClassHandle(hName)));
#else
   // ...
   handleList.add((void *) exConn.rtiAmb()->getObjectClassHandle("BaseEntity.PhysicalEntity.Platform.GroundVehicle"));
   handleList.add((void *) exConn.rtiAmb()->getObjectClassHandle("BaseEntity.PhysicalEntity.Platform.Munition"));
#endif
   // Create the Reflected Entity List
   DtReflectedEntityList(&exConn, &handleList);
   ...
#if DtHLA_1516
   // Clean up handles
   for (DtListItem *item = handleList.first(); item;)
   {
      DtListItem* next = item->next();
      RTI::ObjectClassHandle *hand = static_cast<RTI::ObjectClassHandle *>(item->data());
      handleList.remove(item);
      delete hand;
      item = next;
   }
#endif
```

By default, when VR-Link subscribes to an object class, it subscribes to all attributes of the class.

The text discusses how to manage HLA (High-Level Architecture) objects in VR-Link using the RTI (Run-Time Infrastructure) API. It explains that subscribing to only a subset of an object class's attributes is done using the `DtObjClassDesc::subscribe()` function, but not directly through RTI services.

The text also covers subscription to interaction classes, which typically occurs when registering a callback function with a VR-Link interaction class. However, the RTI API does not allow subscribing to a subset of an interaction's parameters.

The main topic is managing HLA objects using instances of the `DtHlaObject` class. The text explains how to find out when HLA objects are discovered and removed, intercept reflected attribute values, force attribute updates, and reflect locally-generated updates.

It also provides examples of how to use the `DtHlaObjectManager` class to manage HLA objects, including printing the IDs of all current reflected or local HLA objects. The text concludes by describing additional member functions of the `DtHlaObject` class that provide more specialized information about an HLA object.

The code example provided is:

```c
#include <vl/rtiCompatibility.h>
DtExerciseConn exConn(...);
...
// Subscribe to various object classes, process discoverObjects and
// reflectAttributeValues calls. (This is usually achieved simply by
// creating a DtReflectedObjectList.) ...
DtHlaObjectManager* objMgr = exConn.hlaObjectManager();
const DtList& allObjects = objMgr->allHlaObjects();
for (DtListItem* item = allObjects.first(); item; 
   item = item->next())
{
   // Cast the generic void* to a DtHlaObject*
   DtHlaObject* obj = (DtHlaObject*) item->data();
   std::cout << "id: " << obj->objectId() << std::endl;
}
```

This code prints the IDs of all current reflected or local HLA objects.

1. Registering "objectAddition" and "objectRemoval" callbacks with a DtReflectedObjectList or deriving from a subclass of DtReflectedObjectList to provide new definitions for the objectAdded() and removeAndDelete() virtual functions.
2. Using the addDiscoverObjectCallback() and removeDiscoverObjectCallback() member functions of the DtExerciseConn class to register callback functions that will be called when an HLA object is discovered or removed.
3. Registering a "discoverObject" callback function with the DtExerciseConn for a specific object class using the addDiscoverObjectCallback() member function, and unregistering it using removeDiscoverObjectCallback().

The text also describes how to use the addRemoveObjectCb() and removeRemoveObjectCb() member functions of the DtHlaObject class to register and unregister removal callback functions.

Additionally, the text explains how to intercept reflected attribute values by registering a postUpdate() callback with a DtReflectedObject or using the addPostReflectCb() member function of the DtHlaObject class. The callback function should match the signature defined in objectReflectAttributeValuesCbInfo.h.

Finally, the text describes how to force attribute updates by calling the tick() function of the DtObjectPublisher class, which calls down to its DtHlaObject's update() function to decide which attributes need to be sent and then sends them.

1. Only published attributes that are also subscribed to by remote federates are eligible for sending.
2. Of these eligible attributes, only those whose update conditions have been met or were explicitly requested by a remote federate are sent.

The text also discusses the following topics:

* Reflecting locally-generated updates: VR-Link allows turning on reflection of locally generated data using the `setReflecting()` function. This enables objects published and updated locally to appear in reflected object lists, with the publisher and reflected object sharing a state repository.
* Ownership management: HLA supports ownership management services, which allow transferring responsibility for sending updates from one federate to another. The `DtHlaObject` class encapsulates HLA details of an object, and both `DtObjectPublishers` and `DtReflectedObjects` have member functions that return the `DtHlaObject`. Ownership management blurs the line between locally simulated objects and reflected objects, allowing multiple publishers and reflected objects to share a single `DtHlaObject`.

The code examples provided are:

* None

Note: The text does not contain any explicit code examples. However, it provides information on how to use certain functions and classes in VR-Link, such as `setReflecting()`, `hlaObject()`, and `DtHlaObject`.

When using VR-Link, it's possible for multiple federates to send attribute updates for an object, including the local federate. When a publisher's destructor is called, VR-Link will delete the corresponding HLA object if the local federate owns the `privilegeToDelete` attribute. However, this behavior can be changed using `setDeleteObjInDtorFlag()`.

If the underlying HLA object is deleted by a remote federate, the publisher's `DtHlaObject` pointer will be set to NULL, and subsequent ticks will be no-ops. To be notified when an object is deleted, you can register a `removeObject()` callback with the `DtHlaObject` using its `addRemoveObjectCb()` function or register an `objectRemoval()` callback for the corresponding `DtReflectedObject` with your `DtReflectedObjectList`.

When using ownership management, it's recommended to call `DtExerciseConn::setReflecting()` to enable reflecting locally-generated updates. If self-reflecting is not turned on, you must manually manage publish and reflected lists when an object transfer occurs.

`DtHlaObject` has several member functions that wrap the RTI's federate-initiated ownership management services:

* `acquireObject()`
* `divestObject()`
* `unconditionalDivest()`
* `negotiatedDivest()`
* `acquireAttributes()`
* `cancelNegotiatedDivest()`
* `cancelAcquireAttributes()`

It's recommended to use VR-Link's ownership-related functions rather than calling the RTI's functions directly.

The `DtOwnershipHandler` class allows you to receive ownership-related callbacks, such as notification that you have successfully acquired or divested ownership of a set of attributes. There are three different `DtOwnershipHandler` classes: `DtDefaultOwnershipHandler`, `DtPartialOwnershipHandler`, and `DtRprOwnershipHandler`. You can also write your own `DtOwnershipHandler`.

Here is the code examples:

* `setDeleteObjInDtorFlag()`
* `addRemoveObjectCb()`
* `objectRemoval()`
* `acquireObject()`
* `divestObject()`
* `unconditionalDivest()`
* `negotiatedDivest()`
* `acquireAttributes()`
* `cancelNegotiatedDivest()`
* `cancelAcquireAttributes()`

The text discusses ownership management in HLA (High-Level Architecture) using VR-Link. There are two ways to register an ownership handler: globally by calling `setDefaultOwnershipHandler` on a `DtExerciseConn`, or individually by using `setOwnershipHandler()` on a `DtHlaObject`.

The text then provides several examples of implementing ownership management:

* Acquiring objects: Create a publisher for the object, call `acquireObject()`, and attach an ownership handler to notify when acquisition succeeds.
* Divesting attributes: Call `unconditionalDivest()` or `negotiatedDivest()` on the publisher's `DtHlaObject` to initiate divestiture. Attach an ownership handler to notify when another federate assumes ownership.
* Giving up attributes if requested: Create a publisher and attach an ownership handler that accepts all divestitude actions.
* Acquiring attributes if offered: Set a default ownership handler for the exercise connection, set the acquisition action to always accept all acquisitions, and add a callback to notify when an acquisition is successful.

The text also discusses using Data Distribution Management (DDM) with VR-Link. There are two ways to use DDM: using the DDM scheme implemented by VR-Link's publishers or passing in your own DDM region and manipulating it manually.

Here are the code examples from the text:

* Example 1: Acquiring objects
```cpp
void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
myExerciseConnection->setOwnershipHandler(&defaultHandler);

// Create the reflected entity list
DtReflectedEntityList rel(...);
...
```

* Example 2: Divesting attributes
```cpp
void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}
// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the
// instance. DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);

// Initiate the divest
RTI::AttributeHandleSet* hSet =
   RTI::AttributeHandleSetFactory::create(3);
hSet->add(1);
hSet->add(2);
hSet->add(3);
obj->negotiatedDivest(*hSet);
delete hSet;
```

* Example 3: Giving up attributes if requested
```cpp
void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}
// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the
// instance. DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
```

* Example 4: Acquiring attributes if offered
```cpp
void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
myExerciseConnection->setOwnershipHandler(&defaultHandler);

// Create the reflected entity list
DtReflectedEntityList rel(...);
...
```

Note that these code examples are not complete and may require additional setup or context to work correctly.

The default VR-Link DDM scheme uses a space named BenchmarkGeographicSpace with two dimensions, X and Y, corresponding to longitude and latitude.

**5.7 Geographic DDM**

* The `DtEntityPublisher` and `DtAggregatePublisher` can create their own DDM regions on instantiation and update them based on entity location and velocity.
* To enable geographic DDM in the `DtExerciseConn`, set `exConn.setUseGeographicDdm(true);`.
* The exercise connection has a "playbox" that defines the minimum and maximum values of latitude and longitude for DDM normalization. The region bounds may not exceed those specified by the playbox.
* To change the playbox, use the following code:
```java
DtGeodeticCoord lowerBound(DtDeg2Rad(30.0), DtDeg2Rad(-130.0), 0);
DtGeodeticCoord upperBound(DtDeg2Rad(40.0), DtDeg2Rad(-120.0), 0);
exConn.setDdmPlayboxLowerBound(lowerBound);
exConn.setDdmPlayboxUpperBound(upperBound);
```

**5.7.1 Publishing Using Geographic DDM**

* To publish with a geographic region, set `exConn.setUseGeographicDDM(true);`.
* When an entity or aggregate publisher is created, the object is published using a region.
* The region can be accessed and passed to other publishers.

Example:
```java
exConn.setUseGeographicDdm(true);
DtEntityPublisher entityPub(...);
DtEmitterSystemPublisher emitterPub(&exConn, 0, entityPub.publishingRegion());
```

**5.7.2 Reflecting Using Geographic DDM**

* Create a geographic region and pass it into a reflected list to subscribe to a class with region.
* Use the `DtGeodeticRegion` class in VR-Link.

Example:
```java
DtGeodCoord lowerBound(DtDeg2Rad(35.0), DtDeg2Rad(118.0), 0);
DtGeodCoord upperBound(DtDeg2Rad(40.0), DtDeg2Rad(122.0), 0);
DtGeodeticRegionSP region(new DtGeodeticRegion(&exConn));
region->setRegionBounds(lowerBound, upperBound);
DtReflectedEntityList reflEntList(&exConn, region);
```

**5.7.3 Interactions with Regions**

* VR-Link lets you send and receive interactions in regions.
* The `addCallback` member function of each interaction can take a region shared pointer.
* Use the `sendStampedWithRegion` method to send an interaction with region.

Example:
```java
// Set up region bounds...
DtGeodeticRegionSP region(...);
DtFireInteraction::addCallback(&exConn, fireCb, NULL, region);
```

**5.7.4 Using DDM without VR-Link's Geographic Implementation**

* Create any type of region using the `DtDDMRegion` class.
* Specify the space (for HLA 1.3) and dimensions, and `DtDDMRegion` will create an RTI region that can be manipulated using normalized values.

**5.8 Using the DtInteraction Class**

* The HLA version of the `DtInteraction` class is defined in `interactionHLA.h`.
* Use the `setExConn()` method to set the `DtExerciseConn` and `DtInterClassDesc` associated with a particular instance.
* Call `setExConn()` before using many of `DtInteraction`'s member functions.

The `setExConn()` function in the `DtInteraction` class sets the current exercise connection and class descriptor for an interaction. If no class descriptor argument is provided, the subclass will choose a default one. The `DtExerciseConn` class typically calls `setExConn()` before sending an interaction.

On the incoming side, VR-Link calls `setExConn()` on the received interaction, passing the `DtExerciseConn` and the interaction class handle. Interaction classes store their parameter values in their native representation, which can be obtained using `phvps()` or `phvm()` functions.

The `DtInteraction` class has several functions that require a valid current exercise connection and class descriptor, including `interactionClassHandle()`, `interactionClassName()`, `numParameters()`, and `neededByFederation()`.

The class also has virtual printing functions, such as `print()`, `printHeader()`, `printParams()`, and `printData()`. These functions require a current exercise connection and class descriptor to fully function. The `setExConn()` function can be used to ensure that all data is printed correctly.

The text also discusses generic attributes and parameters in the FOM, which allow accessing extended information not normally supported. Enabling generics in VR-Link allows for simple access to new attributes and parameters without needing a code generator or hand modeling. There are two ways to enable generics: setting `genericAttributes` to true in the initializer or enabling unknown parameters on specific classes.

The text concludes by noting that generic attributes do not have type safety, but can be useful in situations where working with data quickly is more important than type safety.

The chapter discusses general HLA (High-Level Architecture) issues in VR-Link.

**5.10.1 Time Stamps**

HLA DtStateMsg or DtInteraction's time stamp can be set and inspected using the `setTimeStamp()` and `timeStamp()` functions. The `sendStamped()` function sets the time stamp of an outgoing HLA message to the current time. The time is encoded as a 8-byte ASCII representation of the hex number that would have been sent in a DIS (Distributed Interactive Simulation) time stamp.

**5.10.2 Registering and Responding to Synchronization Points**

The `DtExerciseConn` class can register synchronization points and user-defined callbacks for synchronization points. To register a synchronization point, call `exConn.registerSynchronizationPoint("point1");`. User-defined callbacks can be added or removed using member functions such as `addSynchPointRegistrationSucceededCb()` and `removeSynchPointRegistrationFailedCb()`.

**5.10.2.1 Responding to Synchronization Points Automatically**

By default, VR-Link applications automatically respond to announced synchronization points by immediately indicating that the point has been achieved. This can be disabled by calling `exConn.setReplyingToSynchronizationPoints(false);`.

**5.10.3 Time Management**

VR-Link supports HLA Time Management, which allows federates to synchronize and order events with a timeline maintained by the RTI (Run-Time Infrastructure). Federates use time management when interacting with other federates that have a different rate of simulation.

**5.10.3.1 Federation Time**

Federation Time (FedTime) is the managed simulation time for an exercise. In a time-managed federation execution, federates make time requests and receive time grants from the RTI. Regulating federates control the advancement of FedTime.

Some example code is provided:
```cpp
#include <vl/exerciseConn.h>

void fedsSynched(const char* label, void* /*usr*/)
{
    std::cout << "Federates synched at: " << label << std::endl;
}

void announcePoint(const char* label, const char* tag, void* usr)
{
    DtExerciseConn* exConn = (DtExerciseConn*)usr;
    std::cout << "Announce point: " << label << std::endl;
    std::cout << "Tag: " << tag << std::endl;
    usr->replyToSynchronizationPoint(label);
}

int main(int argc, char** argv)
{
    DtExerciseConn exConn(...);
    ...
    // fedsSynched is called whenever the federation is synched
    exConn.addFederationSynchedCb(fedsSynched, NULL);
    // announcePoint is called when the label "point2" is announced.
    // The exercise connection automatically replies to all synch points
    // excluding "point2"
    exConn.addAnnounceSynchPointCb("point2", announcePoint, &exConn);
    ...
}
```
Note that some code examples are incomplete and may require additional context or implementation.

**Time Regulation**

* Enable time regulation using `exConn.rtiAmb()->enableTimeRegulation(mySuggestedFedTime, myLookAhead);`
* Disable time regulation using `exConn.rtiAmb()->disableTimeRegulation();`
* Request a specific time advance using `exConn.rtiAmb()->timeAdvanceRequest(RequestedFedTime);`

**Sending Time Stamp Order (TSO) Messages**

* Enable sending TSO messages by setting `exConn.setSendFedTime(true);`
* VR-Link uses the simTime when sending FedTime, which must be maintained as FedTime + LookAhead
* If simTime is less than FedTime + LookAhead, an exception will be thrown

**Receiving TSO Messages**

* VR-Link handles incoming TSO messages transparently and ensures delivery at the correct FedTime

**Using Callbacks**

* Register callbacks for time advance request, time constrained enabled, and time regulation enabled events using `exConn.fedAmb()->addTimeAdvanceGrantCb()`, `exConn.fedAmb()->addTimeConstrainedEnabledCb()`, and `exConn.fedAmb()->addTimeRegulationEnabledCb()` respectively

**Converting FedTime to DtTime**

* VR-Link provides member functions for registering conversion functions using `DtExerciseConn::setFedTimeToVrlTimeConverter()` and `DtExerciseConn::setVrlTimeToFedTimeConverter()`
* Default conversion functions are provided for the MAK RTI, but can be overridden if necessary

**VR-Link Calls to RTI Services**

* The following Federate-initiated services may be called by VR-Link:
	+ createFederationExecution
	+ destroyFederationExecution
	+ joinFederationExecution
	+ resignFederationExecution
	+ publishInteractionClass
	+ publishObjectClass
	+ subscribeInteractionClass
	+ subscribeObjectClassAttributes
	+ unsubscribeInteractionClass
	+ unsubscribeObjectClass

Note that the provided code examples are included in the summary to maintain their original context and accuracy.

The text describes various services provided by the RTI (Run-Time Infrastructure) in a High-Level Architecture (HLA) system. These services are invoked at different points during the execution of the system.

1. **RTI Services with NULL Definitions**: These services are not called by application code, so they are never invoked.
	* deleteObjectInstance: Invoked from an object publisher's destructor.
	* localDeleteObjectInstance: Invoked only from DtReflectedObjectList::removeObject(), which is not typically called by applications.
	* registerObjectInstance: Invoked from an object publisher's constructor.
	* requestClassAttributeValue-Update: Invoked from a reflected object list's constructor, if the list's requestClassUpdate flag is true (the default).
	* requestObjectAttributeValue-Update: If DtReflectedEntityList's (or any other reflected object list's) requestObjectUpdate flag is true (the default), then this service is invoked shortly after each reflected object is discovered and created.
	* sendInteraction: Invoked from within DtExerciseConn::send() or sendStamped().
	* sendInteractionWithRegion: Invoked from within DtExerciseConn::send() or sendStamped() if you are using DDM (Data Distribution Management).
	* updateAttributeValues: Invoked from within an object publisher's tick() function, if we judge that data needs to be sent based on update conditions and remote subscriptions and requests.
2. **RTI-initiated Services with Non-NULL Definitions**: These services are called by the RTI itself.
	* VR-Link Response:
		+ startRegistrationForObjectClass: VR-Link maintains information about which object classes are needed by the federation.
		+ stopRegistrationForObjectClass: VR-Link does not maintain information about which object classes are needed by the federation.
		+ turnInteractionsOff: VR-Link does not maintain information about which interaction classes are needed by the federation.
		+ turnInteractionsOn: VR-Link maintains information about which interaction classes are needed by the federation.
		+ discoverObjectInstance: If any reflected object list has registered interest in the object's class or a super class, VR-Link creates a new reflected object and adds it to the list.
		+ provideAttributeValueUpdate: VR-Link notes that the attribute set has been requested. The next time the object's publisher calls its tick() function, the request attribute updates are sent.
		+ receiveInteraction: If any user callbacks have been registered with VR-Link for the received interaction type, those callbacks are invoked.
		+ reflectAttributeValues: The reflected object's state repository is updated based on the contents of the received attribute update.
		+ removeObjectInstance: The reflected object is removed from the reflected object list, and deleted.
		+ turnUpdatesOffForObjectInstance: VR-Link does not maintain information about which attributes are needed by the federation.
		+ turnUpdatesOnForObjectInstance: VR-Link maintains information about which attributes are needed by the federation.

The text also discusses interoperability between HLA 1.3 and IEEE 1516 federates, including restrictions and requirements for using FED or XML files, object names, user-supplied tags, and consistency in FOM (Federation Object Model) format.

The text explains that there are two broad categories of FOM modifications: those that contain only concepts present in VR-Link's top-level API but represented differently, and those that include new concepts not present in VR-Link's API. For the first category, developers can switch between FOMs by modifying the FOM Mapping layer without affecting the top-level API.

For the second category, developers must extend the top-level API by deriving new classes from base state repository, publisher, reflected object, or reflected object list classes to include new concepts, and then create mappings from arbitrary FOM representations of these concepts to the new API extensions.

The text also provides examples of extending VR-Link for FOM agility and explains how to use the VR-Link Code Generator to create new interaction and object classes automatically.

Here is a summary of the key points:

* VR-Link has been designed with FOM agility in mind.
* FOM agility is implemented through a FOM Mapper.
* There are two broad categories of FOM modifications: those that contain only concepts present in VR-Link's top-level API but represented differently, and those that include new concepts not present in VR-Link's API.
* For the first category, developers can switch between FOMs by modifying the FOM Mapping layer without affecting the top-level API.
* For the second category, developers must extend the top-level API and create mappings from arbitrary FOM representations of these concepts to the new API extensions.

The code examples provided in the text are:

* None

The HLA implementations of VR-Link's top-level API require FOM Mapping information to function correctly. This information includes class mappings, attribute and parameter encoding/decoding, and interaction instance mapping.

Class Mappings:
* Publishers need to know which FOM object class to use for locally simulated objects.
* Reflected object lists need to know the set of FOM classes to register discoverObject() callbacks for.
* Interaction instances need to know which FOM class to use when sending interactions.
* Interaction classes need to know which FOM classes to subscribe to.

Attribute and Parameter Encoding/Decoding:
* Publishers need to decide whether each attribute needs to be sent during a call to tick(), and how to encode values from its state repository into outgoing attribute updates.
* Reflected objects need to decode each attribute of a FOM class into its state repository.
* Interaction instances need to encode and decode each parameter.

To obtain this information, top-level objects can either hard-code the mapping or use a central repository called a DtFomMapper. The DtFomMapper is obtained from the DtExerciseConn through DtExerciseConn::fomMapper().

A DtFomMapper contains class mapping information as well as attribute and parameter encoding/decoding information. It provides functions to obtain this information, such as chooseObjectClass(), setObjectClassToChoose(), and setObjectClassChooser(). These functions can be used to configure the FOM Mapper's mappings.

The following sections describe how to set up a FOM Mapper's class mappings:

* Choosing an Object Class to Publish: A DtObjectPublisher asks the FOM Mapper for the name of the FOM object class to use to represent its locally simulated object.
* Mapping a Single FOM Class to a Publisher: Use setObjectClassToChoose() to associate a single FOM class with a publisher.
* Mapping Multiple FOM Classes to a Publisher: Use setObjectClassChooser() to associate a class choosing function with the name of a VR-Link class.

Code examples:

```
fomMapper->setObjectClassToChoose("DtAggregatePublisher", "BaseEntity.AggregateEntity");
```

The FOM (Foundation Object Model) Mapper is responsible for mapping VR-Link classes to FOM classes. There are two types of mappings: object class mapping and interaction class mapping.

**Object Class Mapping**

* The `setObjectClass()` function maps a single FOM class to a VR-Link C++ class.
* The `setObjectClasses()` function maps multiple FOM classes to a VR-Link C++ class.
* A class choosing function can be associated with a VR-Link publisher class name using the `setObjectClassChooser()` function.

**Interaction Class Mapping**

* The `setExConn()` function is called on an interaction (e.g., `DtExerciseConn::send()` and `sendStamped()`) to ask the FOM Mapper for the name of a FOM class to use to represent the interaction.
* A chooser function can be associated with a VR-Link class name using the `setInteractionClassChooser()` function.

**Subscribing to Object Classes**

* A `DtReflectedObjectList` asks the FOM Mapper for the names of the FOM classes to subscribe to and manage, by calling `objectClassNames()`.
* The reflected object list registers discoverObjectInstance() callbacks with lower layers of VR-Link for these classes.

**Subscribing to Interaction Classes**

* When a `DtInteraction` subclass is created, it maps that request to subscriptions to FOM classes.
* The FOM Mapper's `interactionClasses()` member function returns the set of FOM classes to subscribe to.

**Creating Instances of DtInteraction**

* The FOM Mapper uses a `DtInteractionFactory` to manage the mapping between FOM classes and functions that create instances of the appropriate `DtInteraction` subclasses.
* The `createInteraction()` member function is used to create an instance of the appropriate kind of `DtInteraction` subclass.

Here are some code examples:

* `fomMapper->setObjectClass("DtReflectedAggregateList", "BaseEntity.AggregateEntity");`
* `fomMapper->setInteractionClassToChoose("DtFireInteraction", "WeaponFire");`
* `fomMapper->setInteractionClassChooser("DtFireInteraction", myChooser);`
* `fomMapper()->interactionFactory()->addCreator("WeaponFire", DtFireInteraction::create);`

The chapter discusses attribute and parameter encoding and decoding for VR-Link's FOM Mapping functionality. A DtFomMapper contains information about how to encode and decode individual attributes and parameters, which are used to convert between RTI messages in FOM representation and VR-Link's DtStateRepositories and DtInteractions.

Encoders and decoders are tables of encoding and decoding functions, one for each attribute or parameter. Encoder factories and decoder factories are tables of encoders and decoders, one table for each object or interaction class. A DtFomMapper has an encoder factory and a decoder factory for both objects and interactions.

The chapter provides examples of encoder and decoder classes:

* DtHlaStateEncoder (hlaStateEncoder.h)
* DtHlaStateDecoder (hlaStateDecoder.h)
* DtInteractionEncoder (interactionEncoder.h)
* DtInteractionDecoder (interactionDecoder.h)

These classes implement an efficient, table-driven approach to attribute encoding and decoding. You can subclass encoders and decoders and override the encode() and decode() functions if needed.

The chapter also discusses how to add new FOM classes by creating new encoders and decoders and adding them to the factories' tables. Additionally, it provides information on how to use encoder and decoder factories to register encoding, decoding, and checking functions for a particular attribute or parameter with an encoder or decoder.

Code examples:

* `addEncoder()`
* `addDecoder()`
* `addChecker()`
* `encode()`
* `decode()`

The text describes the form and function of encoding, decoding, and checking functions in VR-Link.

**Decoding Interactions**

* The `DtInteractionDecoder::decode()` function takes an RTI representation of an interaction message (PHVPS) and a pointer to a `DtInteraction` object.
* It goes through the parameters in the PHVPS and calls the parameter decoding function associated with each parameter.
* An example decoding function for the "RateOfFire" attribute is shown:
```c
void decodeRateOfFire(DtFireInteraction* inter, const RTI::ParameterHandleValuePairSet& pvlist, int index)
{
   RTI::ULong length = 0; 
   DtNetU16* netVal = (DtNetU16*) params.getValuePointer(index, length);
   int nativeVal = (DtU16) *netVal;
   inter->setRate(nativeVal);
}
```
**Decoding Object State Updates**

* The `DtHlaStateDecoder::decode()` function takes a `DtStateMsg` and a pointer to the `DtStateRepository`.
* It walks the list of attributes in the message and calls the attribute decoding function associated with each.
* An example decoding function for an attribute is shown:
```c
void decodePosition(DtEntityStateRepository* stateRep, const RTI::AttributeHandleValuePairSet& attrs, int index)
{
   RTI::ULong length = 0;
   DtNet64Vector* netVal = (DtNet64Vector*) 
      attrs.getValuePointer(index, length);
   stateRep->setLocation((DtVector) *netVal);
}
```
**Encoding Interactions**

* The `DtInteractionEncoder::encode()` function takes a `DtInteraction` instance and a PHVPS to fill out with the FOM representation of this data.
* It calls the encoding function registered for each parameter in the interaction class.
* An example encoding function is shown:
```c
void encodeRateOfFire(const DtFireInteraction& inter, RTI::ParameterHandleValuePairSet* params, RTI::ParameterHandle paramHandle)
{
   DtNetU16 netVal = (DtNetU16) inter.rate();
   params->add(paramHandle, (char*) &netVal, sizeof(DtNetU16));
}
```
**Encoding Objects**

* The `DtHlaStateEncoder` contains tables of encoding functions and checking functions.
* It determines which attributes need to be sent based on the current state of the object and its previous update.
* An example encoding function is shown:
```c
void encodePosition(DtEntityStateRepository* stateRep, const RTI::AttributeHandleValuePairSet& attrs, int index)
{
   // ...
}
```
Note that some details have been omitted for brevity, but all code examples and core information are preserved.

1. `encodePosition`: This function takes three arguments: a state repository, an attribute handle, and an AHVPS to encode into. It encodes the current location of an object into the AHVPS.

2. `needDamageState`: This is an example of a checker function used for the DamageState attribute of the PhysicalEntity RPR FOM class. It returns true if the value has changed since it was last sent.

The text also describes the use of encoder and decoder factories in the FOM Mapper to create instances of encoders and decoders for specific FOM classes. These factories are:

* `DtStateDecoderFactory`
* `DtStateEncoderFactory`
* `DtInteractionDecoderFactory`
* `DtInteractionEncoderFactory`

These factories have member functions such as `addEncoder()`, `addDecoder()`, `createEncoder()`, and `createDecoder()` to associate encoders and decoders with FOM classes. They also have `encoder()` and `decoder()` functions that return pointers to the encoder or decoder registered for a particular FOM class.

The text provides examples of how to use these factories to register custom encoding, decoding, and checking functions for specific FOM classes. It also explains how to replace the default factories used by a FOM Mapper with custom ones.

When constructing a `DtExerciseConn`, you must choose a FOM Mapper for it to use. You can do this in one of several ways:

1. Pass a `DtFomMapper` instance to the `DtExerciseConn` constructor.
2. Pass the name of a shared library containing a function that creates the desired FOM Mapper to the `DtExerciseConn` constructor.
3. Set the fallback FOM Mapper creation function using `DtExerciseConn`'s static `setFomMapperCreator()` function.
4. Allow `DtExerciseConn` to create an empty FOM Mapper and configure it after the constructor returns.

The text provides examples of how to use each method, including:

* Passing a `DtFomMapper` instance: `MyFomMapper mapper(); DtExerciseConn("VR-Link", "MyAppName", &mapper);`
* Passing the name of a shared library: `DtExerciseConn(const char* execName, const char* federateName, const char* dsoName, ...);`
* Setting the fallback FOM Mapper creation function: `DtExerciseConn::setFomMapperCreator()`

A `DtEmptyFomMapper` is a clean slate that contains no mappings between VR-Link classes and FOM classes.

After constructing a `DtExerciseConn`, you can configure a `DtFomMapper` using its mutator functions. You can add extra mappings to a `DtFomMapper` or start with the default `DtEmptyFomMapper`.

VR-Link contains built-in support for the RPR FOM, which uses a class called `DtRprFomMapper`. The constructor of `DtRprFomMapper` takes an optional version argument that indicates which version of the RPR FOM you want to use.

To reduce executable size, you can use an alternate FOM Mapper called `DtSimpleRprFomMapper`, which has mappings for only a subset of the RPR FOM.

You can also derive your own `DtFomMapper` by creating a subclass of `DtFomMapper`. This allows you to group your configuration code in one place. When deriving from `DtFomMapper`, it is recommended to derive from `DtEmptyFomMapper` instead, as it initializes all factories and lists for you.

In your derived `DtFomMappers`, the constructor should be empty, and most initialization occurs within the virtual `init()` function. The `init()` function is called by the `DtExerciseConn` constructor after reading the FED file.

VR-Link includes examples of how to create FOM Mappers and extend the top-level API to work with new FOM concepts. These examples are in several subdirectories of ./examples, including `myFomMap` and `addAttr`.

Here is an example code snippet:
```
DtExerciseConn conn("VR-Link", "MyAppName", new DtRprFomMapper(2.0017));
```

The text discusses how to extend VR-Link's API to work with different FOMs (Federated Object Models) using the VR-Link Code Generator. The generator produces C++ code, along with a project file or Makefile, based on a FOM definition file (OMT or XML). This generated code can be used to build a dynamic library that can then be built into application code.

The text also provides examples of how to add new interaction or object classes to VR-Link's API, including extending VR-Link's encoder and decoder classes. The testInter and testObj examples demonstrate this process, while the testSimpInter example shows an alternative method that does not use VR-Link's encoder and decoder classes.

The text notes that the VR-Link Code Generator has limitations and may not be able to fully generate code for complex FOMs. In such cases, minor hand editing may be required. MAK (the company behind VR-Link) is committed to improving the Code Generator and provides support for customers who encounter issues with their FOMs.

Here are the examples mentioned in the text:

* testInter
* testObj
* testSimpInter

Note that the text does not provide a walk-through of the testSimpInter example, but comments in the source files can be used to understand how it works.

**Starting the VR-Link Code Generator**

The VR-Link Code Generator can be started from the command line, script, batch file, or Windows Start menu. The command-line syntax is:
```
./bin/vrlcodegenerator [-p <string>] [-I <string>] [-P <string>] [-F <string>] [-O <string>] [-A] [-G] [--] [-v] [-h]
```
Where:

* `-p` specifies a prefix for generated class names
* `-I` specifies the include directory for generated code
* `-P` specifies the project file
* `-F` specifies a FOM definition file (accepted multiple times)
* `-O` specifies the output directory for generated code
* `-A` generates all objects in the FOM definition
* `-G` performs file generation without opening the GUI
* `--` ignores the rest of the labeled arguments following this flag
* `-v` displays version information and exits
* `-h` displays usage information and exits

**The VR-Link Code Generator Window**

The VR-Link Code Generator window has two panes: Objects and interactions contained in the FOM definition file are listed in the left pane, while objects and interactions for which code will be generated are listed in the right pane.

**Code Generator Projects**

A project is a context in which you work with the Code Generator. You can create, load, and save projects using the following methods:

* Create a new project: Choose File -> New Project or click the New Project button
* Load a project: Choose File -> Load Project or click the Load Project button
* Save a project: Choose File -> Save Project or click the Save Project button

**Using the Code Generator**

To use the Code Generator, you need to:

1. **Load a FOM Definition File**: Choose File -> Import FOM and select an XML or OMT file.
2. **Select the Objects and Interactions to Generate**: Select objects and interactions using one of the following methods:
	* Click on a list item
	* Shift-click to select a series of contiguous items
	* Ctrl-click to select multiple non-contiguous items
	* Choose Edit -> Select All
3. **Removing Classes from the Objects to Generate List**: Select a class in the list and click the left-pointing arrow.
4. **Customizing Encoders and Decoders**: The Code Generator lets you customize encoders and decoders for object attributes and interaction parameters before generating code.

Note that this summary only includes the text provided, without making any assumptions or adding any additional information.

To customize an object or interaction class's encoders and decoders:

1. Double-click on the class in the Objects/Interactions to Generate pane, or right-click and select Customize.
2. The Customize Encoders and Decoders window opens, listing the attributes for the object or interaction.
3. Select the attribute you want to edit, and edit the function body as desired on both the Encoding and Decoding tabs.
4. Click Save Changes.

Note: When editing an encoder, it's recommended to make corresponding changes to the decoder (and vice versa).

Additionally, there are several code generation preferences that can be set:

* Namespace: Specify a namespace to avoid name conflicts within VR-Link or application code.
* Create Include Directory: Place header files in a specified directory relative to the output directory.
* Prefix Classnames: Add a prefix to class names to prevent conflicts with existing VR-Link classes.
* 64-bit Linux Makefile: Generate a makefile for building the generated code on Linux for 64-bit computers.
* Generate Examples: Create simple talk and listen examples that demonstrate how an object or interaction is used.
* Map RTIObjectId to DtGlobalObjectDesignator: Map the RTIObjectId structure to VR-Link's internal DtGlobalObjectDesignator.
* Generate #error for undecodable attributes: Insert #error statements into output code if it cannot figure out how to generate correct code.
* Include HLA Standard MIM: Include Management Information Model (MIM) FOM elements that are part of the HLA Evolved standard even if they are not found in the loaded FOM.
* Generate DIS PDUs: Produce custom DIS PDUs and a protocol-independent API (experimental feature).

These preferences can be set in the ./data/config/codeGenConfig.xml configuration file, the GUI, or both.

The VR-Link Code Generator produces an output file containing the internal state of the parse tree after parsing the FOM (Federal Office Model). This output can be sent to MAK when a problem arises that requires support.

To configure code generation preferences, go to Configuration > Preferences. In this dialog box, you can specify a namespace and other options by selecting relevant checkboxes and clicking OK.

To specify an output directory, go to Configuration > Choose Output Directory and select the desired folder.

To generate code, choose Build > Generate or click the Generate button.

The generated code includes:

* Enumerations: An enumerations file is generated from enumerated data types in the OMT or XML file. The file name is FomNameEnum.h.
* Data Types: Files are generated to implement complex data types and their network types. These files are named FomNameTypes.h or .cxx, and FomNameNetTypes.h or .cxx.
* Objects and Interactions: For each object, a DtStateRepository, DtObjectPublisher, DtReflectedObject, DtReflected-ObjectList, DtHlaStateEncoder, and DtHlaStateDecoder is created. For each interaction, a DtInteraction, DtInteractionEncoder, and DtInteractionDecoder is created.
* Project Files and Makefiles: Windows project files and UNIX Makefiles are generated with the code.

There are some limitations to the code generator:

* If a complex data type contains more than one component of dynamic cardinality, the code generator cannot generate code to decode this.
* If an attribute or complex data type contains a component of variable size data, which is also of variable size, the code generator cannot generate code.
* If the complex data type contains a variant record, the code generator will try to write the code that encodes or decodes it.

The DIS Specific Interface section of VR-Link's protocol-independent interface provides functionality for simulations to interact with a DIS exercise. This section describes how to work with Protocol Data Units (PDUs), which are used to send data between applications.

**8.1 Working with PDUs**

* Sending PDUs: Use the `DtExerciseConn::send()` or `DtExerciseConn::sendStamped()` functions to send PDUs.
	+ Example:
```c
DtExerciseConn exchange(...);
...
// Create a DtTransmitterPdu
DtTransmitterPdu pdu;
// Fill the PDU with data
pdu.setEntityId(DtEntityIdentifier(1,2,3));
pdu.setRadioId(4);
pdu.setTransmitState(DtOn);
...
// Send to the exercise
exConn.sendStamped(pdu);
```
* Receiving PDUs: Handle incoming PDUs through callbacks.
	+ Example:
```c
DtExerciseConn exConn;
...
// Register a callback function with VR-Link using a PDU class's static addCallback() function
DtTransmitterPdu::addCallback(myCallbackFunction);
...

void myCallbackFunction(DtTransmitterPdu* pdu) {
    // Examine the fields of the PDU using inspector functions
    int entityId = pdu->getEntityId();
    int radioId = pdu->getRadioId();
    ...
}
```
**8.1.2 Receiving PDUs**

* The process for receiving PDUs is virtually identical to that described in 4.3.2 Receiving Interactions.
* Note: Applications usually send interaction PDUs as described in this section, and use `DtEntityPublisher` to manage the sending of entity state PDUs.

**8.1.2.1 More Control Over Receiving PDUs**

* Most applications use VR-Link's callback mechanism to handle incoming PDUs, leaving the job of actually reading the PDUs and dispatching them to the callbacks to `DtExerciseConn::drainInput()`.
* However, to give you more flexibility and control over reading PDUs from the network, `DtExerciseConn` provides access to the functions used by `drainInput()`.

The rest of the section describes how to work with PDU headers, inspecting and setting data in a PDU header, getting a PDU's network representation, constructing a PDU from a network representation, using external buffers in a PDU class, copying PDUs, and getting an object ID.

The `readAndProcess()` function reads a single PDU from the network using `netRead()` and then passes it to `processPdu()`, which invokes all callbacks. Application code can use these functions instead of calling `drainInput()`.

`netRead()` tries to read a packet from the network, constructs an instance of a PDU class from the network representation, and returns it. However, successive calls to `netRead()` return PDUs that use the same buffer for their network representations, so applications must delete the returned PDU before making another call to `netRead()`. Using `readAndProcess()` or `drainInput()` ensures that each PDU is deleted before the next call to `netRead()`.

The optional return code argument to `netRead()` is a pointer to a return code set depending on the results of the operation. If a PDU was successfully read, the return code is set to `DtNET_READ_SUCCESS`. If there are no PDUs to be read, the return code is set to `DtNET_READ_NO_PACKETS` and NULL is returned.

Here is an example of using `netRead()`:
```c
int retCode;
while (1)
{
   DtPdu* pdu = exConn.netRead(&retCode);
   if (retCode == DtNET_READ_SUCCESS)
   {
      // do something with the PDU
      ...
      delete pdu;
   }
}
```
The `readUntil()` function is similar to `drainInput()` but returns when a predicate function returns true or after a timeout, whichever happens first. The predicate function has the following signature:
```c
int predicate(DtPdu *pdu, void *arg);
```
Here is an example of using `readUntil()`:
```c
DtPduKind readUntil(DtPredicate predicate, void* arg, 
                     DtTime timeout, DtTime sleepTime);
```
The `DtPdu` class has functions to inspect and set data in a DIS PDU's header. The following member functions return the values of their respective fields:
```c
protocolVersion()
exerciseId()
kind()
protocolFamily()
length()
```
Other fields of the various PDUs are accessed through member functions of the classes derived from `DtPdu`.

The base class `DtPdu` has two constructors: a blank PDU constructor and a from-network-representation constructor.

**Blank PDU Constructor**

* Constructs a minimal, blank PDU with default values for header information.
* The protocol version is set to the value of `DtProtocolVersionToSend`.
* The PDU kind and protocol family depend on the derived PDU class.
* The length is the PDU's minimal length.
* The exerciseId and time stamp are zero.

Example:
```c
DtFirePdu pdu();
```
or:
```c
DtFirePdu pdu;
```

**From-Network-Representation Constructor**

* Takes a pointer to a network representation of a PDU as an argument.
* Constructs a `DtPdu` object representing this PDU.
* The from-network-representation constructor is typically used by a `DtPduFactory`.

Example:
```c
DtFirePdu pdu(new DtNetFirePdu());
```

**Important Notes**

* The `packet()` method returns a pointer to the network representation of the PDU, which should not be modified unless necessary.
* The `status()` member function can be used to determine whether a `DtPdu` represents valid data after construction.

I hope this summary helps! Let me know if you have any further questions.

The status of a DtPdu constructor is not verified, so a status of DtSTATUS_OK does not necessarily mean that the PDU is valid. However, a status other than DtSTATUS_OK means that the PDU is not valid.

To construct a DtPdu object from a network representation of a PDU whose type you do not know, use the DtPduFactory::createPdu() member function. This function checks the PDU kind in the packet and passes it to the right creator function, which returns a pointer to the newly constructed object.

You can get a pointer to the PDU factory used by a DtExerciseConn using the pduFactory() method. To construct a PDU class object from a network representation of a PDU, use the following code:

```c
DtExerciseConn exConn(...);
...
char *buffer = ...;
DtPduFactory* fact = exConn.pduFactory();
DtPdu* pdu = fact->createPdu((DtNetPacket*) buffer);
```

The createPdu() function rejects packets with a protocol version less than DtProtocolVersionToRecvMin or greater than DtProtocolVersionToRecvMax.

Each PDU class has a static member function called create(), which can serve as that PDU's creator function. To register a creator function for a PDU kind, use the addCreator() method:

```c
DtExerciseConn exConn(...);
...
exConn.pduFactory()->addCreator(DtPduKind(10), DtEntityStatePdu::create);
```

A NULL creator function can be added to indicate that there is no PDU class for a particular kind and DtUnknownPdu should be used instead.

Each DtPdu object stores a network representation of the PDU it represents. You can specify an external buffer for storage of this network representation by passing a DtBufferPtr as an argument to the PDU class constructor:

```c
char buffer[144];
DtEntityStatePdu pdu(DtBufferPtr(buffer));
```

This is useful when you want to avoid copying data into a buffer internal to the DtPdu.

When passing a pointer to external memory to the `DtPdu` constructor, consider the following:

* Ensure that the buffer is large enough to accommodate the largest network representation.
* Ensure that the lifetime of the buffer extends for the lifetime of the `DtPdu`.
* Modifying the buffer will result in undefined behavior when using mutator or inspector functions.

The `DtPdu` class has a copy constructor and assignment operator overloaded, allowing you to copy data as follows:

```cpp
DtPdu pdu1, pdu2;
pdu1 = pdu2;
```

To ensure correct copying of data from one PDU to another, use the network representation of the PDU:

```cpp
DtFirePdu pdu1;
DtFirePdu pdu2((const DtNetFirePdu*)pdu1.netRep());
```

The `DtPdu` constructor has an optional buffer argument. To copy a `DtPdu` using a buffer, do the following:

```cpp
DtPdu pdu1;
DtPdu pdu2(pdu1, buffer);
```

To get an object ID, use the `nextId()` function of the `DtExerciseConn` class.

The text also discusses working with non-standard PDUs, including using `DtUnknownPdu` and deriving classes from `DtPdu`. To work with user-defined PDUs, you can:

* Use `DtUnknownPdu` to represent your type of PDU
* Derive a class from `DtPdu`

To send a PDU using the `DtUnknownPdu` class, fill a buffer with the exact bytes you want to send on the network and pass it to the `from-network-representation` constructor.

The text discusses how to create and use custom PDUs in VR-Link, a distributed simulation system. It provides an example of creating a Test PDU with two fields called `a` and `b`, and choosing PDU kind number 220 to represent this PDU.

To send the PDU, an instance of the structure is created and filled with data, then a `DtUnknownPdu` is created from the network representation. The PDU is sent using the `exConn.sendStamped()` function.

On the receiving side, the `DtExerciseConn` class is used to register callbacks for specific PDU kinds. In this case, a callback function is registered for PDU kind 220.

The text also discusses how to derive classes from `DtPdu`, which allows sending user-defined PDUs using the `send()` and `sendStamped()` functions of the `DtExerciseConn` class.

Finally, the text provides an overview of configuring a connection to the DIS network using the `DtExerciseConn` class. This includes creating constructors for the class, configuring a `DtDisSocket`, using asynchronous IO, subscribing to multicast addresses, filtering PDUs, and sending and receiving packets using `DtInetSocket`.

Here is the code example provided in the text:

```c
// Define the structure of your network representation
typedef struct NetTestPdu
{
   DtNetPduHeader header;
   DtNetInt32 a;
   DtNetInt32 b;
} NetTestPdu;

// Create an instance of the structure and fill in the net 
// representation
NetTestPdu aNetPdu;
aNetPdu.header.version = 5;
aNetPdu.header.DtExercise = 1;
aNetPdu.header.DtLength = sizeof(NetTestPdu);
aNetPdu.header.DtKind = 220;

...
aNetPdu.a = 10;
aNetPdu.b = 11;

// Create a DtUnknownPdu from this network representation
DtUnknownPdu pdu((DtNetPduHeader*) &aNetPdu);

// Send the PDU as you normally would
exConn.sendStamped(pdu);
```

And here is an example of deriving a class from `DtPdu`:

```c
class TestPdu : public DtPdu {
public:
   int a;
   int b;
   float c;

   // Constructor for TestPdu
   TestPdu() {}

   // Destructor for TestPdu
   ~TestPdu() {}
};
```

Note that the text does not provide a complete implementation of the `TestPdu` class, but rather an outline of its structure and methods.

The `DtExerciseConn` class receives unicast or broadcast packets destined for the computer on a specified port, and by default sends packets to the broadcast address of the computer's primary network interface.

There are three constructors for `DtExerciseConn`:

1. The first constructor takes four arguments: a port number, an exercise ID, a site ID, and an application number.
2. The second constructor takes five arguments: the same as the first constructor plus a destination address. This address is used as the default IP address to which outgoing packets are sent.
3. The third constructor takes a pointer to a `DtInetSocket`. This gives full control of how the socket is created and allows for derived types of `DtInetSocket` to be passed in.

The `DtDisSocket` class is a subclass of `DtInetSocket` that can be used with `DtExerciseConn`. It contains features for sending and receiving DIS PDU's. The constructor for `DtDisSocket` takes several parameters, including the destination address and port, local port, interface, socket flags, and a flag to determine whether to open the socket immediately.

The `DtExerciseConn` class also supports asynchronous IO for DIS. This can be enabled by passing a socket with asynchronous IO enabled to the constructor or by setting the `useAsynchIO()` member function to true.

Here are some code examples:

* Creating a `DtExerciseConn` object with a destination address: `DtExerciseConn(3000, DtInetAddr("207.86.232.1"));`
* Creating a `DtDisSocket` object: `DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"), 3300); DtInetDevice deviceToUse(DtInetAddr("192.168.0.1")); DtDisSocket* sock = new DtDisSocket(endpoint, 0, deviceToUse);`
* Creating a `DtExerciseConn` object with asynchronous IO enabled: `DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"), 3300); DtDisSocket *netSocket = new DtDisSocket(endpoint, 0, 0, (DtDefaultSockOpts | DtAsyncReadWrite)); DtExerciseConn  *exConn = new DtExerciseConn(netSocket, exerciseId, siteId, applicationNum );`

The text discusses various features of the VR-Link application initializer (`DtVrlApplicationInitializer`) and its connection object (`DtExerciseConn`). The main points are:

1. Asynchronous IO can be enabled using `setUseAsynchIO(true)` to reduce dropped packets, but it is not necessarily faster.
2. Multicast addresses can be subscribed to using `addInterestInMcastAddr()` and unsubscribed from using `subtractInterestInMcastAddr()`. Note that not all platforms support multicast.
3. To send to a particular multicast address, include the address as the `destAddr` argument in `send()` or `sendStamped()`.
4. Filtering PDUs can be enabled using `disableFiltering()` and disabled using `enableFiltering()`. By default, packets with unexpected protocol versions and exercise IDs are filtered out.
5. Bundling of multiple PDUs into a single network packet can be turned on using `setBundling(true)` and off using `setBundling(false)`. The maximum bundle size can be set using the first parameter of `setBundling()`.
6. Unbundling is enabled by default, but can be turned on or off using `setUnbundling(0)` or `setUnbundling(1)`.

The code examples provided are:

* `appInit.setUseAsynchIO(true);`
* `DtExerciseConn exConn(initializer);`
* `disSocket.setBundling(1464, true, 0, 0, 0, 0);` (to turn on bundling with a max size of 1464 bytes)
* `disSocket.setBundling(0, false, 0, 0, 0, 0);` (to turn off bundling)

Note that the text assumes no prior knowledge of VR-Link or its components, and provides detailed explanations of each feature.

**Unbundling**

When receiving packets with more than one PDU, successive calls to the receive function return successive PDUs from the packet. If unbundling is disabled, but a bundled packet is received, all but the first PDU in the packet is ignored.

**Sending Packets**

To send packets using DtInetSocket classes, use either the `send()` or `sendTo()` member function. The socket's `send()` member function returns the number of bytes sent, or -1 if the packets cannot be sent. If -1 is returned, use `getLastError()` or `getLastErrorString()` to query which error was encountered.

**Receiving Packets**

To receive packets using DtInetSocket classes, use the `recv()` member function. The return status can be checked to determine the status of any of the receive calls. If there was an error, `DtInetSockRcv_ERROR` is returned; if nothing was read, `DtInetSockRcv_NO_PACKET` is returned.

**Intercepting Incoming Entity State PDUs**

To intercept incoming entity state PDUs:

* Register a callback on entity state PDUs using `DtReflectedEntity::processEntityState()`.
* Override `DtReflectedEntity::processEntityState()` to update the reflected entity list's DtEntityStateRepository based on the contents of the PDU.

**Setting Different Heartbeats in DIS 7**

To set different heartbeats for entities:

* Use `setStationaryDfltTimeThreshold()` to set the heartbeat for non-moving entities.
* Use `setEntityTypeDfltTimeThreshold()` to set the heartbeat by entity type.
* Use `setClassDfltTimeThreshold()` to set the heartbeat by class type.

Example code:
```c
DtEntityPublisher::setStationaryDfltTimeThreshold(20.0);
DtEntityPublisher::setEntityTypeDfltTimeThreshold(DtPlatform, DtPlatformDomainAir, 1.0);
DtIffPublisher::setClassDfltTimeThreshold(10.0);
DtEntityPublisher::setClassDfltTimeThreshold(5.0);
```
Note that you can still set a single heartbeat value for every DIS object using `setDfltTimeThreshold()`.

**Writing Applications Using the C# API**

The chapter explains how to develop applications using the VR-Link C# library, referencing the F-18 example to illustrate concepts.

**Build Requirements**

VR-Link for C# is built with Microsoft Visual Studio, using both 32-bit and 64-bit compilers. It is also built on the .NET Framework.

**Adding the VR-Link for C#.dll to Your Project**

To use VR-Link for C#, add `vrLinkSharp.dll` as a reference to your project:

1. Right-click on your project and select Add Reference.
2. Select the Browse tab and navigate to the ./bin directory inside the root VR-Link install folder.
3. Select `vrLinkSharp.dll` from the list.

Add the following using statement to access the C# library:
```csharp
using makVrl;
```

**Initializing an Exercise Connection**

To create an exercise connection, use the `ExerciseConnectionInitializer` class:

1. Define a connection type (e.g., `DIS`, `HLA13`, etc.) using the `enum ConnectionType`.
2. Create an instance of the corresponding initializer class (e.g., `DisExerciseConnectionInitializer`).
3. Initialize an `ExerciseConnection` object with the initializer.

Example:
```csharp
DisExerciseConnectionInitializer initializer = new DisExerciseConnectionInitializer();
ExerciseConnection exConn = new ExerciseConnection(initializer);
```

**Using the Application Initializer Class**

As an alternative to initializing an exercise connection, use the `ApplicationInitializer` class:

1. Create an instance of the `ApplicationInitializer` class.
2. Define a connection type using command-line arguments (e.g., `-C HLA13`).

Example:
```csharp
Talk-Sharp.exe -C HLA13
```

**Publishing Objects**

VR-Link for C# supplies publishers for objects that it defines:

1. Define and initialize a publisher of the right type.
2. Edit the `EntityStateRepository` (ESR) to modify the values sent by the publisher.

Example:
```csharp
EntityPublisher myEntityPub;
myEntityPub = new EntityPublisher(myExConn);

EntityStateRepository myESR;
myESR = myEntityPub.esr;

// Modify ESR information in a tick() function
```

Note: The text assumes that you know the C# language and provides example code to illustrate concepts.

The text discusses various aspects of VR-Link for C#, including simulation tick functions, reflected objects, callbacks, interactions, and plug-ins.

**Simulation Tick Functions**

A simulation tick function (`simTick`) updates the position of an entity by adding its velocity and acceleration to its current position. The function also converts the position to a correct format using a coordinate transformation and calls the publisher tick function.

**Reflected Objects**

A reflected object is a class used to store information about an object discovered on the exercise connection. A reflected object list keeps track of multiple reflected objects and handles callbacks associated with discovering, updating, and deleting objects. The `ReflectedEntityList` class is used to store multiple `ReflectedEntity` types.

**Callbacks and Interactions**

Interactions are handled differently than objects. Typically, interactions are created and sent one time, then received and reacted to appropriately. An example of such interaction is the FireMessage. To send a fire interaction, create it and send it with the exercise connection using the `sendMessage` method. To receive a FireMessage, register a callback function using the `addMessageHandler` method.

**Plug-ins**

VR-Link programmers can extend the C# API by creating plug-ins. The text provides an overview of how to develop plug-ins, including build requirements, architectural overview, managed interface class, loading plug-ins, initializing connections, and managed interface concepts.

Here are some code examples:

* `simTick` function:
```csharp
public void simTick(double dt)
{
    ...
    myPos[i] += (myVel[i] + 0.5 * myAccel[i] * dt) * dt;
    
    ...
    myESR.worldPosition = myCoordTrans.coordTrans(myPos);
    ...
    myEntityPub.tick(dt);
}
```
* `ReflectedEntityList` creation:
```csharp
ReflectedEntityList rel = new ReflectedEntityList(exConn);
```
* `drainInput` method:
```csharp
exConn.drainInput(-1.0);
```
* `nearestEntity` function:
```csharp
static ReflectedEntity nearestEntity(string myObjId, Vector3d geocPos, ReflectedEntityList rel)
{
    ...
}
```
* `FireMessage` creation and sending:
```csharp
myFire = new FireMessage();
...
myFire.worldPosition = ESR.worldPosition;
myFire.velocity = ESR.worldVelocity;
...
myExConn.sendMessage(myFire);
```
* `addMessageHandler` method:
```csharp
myExConn.addMessageHandler(FireMessage.theName, new MessageDelegate(processFireMessage));
```
* `processFireMessage` function:
```csharp
internal void processFireMessage(Message m)
{
    FireMessage fm = m as FireMessage;
    Console.WriteLine("Fire Message received from entity " + fm.firingId + " targeting entity " + fm.targetId + ". ");
}
```
Note that I did not make any assumptions not within the text and kept all code examples intact.

The ManagedInterfaceCS library provides C# bindings for accessing the power of VR-Link and ManagedInterface directly from C#. It communicates with the underlying C++ libraries through a simple message-passing API.

The ManagedInterface class is a singleton that provides a centralized location to register message decoders, strategies, and resources used during execution. Plug-ins can be loaded by exporting a function with the name `initManagedInterfaceModule` and signature `(DtManagedInterface* gl)`.

When initializing connections, VR-Link C# loads protocol-specific strategies at runtime based on user requests. A connection initialization procedure is needed to ensure that all strategies are initialized correctly. This involves multiple passes of initialization to handle dependencies between strategies.

The ManagedInterface library includes several concepts:

1. Strategies: modular components that process object state updates and interactions from VR-Link and create messages for the C# application.
2. Resources: shared data structures and classes used by different strategies, managed by a resource manager accessible from the ManagedInterface class.
3. Delegates: not mentioned in this text.

Some examples of strategies included with VR-Link C# are:

* Initialization
* Entity State
* Fire Interaction
* Detonate Interaction
* Start/Stop
* Transmitters
* Set Data
* Signal Interaction
* Laser Designator
* Action Response/Request

These strategies can be extended or replaced through the use of plug-ins.

The provided text discusses various utility functions for accessing commonly used objects in ManagedInterface, including finding and setting resources such as exercise connections, reflected entities, entity publishers, clocks, and reflected entity lists.

It also explains delegates, which are C++ classes that wrap a function to callback at a later time. These are used for message handlers registered with ManagedInterface.

The text then delves into the topic of messages in VR-Link, which communicates with VR-Link C# through serialized byte buffers sent via a simple API. Messages can serialize and deserialize themselves, and adding new messages requires creating both C# and C++ implementations using code generators and a message definition language written in Lua.

The message definition language is used to declare messages, including their layout and configuration. The text provides examples of message definitions, including enums, structures, and attributes. Enums are defined with a name and a list of enumerated values within double brackets [[ ]]. Structures can be defined in the structs table and follow the same rules as the attributes table.

The text also explains how to declare enum and struct attributes within a message definition. Message attributes define the message layout and can be simple data types, enums, structures, or lists of these types. The code examples provided demonstrate how to declare enum and struct attributes within a message definition.

Finally, the text discusses the code generator, which generates C++ and C# source code to encode and decode message data once the message definition is written.

The text describes two command-line tools for generating message source code: one for C# and another for C++. The C# code generator has parameters -i (input file path) and -o (output directory), while the C++ code generator has parameters -i, -h (header file output directory), and -s (source file output directory).

The text then describes an example of a Laser Designator plug-in for DIS and HLA. The plug-in uses the C++ VR-Link toolkit and the VR-Link C# library.

The project files are broken down into five projects: one for protocol-independent message representations, four for protocol-specific projects, and one for the strategy factory. The code examples show how to load laser designator messages into the message factory, register creators for these messages, and add strategies to the strategy factory.

The Laser Designator plug-in loads the laser designator messages into the message factory in its initManagedInterfaceModule() function. The protocol-specific laser designator plug-ins load their specific strategy into the strategy factory and register with the initialization strategy to be loaded during connection.

The code examples also show how to create a laser designator strategy, which registers interest in laser object messages with ManagedInterface. The strategy initializes by finding the exercise connection shared resource, creating a reflected laser designator list, and installing callbacks on it to listen for laser designators coming from the DIS/HLA network. It also creates a laser designator publisher list to hold publishers that mirror laser designators being controlled in VR-Link C#.

The tick function of the Laser Designator strategy updates any laser designator publishers created to mirror laser designators from VR-Link C# to the DIS/HLA network.

Here is a summary of the key points:

1. Define a .lua file that outputs a state message, a discovery message, and a removed message.
2. Create a state repository class for laser designators by deriving from the VR-Link C# library class StateRepository.
3. Define a reflected object class that contains the state repository and provides wrappers around some of its functions.
4. Create a reflected object list that registers callbacks for discovery, update, and removed with the exercise connection.

The code examples provided include:

* A MESSAGE definition in .lua file
* A state repository class `laserDesignatorStateRepository`
* A reflected object class `ReflectedLaserDesignator`
* A reflected object list class `ReflectedLaserDesignatorList` that registers callbacks for discovery, update, and removed with the exercise connection.

The code examples are:

```csharp
MESSAGE{
   fileName="laserDesignatorDiscovery";
   className="LaserDesignatorDiscovery";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="designatorId"};
   }
}

public laserDesignatorStateRepository()
   : base()
{
   setAttribute("entityId", "");
   setAttribute("codeName", CodeName.OTHER);
   setAttribute("targetId", "");
   setAttribute("designatorCode", DesignatorCode.OTHER);
   setAttribute("power", 0.0F);
   setAttribute("wavelength", 0.0F);
   setAttribute("relativeDesignatorSpot", Vector3d.Zero);
   setAttribute("worldDesignatorSpot", Vector3d.Zero);
}

public string entityId
{
  get { return (string)getAttribute("entityId"); }
  set { setAttribute("entityId", value); }
}

internal void update(LaserDesignatorStateMessage sm)
      {
         //this shouldn't change
         entityId = sm.entityId;
         codeName = (makVrl.CodeName)sm.codeName;
         targetId = sm.targetId;
         designatorCode = (makVrl.DesignatorCode)sm.designatorCode;
         power = sm.power;
         wavelength = sm.wavelength;
         relativeDesignatorSpot = sm.relativeDesignatorSpot;
         worldDesignatorSpot = sm.worldDesignatorSpot;
      }

public class ReflectedLaserDesignator
   {
      laserDesignatorStateRepository myLsr = new laserDesignatorStateRepository();
      public ReflectedLaserDesignator(string id)
      {
         myLsr.entityId = id;
      }
      public laserDesignatorStateRepository esr { get { return myLsr; } }
      internal void update(LaserDesignatorStateMessage sm)
      {
         myLsr.update(sm);
      }
   }

public class ReflectedLaserDesignatorList
{
   ExerciseConnection myExConn;
   Dictionary<String, ReflectedLaserDesignator> myUnprocessedLasers = new Dictionary<String, ReflectedLaserDesignator>();
   Dictionary<String, ReflectedLaserDesignator> myLasers = new Dictionary<String, ReflatedLaserDesignator>();
   public ReflectedLaserDesignatorList(ExerciseConnection exConn)
   {
      myExConn = exConn;
      myExConn.addMessageHandler(LaserDesignatorDiscoveryMessage.theName, new MessageDelegate(handleLaserDesignatorDiscoveredMessage));
      myExConn.addMessageHandler(LaserDesignatorRemovedMessage.theName, new MessageDelegate(handleLaserDesignatorRemovedMessage));
      myExConn.addMessageHandler(LaserDesignatorStateMessage.theName, new MessageDelegate(handleLaserDesignatorUpdatedMessage));
   }
```

Note that the code examples are not complete and may require additional implementation to work correctly.

**C# Code Examples**

1. Two callback functions are defined: `handleLaserDesignatorDiscoveredMessage` and `handleLaserDesignatorUpdatedMessage`. These functions handle messages related to laser designators.
2. A `laserDesignatorPublisher` class is created, which contains an exercise connection and a laser state repository. The publisher's tick function sends a LaserDesignatorStateMessage using the exercise connection.
3. A dispose method is defined in the `laserDesignatorPublisher` class, which creates a LaserDesignatorRemovedMessage and sends it with the exercise connection.

**Java API Introduction**

1. The Java API for VR-Link consists of both Java code and native platform-specific code.
2. The Java API is not portable to any Java platform, only platforms supported by VR-Link (C/C++).
3. The Java API has a version of the F-18 example, which illustrates the concepts introduced in this chapter.
4. To run the examples, you need to tell the JVM where the Java code and native libraries are located.

**Code Examples**

The provided C# code examples demonstrate how to handle laser designator messages and publish laser designators using an exercise connection. The Java API introduction provides information on setting up a project, initializing an exercise connection, and publishing objects.

The text provides instructions on how to set up and run VR-Link Java applications. It covers several topics, including:

1. Running example applications: The text shows how to run example applications using the `java` command with various options, such as `-cp`, `--loadPath`, and setting the `CLASSPATH` environment variable.
2. Setting up a project: The text explains that all Java code is contained in a single JAR file, but native code may be loaded differently depending on configuration. It provides instructions for setting up a project with bundled or external native libraries.
3. Exercise connections: The text describes how VR-Link applications connect to an exercise through an exercise connection, which is implemented using the `ExerciseConnection` interface.

The text also includes several code examples and notes on how to set up Eclipse projects. Here are some key points:

* To run example applications, use the `java` command with options such as `-cp`, `--loadPath`, or setting the `CLASSPATH` environment variable.
* To set up a project, add the correct JAR file to your Java classpath and specify the path to native libraries using the `setLoadPath()` method or the `--loadPath` option.
* To use bundled native libraries in an Eclipse project, simply add the JAR file to the build path. To use external native libraries, modify the Run Configurations for the project or call the `setLoadPath()` method in your code.

The text also provides information on how to initialize an exercise connection using the `ExerciseConnectionFactory` class and how to manage resources such as network sockets and managed memory.

**ExerciseConnection**

The `ExerciseConnection` class implements the `AutoCloseable` interface, making it easy to use in try-with-resources statements.

```java
try (ExerciseConnection exConn = ExerciseConnectionFactory.createDefault(initializer)) {
    // Use exConn here...
} catch (Exception e) {
    // Handle exception...
}
```

**ExerciseInitializer**

The `ExerciseInitializer` class contains information necessary to initialize an `ExerciseConnection`. It may also contain additional information for user applications. The `parseCmdLine(String[] args)` method simplifies parsing command line arguments.

```java
@Parameter(names = { "--f18Markings" }, description = "hull markings")
private final String markings;
```

**Threading**

VR-Link for Java shares a single thread with the application, and no extra threads are used for background processing. Each `ExerciseConnection` has a `drainInput()` method that performs background processing and must be called periodically.

```java
exConn.drainInput();
```

**Publishing Objects**

To publish an object to the network, use a `PublisherFactory` obtained from an `ExerciseConnection`, then get an `ObjectPublisher` for a particular kind of object.

```java
PublisherFactory pubFactory = exConn.getPublisherFactory();
ObjectPublisher myEntity = pubFactory.createEntity("myEntityName");
```

**Reflected Objects**

A reflected object is a class used to store information about an object that has been discovered, updated, and deleted by the exercise connection. Each exercise connection tracks all reflected objects in a `ReflectedObjectCollection`.

```java
ReflectedObjectCollection collection = exConn.getReflectedCollection();
```

**Code Examples**

Here are some code examples:

* Using `ExerciseConnection`:
```java
try (ExerciseConnection exConn = ExerciseConnectionFactory.createDefault(initializer)) {
    // Use exConn here...
} catch (Exception e) {
    // Handle exception...
}
```
* Creating a custom `ExerciseInitializer`:
```java
public class F18Init extends ExerciseInitializer {
    @Override
    public void parseCmdLine(String[] args) {
        // Parse command line arguments...
    }
}
```
* Publishing an object to the network:
```java
PublisherFactory pubFactory = exConn.getPublisherFactory();
ObjectPublisher myEntity = pubFactory.createEntity("myEntityName");
myEntity.setWorldPosition(new Vector3d(1524517.05424356, -4464444.01466548, 4278068.90596911));
myEntityPublisher.tick();
```
* Using a time-stepped loop:
```java
double dt = 0.05; // time step in seconds
double simTime = 0.0; // starting simulation time in seconds
while (simTime <= 10.0) {
    exConn.drainInput();
    entity.setWorldPosition(toGeoc.transform(topoPos));
    entityPublisher.tick();
    // Update entity motion...
    simTime += dt;
    Thread.sleep((long) (1000 * dt));
}
```
Note that I kept all code examples and did not make any assumptions not within the text.

1. **Reflected Maps**: A selection criteria defines a test for inclusion in a ReflectedMap, which is a collection of objects that pass the criteria. Once created, the criteria cannot be changed.

Example code:
```java
ReflectedEntityMap rem = new ReflectedEntityMap(exConn);
Iterator<Entity> iter = rem.values().iterator();
while (iter.hasNext()) {
    Entity first = iter.next();
    System.out.println(iter.toString());
}
```

2. **Callbacks and Interactions**: Interactions are handled differently than objects. An example of an interaction is the FireInteraction, which can be sent using the exercise connection.

Example code:
```java
FireInteraction fire = new FireInteraction();
fire.setFiringId(myId);
... set other interaction fields as required ...
exConn.send(fire);

FireInteraction.addListener(exConn, fire -> {
    System.out.print("Fire Interaction from ");
    System.out.println(fire.getFiringId());
});
```

3. **Example and Utility Applications**: VR-Link includes a set of supporting applications that can help with development and troubleshooting.

The text also discusses the f18 program, which simulates a simple HLA or DIS vehicle, and provides command-line options for controlling its behavior.

Note: The provided code examples are in Java, and some may require additional context or setup to run.

The text describes the configuration options for the f18 program, which can be specified using command-line arguments or loaded from a configuration file (f18.mtl). The configuration file sets default parameters such as notify level, dead-reckoning algorithm, initial heading, position, and speed.

Some of the available options include:

* -l file: Loads the specified MTL configuration file.
* -L x,y,z: Specifies the initial position in topographic coordinates.
* -M markings: Specifies the markings.
* -n notify_level: Specifies the notification level for warnings.
* -O lat,long: Specifies the reference latitude and longitude for the topographic coordinate system.
* -r radius: Specifies the turn radius of the f18, in meters. Setting the radius to 0.0 causes the f18 to move in a straight line.
* -s mps: Specifies the initial speed of the f18, in meters per second.

HLA Only Options:

* -f | –fomMapperLib libname: Specifies a FOM Mapper library name.
* –fomMapperInitData data: Specifies FOM Mapper initialization data, if required.
* –rprFomVersion version_number: Specifies the RPR FOM version.

DIS Only Options:

* -A address: Specifies the default destination IP address for outgoing PDUs.
* -I: Use asynchronous IO.
* -P portnum: Specifies the UDP port. Default: 3000.
* –recvBufferSize size: Specifies the receive buffer size.
* –sendBufferSize size: Specifies the send buffer size.
* –siteId ID: Specifies the site ID.
* -S address: Subscribes to the specified multicast addresses.
* –mcastTtl ttl: Specifies the multicast time to live.
* -V version: Specifies the DIS protocol version contained in outgoing PDUs.

The text also describes how to use a modified FOM, which can be achieved by including the definition REVERSE=1 on the make line when building f18.

Additionally, the text provides information on firing munitions, reactions to detonate messages, absolute timestamping, and using a modified FOM.

The text describes various tools and examples for using VR-Link from different languages and platforms.

* The simpleC example demonstrates how to use VR-Link from within a C language application.
* The launcher example demonstrates use of articulated and attached parts in VR-Link for both DIS and HLA.
* netdumpDIS is a DIS debugging tool that displays the contents of arriving DIS PDUs in an easy-to-read format. It has several command-line options, including -c to clear the screen between PDUs, -h to display help, and -v to specify verbose mode.
* netdumpHLA listens to an HLA federation execution, subscribes to all object and interaction classes in the FOM, and prints out data whenever it receives an attribute update or interaction. It has several command-line options, including -c to clear the screen between messages, -f to specify a FOM Mapper library name, and -v to display version information.

The code examples provided are:

* netdumpDIS usage: `netdumpDIS [-c -errorChecking -h -v -r –verbose -A address -P port -S address –ignore_rest]`
* netdumpHLA usage: `{netdumpHLA13 | netdumpHLA1516 | netdumpHLA15161e} [– -c -F -f libname –fomMapperInitData data –rprFomVersion version_number -h -M -m -n -r -R -v -x exec-name –ignore_rest]`

Note that the text provides detailed information on the command-line options for both netdumpDIS and netdumpHLA, including descriptions of each option and its usage.

When running `netdumpHLA` with the `-r` option, it prints the name of each attribute, its size, and a hexadecimal dump of its value for each update or interaction received.

The listen-only application is written in C++ and includes several headers and libraries. It creates an exercise connection (DtExerciseConn), registers a callback to handle fire interactions, and initializes VR-Link time. The program then enters a loop where it checks for user input, processes incoming messages, finds the first entity in the reflected entity list, and prints its position.

The code examples provided are:

1. `Listen.cpp`:
```cpp
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vlutil/vlProcessControl.h>
#include <vl/reflectedEntityList.h>
#include <vl/entityStateRepository.h>
#include <vl/reflectedEntity.h>
#include <vl/fireInteraction.h>
#include <vl/topoView.h>
#include <iostream>

int keybrdTick(void);

void fireCb(DtFireInteraction* fire, void* /*usr*/)
{
    std::cout << "Fire Interaction from " 
          <<  fire->attackerId().string() << std::endl;
}

int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");

        #if DtDIS
        appInit.setUseAsynchIO(true);
        #endif

        appInit.parseCmdLine();

        DtExerciseConn exConn(appInit);

        // Register a callback to handle fire interactions.
        DtFireInteraction::addCallback(&exConn, fireCb, NULL);

        // Create an object to manage entities that we hear about 
        // on the network.
        DtReflectedEntityList rel(&exConn);

        // Initialize VR-Link time.
        DtClock* clock = exConn.clock();

        int forever = 1;
        while (forever)
        {
            // Check if user hit 'q' to quit.
            if (keybrdTick() == -1)
                break;

            // Tell VR-Link the current value of simulation time.
            clock->setSimTime(clock->elapsedRealTime());

            // Process any incoming messages
            exConn.drainInput();

            // Find the first entity in the reflected entity list
            DtReflectedEntity *first = rel.first();

            if (first)
            {
                // Grab its state repository, where we can inspect its data.
                DtEntityStateRepository *esr = first->entityStateRep();

                // Create a topographic view on the state repository, so we 
                // can look at position information in topographic
                // coordinates.
                double refLatitude  = DtDeg2Rad(  35.699760);
                double refLongitude = DtDeg2Rad(-121.326577);
                DtTopoView topoView(esr, refLatitude, refLongitude);

                // Print the position.
                // Since it returns a DtString, we need to force it to 
                // const char* with a cast.
                std::cout << "Position of first entity: "
                       <<  topoView.location().string() << std::endl;
            }

            // Sleep till next iteration.
            DtSleep(0.1);
        }
        return 0;
    }
    DtCATCH_AND_WARN(std::cout);
}
```

2. `keybrdTick()`:
```cpp
int keybrdTick()
{
    char *keyPtr = DtPollBlockingInputLine();
    if (keyPtr && (*keyPtr == 'q' || *keyPtr == 'Q')) 
        return -1;  
    else
        return 0;
}
```

The text also mentions that the source code for both examples is included with VR-Link.

Here is a summary of the main points:

1. Creating a DtVrlApplicationInitializer: This class provides support for command-line arguments.
2. Initializing the exercise connection: The default protocol-specific initialization values are set in the DtVrlApplicationInitializer and its base class, DtExerciseConnInitializer.
3. Managing state and interaction information: Applications use callbacks to handle incoming interactions such as fire, detonations, and collisions.
4. Tracking entities: A reflected entity list is created to keep track of entities found on the network.
5. Managing time: The simulation clock is obtained from the exercise connection.
6. Listening to the network: The program sets VR-Link simulation time and reads and processes any messages arriving through the exercise connection.

The code examples provided demonstrate how to:

* Create a connection to an exercise or federation execution
* Register a callback for incoming interactions
* Track entities using a reflected entity list
* Manage time using the simulation clock
* Listen to the network by reading and processing messages

Here is the complete code example:
```
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>
#include <vl/fireInteraction.h>
#include <vl/iffPublisher.h>
#include <vlpi/EntityTypes.h>
#include <vlutil/vlProcessControl.h>
#include <iostream>

int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");

        // Change some defaults
        #if DtDIS
            appInit.setUseAsynchIO(true);
        #endif

        appInit.parseCmdLine();

        DtExerciseConn exConn(appInit);

        // Create an entity publisher for the entity we are simulating.
        DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
                              DtUnitedStates, DtFighter, DtF18, 0, 0);
        DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
                                    DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 

        // Hold on to the entity's state repository, where we can set data.
        DtEntityStateRepository *esr = entityPub.entityStateRep();

        // Create a topographic view on the state repository, so we 
        // can set position information in topographic coordinates.
        double refLatitude  = DtDeg2Rad(  35.699760);
        double refLongitude = DtDeg2Rad(-121.326577);
        DtTopoView topoView(esr, refLatitude, refLongitude);

        // We can use the ESR to set state.
        esr->setMarkingText("VR-Link");
        topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));

        // Initialize VR-Link time.
        DtClock* clock = exConn.clock();

        DtVector position(0, 0, -100);
        DtVector velocity(20, 0, 0);

        // Send a Fire Interaction.
        DtFireInteraction fire;
        fire.setAttackerId(entityPub.globalId());
        exConn.sendStamped(fire);

        // Main loop
        DtTime dt = 0.05;
        DtTime simTime = 0;
        while (simTime <= 10.0)
        {
            // Tell VR-Link the current value of simulation time.
            clock->setSimTime(simTime);

            // Process any incoming messages.
            exConn.drainInput();

            // Set the current position information.
            topoView.setLocation(position);
            topoView.setVelocity(velocity);

            // Call tick, which insures that any data that needs to be 
            // updated is sent.
            entityPub.tick();

            // Set up for next iteration.
        }
    }
    catch (...)
    {
        std::cerr << "Error: " << std::endl;
    }

    return 0;
}
```
Note that the code examples provided are specific to the VR-Link application and may not be applicable to other applications.

**Listen-Only Example**

This program creates a connection to an exercise or federation execution, registers a callback to handle fire interactions, and manages entities that are heard about on the network. The main loop executes twenty times per second for ten seconds, updating simulation time, processing incoming data, and printing entity positions in topographic coordinates.

**Send-Only Example**

This program creates a connection to an exercise or federation execution, defines an entity type (F18), manages entities using a DtEntityPublisher, sends interactions, and updates state messages. The main loop executes twenty times per second for ten seconds, updating simulation time, processing incoming data, and sending updated state information onto the network.

**Code Examples**

The provided code examples are:

1. Listen-Only Example:
```c
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
// ...
int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
        // ...
    }
    catch (...)
    {
        DtCATCH_AND_WARN(std::cout);
    }
    return 0;
}
```

2. Send-Only Example:
```c
#include <vl/exerciseConn.h>
#include <vl/entityStateRepository.h>
// ...
int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtExerciseConn exConn(appInit);
        // ...
        while (forever)
        {
            // Update simulation time and position.
            position[0] += velocity[0] * dt;
            simTime     += dt;

            // Wait till real time equals simulation time of next step
            DtSleep(simTime - clock->elapsedRealTime()); 
        }
    }
    catch (...)
    {
        DtCATCH_AND_WARN(std::cout);
    }
    return 0;
}
```

These code examples demonstrate the basic structure and functionality of VR-Link applications, including connecting to an exercise or federation execution, managing entities, sending interactions, and updating state messages.

`main()` function:

1. Creates a connection to the exercise or federation execution using `DtVrlApplicationInitializer`.
2. Sets some default values for the connection.
3. Parses command-line arguments.
4. Creates an entity publisher for the F18 aircraft.
5. Registers a callback function (`fireCb`) with the `DtFireInteraction` class to handle incoming interactions such as fire, detonations, and collisions.
6. Creates a reflected entity list to track entities found on the network.
7. Obtains a pointer to the simulation clock from the exercise connection.
8. Sets VR-Link simulation time to provide a common time value for use by time-related operations.
9. Processes any incoming messages using `drainInput()`.
10. Finds the first entity in the reflected entity list and retrieves its position data in topographic coordinates.
11. Prints the position of the first entity.

`keybrdTick()` function:

1. Polls for blocking input line using `DtPollBlockingInputLine()`.
2. Checks if the user has pressed 'q' or 'Q' to quit the program.
3. Returns -1 if the user wants to quit, otherwise returns 0.

The code provides a basic example of how to connect to an exercise using VR-Link and simulate the flight of an F18 aircraft.

This program demonstrates how to connect to an exercise, manage entities, send interactions, and send state messages using VR-Link utility classes.

The program starts by creating a DtExerciseConn to provide an interface to the RTI or DIS network (lines 17-27). It then defines the entity type the F18 will use (line 29) and creates a DtEntityPublisher to manage the generation of messages for this particular entity (line 33).

The program sets up a pointer to the entity state repository, creates a topographic view on that repository, and initializes VR-Link time (lines 37-44). It then sends an interaction using the exercise connection's sendStamped() function (lines 56-58) and enters a main loop that executes twenty times per second for ten seconds.

In each iteration of the main loop, the program sets simulation time, processes any incoming messages, updates the F18's positional data in its entity state repository, ticks the entity publisher to send the updated data onto the network, increments the F18's position, and sleeps until it is time to begin the next iteration (lines 65-85).

The VR-Link utility classes include coordinate conversion routines, matrix and vector classes and functions, and time-related functions. The DtVector class can be used to represent vectors in three-dimensional space, as shown in the example:

DtVector vec(10.0, 20.0, 30.0);

The text describes two classes, `DtVector` and `DtDcm`, which are used to represent 3D vectors and 3x3 matrices respectively.

**DtVector**

* Can be constructed with initial values
* Has copy constructor, assignment operator, equivalence operator, and subscripting operator
* Allows for operations such as:
	+ Creating a new vector from an existing one (`DtVector vec2(vec);`)
	+ Assigning a value to a specific component of the vector (`vec[0] = x;`)
	+ Comparing two vectors for equality (`if (vec == vec2) {...}`)
* Has a `string()` member function that returns a text representation of the contents of the vector
* Has static member functions `zero()`, `i()`, `j()`, `k()`, and `ones()` that return commonly used vectors

**DtDcm**

* Can be constructed with initial values or from three component vectors
* Has copy constructor, assignment operator, equivalence operator, and subscripting operator
* Allows for operations such as:
	+ Creating a new matrix from an existing one (`DtDcm mat2(mat);`)
	+ Assigning a value to a specific component of the matrix (`mat[0][0] = 10.0;`)
	+ Obtaining any of the three vectors that make up the matrix (`DtVector firstRow = mat[0];`)
* Has static member functions `zero()` and `identity()` that return the zero matrix and identity matrix respectively

**Semantics**

* `DtVector` and `DtDcm` objects are usually passed to VR-Link functions by reference, not by pointer
* Functions that operate on these objects can be passed a `DtVectorRef` or `DtConstVector`, while a `DtDcm` can be passed a `DtDcmRef` or `DtConstDcm`

**Manipulation Functions**

* LibMatrix.h contains C-style functions that operate on `DtVector` and `DtDcm`, including addition, subtraction, multiplication, scaling, dot products, cross products, negation, normalization, determinant calculation, transpose, and inverse.

**Orientation and Euler Angles**

* The text also discusses the use of Euler angles to represent orientation, specifically in the context of VR-Link's `DtTaitBryan` class.

The text discusses the classes and functions used for converting between different coordinate systems in VR-Link. The main classes mentioned are:

* `DtTaitBryan`: represents orientation using three component angles (psi, theta, phi) and has inspector and mutator functions to access these angles.
* `DtGeodeticCoord`: represents geodetic coordinates (latitude, longitude, altitude) and has inspectors and mutators for individual components. It also has member functions to convert between geocentric and geodetic coordinates.

The text also discusses the following topics:

* Converting between Euler angles and matrix representation using functions like `DtEuler_to_BodyToRef()` and `DtBodyToRef_to_Euler()`.
* Coordinate conversions, including:
	+ Geocentric coordinates: represented by `DtVector` class.
	+ Geodetic coordinates: represented by `DtGeodeticCoord` class.
	+ Topographic coordinates: represented by `DtCoordTransform` class.
	+ UTM coordinates: represented by `DtUtmInit()` function.

The text also mentions the following functions and classes:

* `DtUseMapDatum()`: allows configuring the reference ellipsoid used for geocentric to geodetic conversions.
* `DtSpheroid` and `DtMapDatum` structs: define the properties of an ellipsoid and a map datum, respectively.
* Pre-defined `DtMapDatums` in `mapDatum.h`, such as `DtWGS84`, `DtED50`, etc.

The code examples provided demonstrate how to use these classes and functions to convert between different coordinate systems.

The text discusses various coordinate systems used in VR-Link, including topographic coordinates, geocentric coordinates, and UTM (Universal Transverse Mercator) coordinates.

Topographic coordinates are defined as a right-handed Cartesian coordinate system with the X-Y plane tangent to the earth's surface at the origin. A DtVector is used to represent a topographic coordinate. The text provides an example of how to convert between geocentric and topographic coordinates using a DtCoordTransform object, which can be initialized using the function DtGeocToTopoTransform().

The text also discusses Euler angles in topographic coordinates, which correspond to heading, pitch, and roll. It shows how to obtain these values by converting an entity's orientation from geocentric to topographic coordinates using a DtCoordTransform object.

UTM coordinates are used to specify locations on the earth's surface. The text explains that UTM coordinates consist of easting and northing values in meters, as well as altitude above a reference ellipsoid. VR-Link allows defining an "offset UTM" coordinate system by passing any arbitrary reference point to the function DtUtmInit(). The text provides an example of how to use this function.

Here is the code examples:

* To create a DtCoordTransform that can convert between geocentric and topographic coordinates:
```
DtCoordTransform geocToTopo;
DtGeocToTopoTransform(DtDeg2Rad(30.0), DtDeg2Rad(100.0), &geocToTopo);
```
* To use the transform to convert a geocentric location to a topographic location:
```
DtEntityStateRepository *esr = ...;
DtVector topoLocation;
geocToTopo.coordTrans(esr->location(), topoLocation);
```
* To initialize a second DtCoordTransform to convert from topographic to geocentric coordinates:
```
DtCoordTransform topoToGeoc;
topoToGeoc.setByInverse(geocToTopo);
```
* To use the transform to convert a topographic location to a geocentric location:
```
DtEntityStateRepository *esr = ...;
DtVector geocLocation;
topoToGeoc.coordTrans(topoLocation, geocLocation);
esr->setLocation(geocLocation);
```
* To obtain an entity's heading, pitch, and roll in topographic coordinates:
```
DtTaitBryan topoEuler;
geocToTopo.eulerTrans(esr->orientation, &topoEuler);
double heading = topoEuler.psi();
double pitch = topoEuler.theta();
double roll = topoEuler.phi();
```

The text describes the `DtDegMinSec` structure and its use in initializing VR-Link's UTM conversion routines. It also explains how to construct a `DtUtmCoord` object, which represents a point in UTM coordinates.

The text then discusses the differences between UTM and topographic coordinate systems, highlighting the importance of understanding these differences when working with coordinates.

Finally, it provides information on lower-level coordinate conversion functions, including the use of rotation matrices to convert vectors between different coordinate systems. The text includes code examples for using these functions, such as obtaining a rotation matrix for converting between geocentric and topographic frames.

Here is the summary without losing any core information:

* `DtDegMinSec` structure definition
* Initializing VR-Link's UTM conversion routines with reference point (35 north latitude, 122 west longitude)
* Constructing a `DtUtmCoord` object
* Differences between UTM and topographic coordinate systems
	+ Z represents altitude above the earth's surface in UTM, but height above a plane tangent to the earth's surface in topographic coordinates
	+ Neglecting small angle between northing and north, UTM X, Y, and Z correspond to east, north, and up, while topographic X, Y, and Z correspond to north, east, and down
* Lower-level coordinate conversion functions
	+ `DtDcmVecMul()` for multiplying a rotation matrix by a vector
	+ `DtLatLon_to_GeocToTopo()` and `DtLatLon_to_TopoToGeoc()` for obtaining rotation matrices between geocentric and topographic frames

All code examples are preserved in the summary.

The text discusses various topics related to VR-Link, including:

1. Coordinate transformations: It explains how to transform coordinates from one system to another using rotation matrices and translational offsets.

Example:
```
DtDcm bodyToTopo;
DtDcmDcmMul(geoc2Topo, esr->bodyToGeoc(), bodyToTopo);
DtTaitBryan topoEuler;
DtBodyToRef_to_Euler(bodyToTopo, topoEuler);
```

2. Linked lists: It introduces the concept of linked lists using `DtList` and provides examples on how to create and manipulate them.

Example:
```
DtList list;
list.add(a1);
list.add(a2);
list.add(a3);

for (DtListItem* item = list.first(); item; item = item->next())
{
   A* current = (A*) item->data();
   printf("%d\n", current->a);
}
```

3. Diagnostic utilities: It discusses how to control the amount of diagnostic information printed by VR-Link using the `DtNotifyLevel` variable and provides examples on how to print diagnostic messages.

Example:
```
DtNotifyLevel = DtNlVerbose;
printf("Diagnostic message");
```

Note that the text also mentions that `DtList` has been superseded by `std::list<>` and recommends using the latter in new code.

The text discusses various functions and classes in VR-Link for printing debug messages, handling exceptions, manipulating IP addresses, and providing miscellaneous global functions.

**Printing Debug Messages**

* The `DtOutputStream` class allows sending debug and informational messages in VR-Link.
* It uses a buffer and allows redirecting messages.
* Examples of using `DtOutputStream` include:
	+ `DtInfo << "something bad just happened, the error is " << error << "\n";`
	+ Attaching a `DtPrinter` to a `DtOutputStream`, such as printing to a file or console.

**Handling Exceptions**

* The `DtException` class represents VR-Link exceptions.
* Member functions may throw exceptions under certain conditions.
* Example of catching an exception:
```c
try {
    region = new DtDDMRegion(spaceName, dimensionVector);
} catch (const DtException& regionException) {
    DtWarn << "Caught exception: " << regionException << std::endl;
}
```

**Manipulating IP Addresses**

* The `vlutil.h` header file provides functions for obtaining and manipulating IP addresses.
* Examples of using these functions include:
	+ Constructing a `DtInetAddr` from a string containing the common dot notation for an IP address: `DtInetAddr myAddr = DtStringToInetAddr("207.86.232.1");`
	+ Returning a string representation of a `DtInetAddr`: `std::string addrStr = DtInetAddrString(myAddr);`

**Miscellaneous Global Functions**

* The following table lists additional miscellaneous global functions:
```markdown
| Function | Description |
| --- | --- |
| DtSleep() | Provides a machine-independent way to halt program execution for some period of time. |
| DtSelect() | Provides a machine-independent interface to the UNIX select system call, which takes different arguments on different platforms. |
```
Note that this summary does not include any assumptions not within the text and keeps all code examples intact.

The text describes two functions in VR-Link: `DtSelect()` and `DtAbort()`.

`DtSelect()` takes five arguments: a number of file descriptors, three arrays of file descriptors to monitor for presence of data to read, availability for writing, and pending exceptional conditions, respectively, and a timeout in seconds. On Windows, the file descriptor 0 is interpreted as stdin.

`DtAbort()` is called whenever VR-Link generates a fatal error and makes the abort system call. If you want to modify VR-Link's abort behavior, you can write your own definition for `DtAbort()`. The default definition resides in its own object file, so your definition will supersede it with no other effects. If your definition is linked into your application through a library, make sure that the library appears before `vlutil` on the link line.

The text also mentions that more information can be found in `vlutil.h` and `vlPrint.h`.

