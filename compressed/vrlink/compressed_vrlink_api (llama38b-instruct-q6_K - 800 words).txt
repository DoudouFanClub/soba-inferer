**Introduction**

The VR-Link toolkit is an object-oriented library of C++ classes, functions, and definitions that simplifies the development of networked simulators and virtual reality applications.

**Protocol-Independent API**

VR-Link provides a protocol-independent API for simulating local entities, setting their state, and sending entity information to other applications over a network using DIS or HLA. The API also simplifies receiving and processing information from other applications.

**Features**

* Exercise Connection: an interface to an HLA or DIS exercise
* Object Tracking: tracks remote participants in the virtual world
* Object Publishing: keeps remote applications informed about the state of entities simulated locally
* Interaction Classes: provides a protocol-independent interface for sending and receiving interaction messages
* FOM-Agility: allows mapping VR-Link's API to another FOM's parameters, attributes, and object or interaction classes
* User Extensibility: allows overriding default functionality through subclassing
* Low-Level Access: provides direct access to the HLA RTI and network configuration in DIS
* Utility Functions: includes vector and matrix manipulation functions, system clock interface, and support for discreet simulation time

**Files and Executables**

VR-Link includes:

* Header files and libraries necessary to build applications based on VR-Link
* Executables and source code for the following utility applications:
	+ F18
	+ DIS Netdump
	+ Talk
	+ Listen
* Source code and executables for sample applications, including test applications that demonstrate how to extend the features of VR-Link by creating own PDUs, interactions, encoders, and decoders.

All code examples are retained in full.
**Simulation Standards Supported**

VR-Link supports HLA (High-Level Architecture) and DIS (Distributed Interactive Simulation) simulation standards.

**HLA RTI 1.3 and RTI 1516 Specifications**

VR-Link supports HLA RTI 1.3, HLA RTI 1516, and HLA Evolved (IEEE 1516-2010) specifications. The protocol-independent interface allows for creating applications that can work with any version of HLA without significant changes.

**FOM Support**

VR-Link provides built-in support for the Real-Time Platform Reference FOM (RPR FOM). The RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group. VR-Link supports various versions of the RPR FOM, including:

* RPR FOM 0.5, 0.7, 0.8, 1.0
* RPR FOM 2.0, drafts 6, 14, 17, and 20

**Interoperability**

VR-Link allows for interoperability between HLA 1.3 and IEEE 1516 federates.

**FED and FDD (XML) Files**

VR-Link supports configuration files in both FED and FDD (XML) formats. These files can be used with RTI 1516, HLA Evolved, and RTI 1.3.

**Code Examples**

The provided text includes the following code examples:

* None

Note: The text does not include any explicit code examples.
The text discusses VR-Link, a toolkit for writing simulation applications. It provides multiple layers of access to developers, allowing them to choose how they approach application development.

There are several options for approaching application development with VR-Link:

1. Work through the protocol-independent interface to create applications that work with both HLA and DIS.
2. Go below the protocol-independent interface to take advantage of protocol-specific classes and tailor the application to HLA or DIS.
3. Extend VR-Link by creating new classes for HLA objects and interactions, or DIS PDUs, and use the FOM Mapper to support additional FOMs.

The text also discusses HLA (High Level Architecture) and DIS (Distributed Interactive Simulation), two simulation standards that are supported by VR-Link. It briefly describes the Federation Object Model (FOM) and Run-Time Infrastructure (RTI) in the context of HLA, as well as the DIS protocol.

In addition, it mentions the Real Time Platform Reference FOM (RPR FOM), which is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group. VR-Link has extensive built-in support for the RPR FOM and supports the FOM defined within the FED file called VR-Link.fed, which represents the RPR FOM plus a few extra classes.

Here is the code example provided in the text:

```
DtExerciseConn conn("MAK-RPR20017-1-1.fed", "MyApp", new DtRprFomMapper(2.0017-1));
```

Note that this code example is used to demonstrate how to connect to an exercise using VR-Link, and the specific parameters and classes used may vary depending on the context in which it is being used.
**RPR FOM**

The RPR FOM aims to facilitate a priori interoperability among HLA simulations that choose to use it. Using the RPR FOM ensures interoperability with others who also use this FOM. Many simulation tools, including most VT MAK products, support the RPR FOM.

**RTI (Run-Time Infrastructure)**

An RTI is an implementation of the HLA interface specification, providing services through its API. Applications can call these functions directly or through VR-Link. The HLA rules require federates to use the RTI for exchanging simulation data.

**DIS Protocol**

The DIS protocol governs how participating applications share information about a virtual world. It specifies packets (Protocol Data Units, PDUs) that communicate this information. Each PDU identifies the sender and contains other information depending on its type. The table lists DIS version numbers and their corresponding formal specifications:

| Version | Specification |
| --- | --- |
| 0 | Other |
| 1 | DIS PDU version 1.0 (May 1992) |
| 2 | IEEE 1278-1993 |
| ... | ... |

**Protocol Independence**

VR-Link's Protocol-Independent API allows creating applications that work in both DIS and HLA without significant modification. When creating a protocol-independent application, you write one application and compile it for each protocol by specifying the protocol at compile time.

**Obtaining Further Information about HLA and DIS**

The HLA 1.3 and IEEE 1516 specifications are copyrighted and not distributed by MAK. You can find documentation for the RTI 1.3 and 1516 interface specifications at:

* http://shop.ieee.org/store/
* http://www.sisostds.org
* http://www.sisostds.org/ProductsPublications/Standards.aspx

**A Conceptual Overview of VR-Link**

VR-Link's protocol-independent classes enable applications to interact with other players in a virtual world. These tasks typically include:

1. Connecting to an exercise.
2. Managing state information.
3. Managing information about events.

The code examples provided are retained in full, and no assumptions or extra information has been added.
VR-Link provides classes that facilitate tasks related to real-time platform-level simulations. These classes include protocol-independent and protocol-specific categories.

**Protocol-Independent Classes**

* Exercise Connection: A class that serves as an interface between the application and the RTI or DIS network.
* Object Management Classes:
	+ Publisher Class (e.g., DtEntityPublisher): Manages sending updates of locally simulated objects to the exercise through its Exercise Conn.
	+ Reflected Object Class (e.g., DtReflectedEntity): Represents a remote object, maintaining its current state based on updates received from the exercise.
	+ Reflected Object List Class (e.g., DtReflectedEntityList): Keeps track of remote objects and creates/destroys them based on information received from the exercise.
	+ State Repository Class (e.g., DtEntityStateRepository): Used by publishers and reflected objects to store the state of the object they represent.

**Exercise Connection**

* Implemented through the class DtExerciseConn, which allows an application to:
	+ Send interactions to the exercise
	+ Read input from the network
	+ Generate event IDs
	+ Register callback functions
	+ Manage the simulation clock

**Managing State Information**

* A VR-Link application typically maintains information about locally simulated entities and communicates this information to other participants in an exercise.
* The application must also obtain information about remote objects and represent them locally.

**Code Examples**

No code examples were provided in the original text.
HLA Federation Execution:

* State updates are sent when update conditions (specified by FOM) are met and a federate has subscribed to the entity attribute that changed.
* Subscription is the process by which a federate tells RTI that it wants to be notified about changes to an object.

Remote Entities:

* VR-Link application receives information about remote entities through the exercise connection.
* The function DtExerciseConn::drainInput() causes VR-Link to read and process input.
* VR-Link maintains a list of remote entities in a DtReflectedEntityList, with each entity represented by a DtReflectedEntity that maintains its state in a DtEntityStateRepository.

Interactions:

* Interactions are events such as firing a munition or collision of entities, managed through classes derived from DtInteraction.
* Locally-defined interactions are sent through the exercise connection, while remote interactions are received and processed through the exercise connection.
* Callback functions can be used to react to remote interactions, with no built-in functions for reacting to remote interactions.

Other Simulation Concepts:

* This section describes how VR-Link implements various simulation concepts, including:
	+ Time: VR-Link maintains a concept of VR-Link simulation time, which is typically advanced each frame in proportion to the amount of real time that has elapsed since the previous frame.
	+ Object identification
	+ Callbacks
	+ Coordinate systems
	+ Dead-reckoning and smoothing
	+ Timestamps

Note: The provided text does not include any code examples beyond class names, such as DtInteraction, DtReflectedEntityList, and DtClock.
The text discusses how to manage simulation time in VR-Link applications, including fixed frame rate and floating frame rate scenarios. It also explains the concept of object identification in HLA and DIS, as well as the use of callbacks in VR-Link.

In terms of managing simulation time, the text provides an example of a main simulation loop that advances the simulation time by a fixed step size (`dt`) and sleeps until the next multiple of that step size. For floating frame rate applications, it suggests passing the current time to `setSimTime()` each frame.

The text also discusses object identification in HLA and DIS, noting that HLA objects have several different identifiers, including Object Handles and Object Names. It provides a reference to section 4.7 for more information on these topics.

Finally, the text explains the use of callbacks in VR-Link, including how to register callback functions with VR-Link classes and how to pass arbitrary pointers as arguments to those functions. It also provides an example of a callback function signature and notes that non-static member functions cannot be passed directly to VR-Link's callback registration functions.

Here is the code example provided:

```c
DtObjectPublishers and DtReflectedObjects use their DtExerciseConn's clock when performing dead-reckoning, thresholding, and so on. In rare cases where you are creating an instance of an entity or aggregate state repository yourself outside of the context of a publisher or reflected object, you will need to tell the repository what clock to use if you want dead-reckoning to occur properly. Do this using the repository's setClock() function.

For more information, please see 2.7.6 Timestamps.

One concept that HLA and DIS handle fairly differently is object identification. In DIS, entities are identified by a triplet (site, application, entity) known as an Entity Identifier. Other types of objects are usually identified using the IDs of their host entities plus a single additional ID number. In HLA, objects have several different identifiers, including:

An Object Handle, which is used within a federate to identify a particular object in an RTI service invocation
An Object Name, which is used within interactions and attribute updates exchanged among federates for the RPR FOM.

For more information about the various types of identifiers, and to see how VR-Link accounts for these differences, please see 4.7 - Identifying Objects.

class MyObj
{
public:
   // The function we want to call.
   void doSomething( void* usr )
   {
      MyObj* obj = static_cast<MyObj*>(usr);
      obj->someMethod();
   }
};
```

This code example demonstrates how to define a callback function (`doSomething`) that takes a `void*` argument, which is typically used to pass an arbitrary pointer to the callback. The example also shows how to cast the `void*` back to the original object type using `static_cast`.
The text describes various features and concepts related to VR-Link, a software framework for simulation and interaction with virtual environments.

1. Interaction Callbacks: A static member function `theCallback` is defined to be registered as an interaction callback with the `DtFireInteraction` class. When called by VR-Link, it takes two parameters: a pointer to a `DtFireInteraction` object and a void pointer `usr`. The callback function casts `usr` to a `MyObjType*` and calls the `someFunc()` method on it.

2. Registering Callbacks: In the `main()` function, an instance of `MyObj` is created and registered with a callback using `DtFireInteraction::addCallback()`, passing pointers to the `exConn` object, `theCallback` function, and `obj` as arguments.

3. Coordinate Systems: VR-Link supports various coordinate systems, including geocentric coordinates by default, UTM coordinates, Cartesian coordinates, and Topographic coordinates. The text provides references for more information on views and coordinate conversions.

4. Dead-Reckoning and Smoothing: To represent the behavior of entities between state updates, VR-Link uses dead-reckoning and smoothing to estimate the location of an entity based on its acceleration and velocity. The text explains how this process works and provides a reference for more information.

5. Timestamps: When sending interactions or object state updates through `DtExerciseConn` using `sendStamped()`, a timestamp is sent along with the message. The timestamp type indicates whether the clock used to obtain the timestamp is synchronized to a global exercise clock. If both sender and receiver use absolute timestamping, the receiver can immediately make sense of the timestamp; otherwise, it may be ignored.

6. Wire Formats: VR-Link provides mechanisms for setting and inspecting the current wire format at runtime using `DtSetNetworkByteOrdering()` and `DtNetworkByteOrdering()`. Big endian is the default wire format.
The text discusses two simple VR-Link applications: Listen-Only Example and Send-Only Example. The Listen-Only Example listens to the network without simulating any entity on it. To use little-endian byte ordering, you can call `DtSetNetworkByteOrdering(DtLittleEndian)`.

The code examples provided are for the Listen-Only Example. It includes several header files and defines a callback function `fireCb` that prints a message when a fire interaction is detected on the network. The main function creates a connection to an exercise or federation execution, registers a callback to handle fire interactions, and initializes VR-Link time.

The code also provides examples of how to connect to an exercise using different protocols (DIS and HLA). It explains how applications based on VR-Link use callbacks to handle incoming interactions such as fire, detonations, and collisions.

Here is the complete code for the Listen-Only Example:

```c
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vlutil/vlProcessControl.h>
#include <vl/reflectedEntityList.h>
#include <vl/entityStateRepository.h>
#include <vl/reflectedEntity.h>
#include <vl/fireInteraction.h>
#include <vl/topoView.h>
#include <iostream>

int keybrdTick(void);

void fireCb(DtFireInteraction* fire, void* /*usr*/)
{
    std::cout << "Fire Interaction from " 
          <<  fire->attackerId().string() << std::endl;
}

int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");

#if DtDIS
        appInit.setUseAsynchIO(true);
#endif

        appInit.parseCmdLine();

        DtExerciseConn exConn(appInit);

        // Register a callback to handle fire interactions.
        DtFireInteraction::addCallback(&exConn, fireCb, NULL);

        // Create an object to manage entities that we hear about 
        // on the network.
        DtReflectedEntityList rel(&exConn);

        // Initialize VR-Link time.
        DtSleep(0.1);

        while (true)
        {
            // Sleep till next iteration.
            DtSleep(0.1);
        }

        return 0;
    }
    DtCATCH_AND_WARN(std::cout);
}

int keybrdTick()
{
    char *keyPtr = DtPollBlockingInputLine();
    if (keyPtr && (*keyPtr == 'q' || *keyPtr == 'Q')) 
       return -1;  
    else
       return 0;
}
```

And here is an example of how to connect to an exercise using different protocols:

```c
int main()
{
   // Create a connection to the exercise or federation execution
#if DtHLA
   DtString execName("VR-Link");
   DtString fedName("VR-Link listen"); 
   DtExerciseConn exConn(execName, fedName, new DtSimpleRprFomMapper);
#elif DtDIS
   int port           = 3000;
   int exerciseId     = 1; 
   int siteId         = 1;
   int applicationNum = 15;
   DtExerciseConn exConn(port, exerciseId, siteId, applicationNum,
                              0,             // No Status, any error will be fatal
                              true);            // use Async IO
#endif 
```

I hope this summary helps! Let me know if you have any further questions.
The program simulates the flight of an F18 aircraft using VR-Link and HLA (High-Level Architecture). It creates a connection to the exercise or federation execution, sets up an entity type for the F18, and creates an entity publisher to manage the generation of messages for this entity.

The program then enters a main loop where it:

1. Sets the simulation time
2. Processes any incoming messages using `exConn.drainInput()`
3. Updates the current position information using `topoView.setLocation()` and `topoView.setVelocity()`
4. Calls `entityPub.tick()` to send updated data if necessary
5. Waits till real time equals simulation time of next step using `DtSleep()`

The program also includes examples of:

1. Sending a fire interaction using `exConn.sendStamped()`
2. Connecting to an exercise using `DtExerciseConn`
3. Managing entities using `DtEntityPublisher` and `entityStateRepository`
4. Creating a topographic view on the entity state repository

The code examples provided are:

```
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>
#include <vl/fireInteraction.h>
#include <vl/iffPublisher.h>
#include <vlpi/EntityTypes.h>
#include <vlutil/vlProcessControl.h>
#include <iostream>

int main(int argc, char** argv)
{
    // ...
}
```
**Sending State Messages**

The main loop executes 20 times per second for 10 seconds, simulating the sending of state updates. The program uses the `sendStamped()` function to send state updates, but it is recommended to use the entity publisher to send state updates using data from the entity state repository.

**Compiling and Linking a VR-Link Application**

To build a VR-Link application, you need to:

1. Include the VR-Link header files and RTI header files (for HLA) in your compiler flags.
2. Link with VR-Link's libraries (and for HLA, the RTI's libraries).
3. Compile for a particular simulation standard (HLA or DIS) using the specified flags.

**Libraries and Header Files**

VR-Link consists of four libraries: mtl, vl, matrix, vlpi, and vlutil. The `vl` library has different versions for HLA and DIS.

**Compiling for a Particular Simulation Standard Under Linux**

To build a VR-Link application on Linux, you need to:

1. Use gmake 3.81 or later.
2. Select the simulation standard (HLA or DIS) using compile flags.
3. Include the `vlhome` directory in your include path.

**Compile and Link Flags for HLA**

For HLA, the compile flags are:
```
-I{VLHOME}/include
-I{VLHOME}/RTI/include
-DDtHLA=1 (or D DtHLA_1516=1 or DDtHLA_1516_EVOLVED=1)
```
The link flags are:
```
-lvrhome/lib -lvl -lvlHLA13 -lmatrix -lmtl -lvlutil -lxml2 -lRTI-NG -lfedtime
(lvlHLA1516 or lvlHLA1516e for IEEE 1516-2000 or IEEE 1516-2010)
```
**Compile and Link Flags for DIS**

For DIS, the compile flag is:
```
-Ivlhome/include
-DDtDIS=1
```
The link flags are:
```
-Lvlhome/lib -lvl -lmtl -lvlDIS -lmatrix -lvlutil -lxml2
```
**VR-Link Compiling for HLA and DIS**

To compile for HLA, you need to set the following #define symbols in the C/C++ -> Preprocessor Definitions section:

DtHLA=1, DtHLA_1516=1, RTI_USES_STD_FSTREAM=1

In the Additional Include Directories section, enter your VR-Link include path and the path to your RTI include directory.

In the Linker -> Input section, enter the following library files:

* For HLA: libRTI-NG.lib | librti1516.lib | librti1516e.lib, vlHLA13.lib | vlHLA1516.lib | vlHLA1516e.lib
* For DIS: vlutil.lib mtl.lib matrix.lib vl.lib vlDIS.lib netapi32.lib WS2_32.lib iphlpapi.lib comctl32.lib

Also, make sure to list the appropriate paths to these files in the Additional Library Directories section.

**Using VR-Link from C**

VR-Link is a C++ toolkit, but you can use it with a C application. To do so, you need at least one C++ file that contains functions that interact with VR-Link code.

When calling C++ from C, you need to compile the C++ code in such a way that it may be called from C. You can do this by surrounding the function declarations with the `extern "C"` keyword.

When calling C from C++, you can create a C++ function that interfaces with VR-Link code and calls C functions. To alert the C++ compiler that an external function is a C function, surround its declaration with the `extern "C"` keyword.

Header files that are included by both C and C++ code should be surrounded by:

#ifdef __cplusplus
#endif

**Delivering VR-Link Applications to Users**

A VR-Link developer's license allows you to compile applications using the VR-Link libraries and run one such application. After developing an application, you may need to deliver it to an internal or external customer. The end user of the application needs a VR-Link run-time license to use it.

All code examples are retained in full without any changes.
The customer only needs the application, VR-Link libraries, license management files, and run-time licenses for each instance of the application that will be run. They do not need the entire VR-Link toolkit or developer's license (unless recompiling is necessary). 

The protocol-independent interface (PII) is a set of classes that provide most of VR-Link's features and allow for applications to work with both DIS and HLA without significant modifications. The PII shields developers from protocol-specific intricacies, but protocol-specific classes are available if needed.

Applications can connect to exercises through the DtExerciseConn class, which provides an interface between a simulation application and an exercise. There are HLA and DIS versions of this class, with most public member function names and signatures shared by both. 

To create a DtExerciseConn in HLA, you must provide a federation execution name and federate name, which can be done through the constructor or using the DtExerciseConnInitializer. The FED file provides information about the Federation Object Model (FOM) to the RTI and VR-Link.

The code examples provided are:

* 4 - The Protocol Independent Interface
* 4.1 - Introduction to the Protocol-Independent Interface
* 4.2 - Connecting to Exercises
	+ 4.2.1 Creating an Exercise Connection for HLA
	+ 4.2.2 Creating an Exercise Connection for DIS
	+ 4.2.3 Initializing Applications
	+ 4.2.4 DtExerciseConn Member Functions

Note: The provided code examples are included in full, without modification or addition of any assumptions or extra information.
**Federation Execution Name (HLA)**

* The federation execution name is used to identify the HLA world.
* All applications that want to interact in the same HLA world must use the same federation execution name and FED file.
* The default FED file supported by VR-Link is `VR-Link.fed`, located in the `./bin` directory.

**Federate Name**

* The federate name is a name given to an application.
* It is used for RTI diagnostics, but does not have to be unique in a federation.
* The default federate name is the same as the application name.

**Creating an Exercise Connection (HLA)**

* To create an exercise connection for HLA, you need:
	+ A FED file
	+ A DtExerciseConn constructor
* Initialize an application's RTI ambassadors and join the federation execution.
* The `DtExerciseConn` constructors initialize an application's RTI ambassadors and create/join the named federation execution.

**Creating an Exercise Connection (DIS)**

* To create an exercise connection for DIS, you need:
	+ A UDP port number
	+ An exercise ID number
	+ A site number
	+ An application number
* Specify these values in the `DtExerciseConnInitializer` and pass them to the `DtExerciseConn` constructor, or specify them directly in the constructor.
* All applications that want to interact in a DIS exercise must use the same UDP port number and exercise ID number.

**Initializing Applications**

* Use `DtVrlApplicationInitializer` to specify default initialization values for VR-Link-based applications.
* Enable parsing of command line input, loading XML or MTL files, and saving state to an XML file.
* Specify default values for protocol-dependent initialization in the `DtExerciseConnInitializer`, configuration file, or command line.

**Command Line Options**

* Protocol-independent options:
	+ Notification level (`-n` or `--notifyLevel`)
	+ Log file name (`--logFileName`)
	+ Ignore rest of labeled arguments (`--ignore_rest`)
	+ Display version information and exit (`-v` or `--version`)
	+ Display usage information and exit (`-h` or `--help`)
* HLA command line options:
	+ Execution name (`-x` or `--execName`)
	+ Federate name (`-N` or `--federateName`)
	+ FED file name (`-F` or `--fedFileName`)
	+ FOM Mapper library name (`-f` or `--fomMapperLib`)
	+ FOM Mapper initialization data (`--fomMapperInitData`)
	+ RPR FOM revision (`--rprFomRevision`)
	+ RPR FOM version (`--rprFomVersion`)
	+ Disable RTI Compiler version check (`--noRtiCompilerCheck`)
	+ Ignore Advisories (`--ignoreAdvisories`)
	+ Federate Type (`-p` or `--federateType`)
	+ HLA Evolved MIM Module (`--mimModule`)
	+ Add FOM Modules ()
**HLA Evolved only**

* `fomModules`: accepts a string parameter
* `HLA Evolved Local Settings Designator`: accepts a string parameter using `-S` or `--localSettingsDesignator`

**Default DIS Command Line Options**

* `DIS port`: accepts a port number using `-P` or `--disPort`, default is 3000
* `Exercise ID`: accepts an ID using `-x` or `--exerciseId`, default is 1
* `Application number`: accepts a number using `-a` or `--appNumber`, default is 2
* `Site ID`: accepts an ID using `--siteId`, default is 1
* `Destination address`: accepts an address using `-A` or `--destAddrString`, default is ""
* `Device address`: accepts an address using `--deviceAddress`
* `Send buffer size`: accepts a size using `--sendBufferSize`, default is -1 (uses system default)
* `Receive buffer size`: accepts a size using `--recvBufferSize`, default is -1 (uses system default)
* `Multicast TTL`: accepts a TTL value using `--mcastTtl`, default is -1 (uses system default)
* `Multicast address`: accepts addresses using `-S` or `--mcastAddresses`
* `Suppress self-reflection`: accepts a boolean value using `--suppressSelfReflect`, default is false
* `Use IPv6`: accepts a boolean value using `--useIpv6`, default is false
* `DIS Version`: accepts a version number using `--disVersion`
* `Use Asynchronous I/O`: accepts a boolean value using `--useAsyncIO`, default is 0
* `Subnet mask to use`: accepts a subnet mask and a prefix length using `<--subnetMask <mask>/TD>`

**DtExerciseConn Member Functions**

* `addPostDrainCallback()`: registers functions to be called automatically after drainInput()
* `removePostDrainCallback()`: unregisters functions from being called after drainInput()
* `drainInput()`: reads and processes input from the exercise
* `nextEventID()`: generates consecutive event IDs for use in fire, detonate, or collision interactions
* `send()`, `sendStamped()`: sends interaction messages, object updates, and DIS PDUs to the exercise
* `setTimeStampType()`: specifies the type of time stamp being sent
* `timeStampType()`: returns the time stamp type
* `vrlinkVersion()`: returns the version of VR-Link

**Sending Data to the Exercise**

* Use `send()` and `sendStamped()` member functions to send interactions to the exercise
* Typically, object state information is handled using higher-level object-management classes

**Receiving Data from the Exercise**

* Use `drainInput()` function to receive and process information from the RTI or DIS network
* Register callbacks for interaction, PDU, and RTI service processing within drainInput()
* Call `drainInput()` periodically, usually once per simulation loop

**Post-Drain Callbacks**

* Post-drain callbacks are functions that can be registered with a DtExerciseConn to be called automatically after drainInput()
* Use `addPostDrainCallback()` and `removePostDrainCallback()` to register and unregister post-drain callbacks
* Post-drain callbacks have the function signature `void myCallback(void* usr);`
The text describes various features and functions of VR-Link, an exercise connection interface for simulation applications.

* It discusses setting up post-drain callbacks to send interactions safely after RTI service callbacks have been invoked.
* It explains the concept of time stamp types (absolute or relative) and how to set them using the `setTimeStampType()` function in `DtExerciseConn`.
* It describes initialization status, including error handling and checking for license management errors using global functions.

The text also covers interactions in VR-Link:

* Interactions are data exchanged among simulation applications to describe events.
* Each type of interaction has its own class (e.g., `DtFireInteraction`, `DtDetonationInteraction`, etc.).
* The individual interaction classes are derived from `DtInteraction`.
* There are protocol-specific versions of each interaction class for DIS and HLA.

The text concludes with an example code snippet showing how to create and send a fire interaction using the `sendStamped()` function in `DtExerciseConn`.

Here is the full code example:
```c
// Create an instance of the appropriate interaction class (derived from DtInteraction)
DtFireInteraction* fireInteraction = new DtFireInteraction();

// Use its mutator functions to set values for the different parameters
fireInteraction->setSenderId(myId);
fireInteraction->setTargetId(targetId);
fireInteraction->setMissileId(missileId);

// Send it using DtExerciseConn's sendStamped() function
exerciseConn.sendStamped(fireInteraction);
```
Note that this code assumes `myId`, `targetId`, and `missileId` are existing objects.
The code snippet provides an example of how to send and receive interactions using VR-Link and DtExerciseConn.

**Sending Interactions**

* Create a `DtFireInteraction` object and set its attributes (attacker ID, target ID, munition ID, event ID).
* Use the `sendStamped()` method to send the interaction to the exercise. This method includes a timestamp with outgoing interactions.
* The timestamp is obtained from the `currentTimeForStamping()` function of the `DtExerciseConn` object.

**Receiving Interactions**

* Incoming interactions are handled through interaction callbacks.
* Application developers write and register callback functions for specific interaction types using the `addCallback()` method.
* When an interaction is received, VR-Link calls the registered callback function with a pointer to the interaction as an argument.
* The callback function can process the interaction as it arrives.

**Callback Function Example**

* A callback function example is provided for handling `DtFireInteraction` objects:
```cpp
void myFireCallback(DtFireInteraction* inter, void* usr) {
    std::cout << "Got a Fire Interaction from " << inter->attackerId().string() << std::endl;
}
```
This callback function is registered with VR-Link using the `addCallback()` method:
```cpp
DtFireInteraction::addCallback(exerciseConn, myFireCallback, NULL);
```
**Note**

* The `addCallback()` method can be called using the qualified name of the interaction class.
* The `usr` argument passed to the callback function is the same value that was passed as an argument to `addCallback()`.
* When multiple callbacks are registered for a specific interaction type, they are called in the opposite order from which they were registered.

**Making RTI Calls in Response to Interactions**

* In HLA applications, interaction callbacks are called from within `RTI::tick()` (which is called by `DtExerciseConn::drainInput()`).
* Some RTIs do not allow calls to RTI services from within other RTI service calls. Therefore, it is not possible to make direct or indirect RTI calls from within interaction callback functions.
* To make RTI calls based on the receipt of a `DtInteraction`, application developers can use `DtExerciseConn::addPostDrainCallback()` to register a function that will be executed right before `drainInput()` returns.

The code snippet also provides an example of how to send a fire interaction in response to receiving a fire interaction:
```cpp
void sendFire(void *usr) {
    // ...
}

void fireCb(DtFireInteraction* inter, void *usr) {
    // ...
    exConn->addPostDrainCallback(sendFire, exConn);
}
```
This code demonstrates how to register the `sendFire` function as a post-drain callback using `DtExerciseConn::addPostDrainCallback()`.
The chapter discusses how to manage entities using classes provided by VR-Link. Entities include vehicles, life forms, and other real-world objects that have a position in space.

To inform other simulation applications about the state of locally-simulated entities, you must:

* Create a DtEntityPublisher for each locally-simulated entity.
* Update its current state during every frame through its DtEntityStateRepository.
* Call DtEntityPublisher::tick() to send needed information to other participants through the exercise connection.

There are several ways to create a DtEntityPublisher:

1. Use the protocol-independent constructor that takes a DtExerciseConn and DtEntityType as arguments:
```
DtExerciseConn exConn(...);
DtEntityType tankType(1, 1, 225, 1, 1, 0, 0);
DtEntityPublisher tankPub(tankType, &exConn);
```
2. Use the protocol-independent constructor that takes three attributes of an entity that are not likely to change during a simulation:
```
// Not shown
```
3. Use protocol-specific constructors that allow you to specify parameters such as the HLA object class to represent the object.

When creating a DtEntityPublisher, you can choose an identifier for the entity by passing it as an optional final argument to the constructor. In HLA, this identifier is the object name, which can be chosen by the RTI or provided by the user.
To reserve an object name, a call must be made to the RTIambassador using `ExConn->rtiAmb()->reserveObjectInstanceName(theName)`. The RTI then calls the Federate Ambassador to let the federate know if the name reservation succeeded or failed. VR-Link keeps a list of all names that have been successfully reserved.

When creating a publisher for an object and specifying a name, VR-Link checks the list of reserved names and requests reservation if the name is not found. The number of times the publisher ticks the RTI and the duration of each tick can be set using static methods in `DtHlaObjectManager`.

VRT applications can make RTI calls to reserve names before creating publishers. It is recommended to batch these requests for performance improvement.

For HLA, a `DtGlobalObjectDesignator` identifier must be chosen when creating a `DtEntityPublisher`. For DIS, the identifier is a `DtEntityIdentifier` triplet. If an identifier is not provided, VR-Link will choose one using `DtExerciseConn's nextId()` function.

To find out the chosen identifier for an object, use the `globalId()` or `id()` functions of the `DtEntityPublisher`.

Setting an entity's state can be done through its `DtEntityStateRepository`. The repository has mutator functions to set various components of an entity's state, such as time, space, and position information. These functions take a time argument specifying the simulation time at which the data is valid.

Components that affect the outward appearance of an entity can also be set using functions like `setDamageState()` or `setFlamesPresent()`.

Positions, velocities, and accelerations must be set in geocentric coordinates as specified in the DIS Standard. The `DtVector` class can be used to set coordinates, which are specified in meters. Orientation is set as a `DtTaitBryan`, which represents three angles that specify successive rotations from the geocentric coordinate system to the entity coordinate system.

Here are the code examples:

```c
#if DtHLA
    DtGlobalObjectDesignator id = "Object1";
#elif DtDIS
    DtGlobalObjectDesignator id = DtEntityIdentifier(1, 2, 3);
#endif

DtExerciseConn exConn(...);
DtEntityType tankType(1, 1, 225, 1, 1, 0, 0);
DtEntityPublisher tankPub(tankType, &exConn, id);

// Set request name tick time
static double requestNameTickTime();
static void setRequestNameTickTime(double time);

// Set number of request name tries
static int numberOfRequestNameTries();
static void setNumberOfRequestNameTries(int tries);

// Get a pointer to a DtEntityPublisher's DtEntityStateRepository
DtEntityStateRepository* esr() = tankPub.entityStateRep();

// Set location, velocity, acceleration, orientation, and rotational velocity using esr()
esr()->setLocation(DtVector(x, y, z));
esr()->setVelocity(DtVector(dx, dy, dz));
esr()->setAcceleration(DtVector(ax, ay, az));
esr()->setOrientation(DtTaitBryan(angle1, angle2, angle3));
esr()->setRotationalVelocity(DtVector(dax, day, daz));

// Set damage state, flames present, engine smoke on, and hatch state using esr()
esr()->setDamageState(enum_value);
esr()->setFlamesPresent(true);
esr()->setEngineSmokeOn(true);
esr()->setHatchState(enum_value);
```
**Entity Coordinate System**

The entity coordinate system is used to represent the state of entities in VR-Link simulations. There are various coordinate systems supported by VR-Link, and conversions between them can be performed using the `DtEntityStateRepository` class.

**Setting Entity State**

The following code sample demonstrates how to set the current state of an entity using the `DtEntityStateRepository` mutator functions:
```c
DtEntityPublisher tankPub(...);
// ...
 DtEntityStateRepository *esr = tankPub.entityStateRep();
esr->setLocation(DtVector(-2696545.0, -4430407.0, 3701906.0));
esr->setVelocity(DtVector(100.0, 100.0, 100.0));
esr->setAcceleration(DtVector(0.0, 0.0, 0.0));
esr->setOrientation(DtTaitBryan(-2.11, 0.948, 2.469));
esr->setRotationalVelocity(DtVector(0.0, 0.10, -0.125));
esr->setFlamesPresent(true);
esr->setDamageState(DtDamageSlight);
// ...
```
**Tick Function**

The `DtEntityPublisher::tick()` function is responsible for updating the entity's state and sending data to other exercise participants. It checks whether the entity's state has changed significantly since the last update and sends a new Entity State PDU if necessary.

**Position and Orientation Thresholds**

Threshold values are used to determine when position and orientation data needs to be sent to other exercise participants. The `DtThresholder` class holds threshold values, which can be set globally or overridden on a per-entity basis using the `threshholder()` member function of the `DtBaseEntityStateRepository` class.

**Removing an Entity**

Deleting a `DtEntityPublisher` removes the entity from the exercise. In HLA, the destructor calls the `deleteObjectInstance` RTI service, while in DIS, it sends a final Entity State PDU with the FinalPdu appearance bit set.
**Working with Remote Entities**

A `DtReflectedEntityList` maintains the current state of entities learned through updates from other participants in an exercise. Each entity is represented by an instance of `DtReflectedEntity`.

**Creating Reflected Entity Lists**

To create a `DtReflectedEntityList`, use:
```
DtExerciseConn exConn(...);
...
DtReflectedEntityList(&exConn);
```
The list automatically creates new `DtReflectedEntity` instances for new entities and updates existing ones with state updates.

**Iterating Through a DtReflectedEntityList**

To iterate through the list, use:
* `first()` and `last()` to get the first and last entities
* `next()` and `prev()` to get the next and previous entity (returns NULL if out of bounds)
* `wrapNext()` and `wrapPrev()` to loop back to the beginning or end of the list

Example iteration code:
```
for (DtReflectedEntity* ent = rel.first();
    ent;
    ent = ent->next())
{
    ...
}
```
**Looking Up Entities**

Use `lookup()` to find a `DtReflectedEntity` by its ID, which can be either a global or local ID.

Example code:
```
DtGlobalObjectDesignator id = fireInteraction.targetId();
DtReflectedEntity* ent = reflectedEntityList.lookup(id);

#elif DtDIS
DtObjectId id = DtEntityIdentifier(1, 2, 3);
#endif
DtReflectedEntity* ent = reflectedEntityList.lookup(id);
```
**Delayed Discovery of Reflected Objects**

Use `setDiscoveryCondition()` to specify a predicate function that determines when an object should be added to the list. This is useful in HLA applications where attribute information may arrive after the object is discovered.

Example code:
```c
bool myPredicate(DtReflectedEntity* ent) {
    // return true if the entity has valid attribute values
}

DtReflectedEntityList rel(...);
rel.setDiscoveryCondition(myPredicate);
```
I did not add any extra information or assumptions, and retained all code examples in full. Let me know if you have any further requests!
The text describes how to work with `DtReflectedEntityList` and its associated classes in VR-Link. Here are the main points:

1. **Waiting for entity type**: You can set a condition on an ` DtReflectedEntityList` to wait until the entity type is known before discovering entities.
2. **Inspecting entity state**: The `DtReflectedEntity` class uses a `DtEntityStateRepository` to store the current state of an entity. This class provides inspector functions to examine various components of an entity's state, such as location, velocity, acceleration, orientation, and more.
3. **Mutator functions**: `DtEntityStateRepository` has mutator functions to set a locally simulated entity's state, but these are usually used for entities that are not reflected in the exercise.
4. **Coordinate systems**: VR-Link uses geocentric coordinates by default, but provides various View classes and coordinate conversion functions to work with other coordinate systems.
5. **Inspector functions**: The `DtEntityStateRepository` class has inspector functions to examine an entity's state, including last-set values for certain components.
6. **Dead-reckoning**: By default, the position, velocity, and orientation of a `DtReflectedEntity` are dead-reckoned values, which means they are extrapolated forward from acceleration, velocity, and angular velocity based on the entity's current dead-reckoning algorithm.

The provided code examples demonstrate how to use these classes and functions in practice. For example, the `printStateOfFirstEnt` function prints part of the state of the first entity in a list using inspector functions from `DtEntityStateRepository`.
The VR-Link simulation time is managed by the setSimTime() function, which should be called once per frame to ensure that all entities are dead-reckoned to the same time within a frame. Dead-reckoning applies to entities and aggregates, but not to other objects.

There is no performance penalty for calling inspectors for dead-reckoned values more than once during a particular frame as long as the VR-Link simulation time has not changed. Dead-reckoning is not performed for entities whose positions and orientations are never inspected.

The DtEntityStateRepository uses a DtDeadReckoner to perform dead-reckoning calculations, which involves passing position-related values to the dead-reckoner's mutators and obtaining extrapolated values from the dead-reckoner using its inspectors. The virtual functions DtDeadReckoner::deadReckonPosition() and DtDeadReckoner::deadReckonOrientation() calculate the position and orientation based on the entity's current rates of movement and the time that has passed since the last update.

To change the way dead-reckoning is handled by a DtEntityStateRepository, create a subclass of DtDeadReckoner and override the virtual functions. Alternatively, pass NULL to setApproximator() to disable dead-reckoning or use the original default dead-reckoner by calling useDeadReckoner() with no arguments.

The enums for the dead-reckoning algorithms are:

* DtDrDrmRvw - Rotational, constant acceleration
* DtDrDrmRpw - Rotational, constant velocity
* DtDrDrmFvw - Fixed, constant acceleration
* DtDrDrmFpw - Fixed, constant velocity
* DtDrDrmRvb - Rotational, body coordinates (unimplemented in VR-Link)
* DtDrDrmRpb - Rotational, body coordinates (unimplemented in VR-Link)
* DtDrDrmFvb - Fixed, body coordinates (unimplemented in VR-Link)
* DtDrDrmFpb - Fixed, body coordinates (unimplemented in VR-Link)
* DtDrOther - No dead reckoning is calculated
* DtDrStatic - No dead reckoning is calculated

It is recommended to use one of the Rotational algorithms when requiring orientation to be dead-reckoned, and one of the Fixed algorithms for positional calculations. The constant acceleration options are suitable for high-speed entities.

VR-Link can smooth out jumps in entity position using the DtSmoother class, which is derived from DtDeadReckoner. Smoothing applies to entities and aggregates, but not to other objects. The default time over which smoothing takes place can be set globally or overridden individually.

Finally, applications may want to be notified when an entity joins or leaves the exercise.
**Callbacks for Entity Addition and Removal**

* Register entity-addition and entity-removal callbacks with a `DtReflectedEntityList` using `addEntityAdditionCallback()` and `addEntityRemovalCallback()`.
* Entity-addition callbacks are called by VR-Link just after an entity is added to the list.
* Entity-removal callbacks are called just before an entity is removed from the list.
* Callbacks must have the following function signature: `void func(DtReflectedEntity* ent, void* userData);`

**Example Code**

```
void printHello(DtReflectedEntity* ent, void* userData)
{
   assert(ent);
   cout << "HELLO " << ent->id().string() << endl;
}
void printGoodbye(DtReflectedEntity *ent, void *userData)
{
   assert(ent);
   cout << "GOODBYE " << ent->id().string() << endl;
}

int main()
{
   ...
   rel->addEntityAdditionCallback(printHello, 0);
   rel->addEntityRemovalCallback(printGoodbye, 0);
   ...
}
```

**Subclassing `DtReflectedEntityList`**

* You can subclass `DtReflectedEntityList` and override the virtual functions `entityAdded()` and `removeAndDelete()`.
* `entityAdded()` is called just after an entity is added to the list.
* `removeAndDelete()` is called to remove an entity from the list. Call the base version of this function within your implementation.

**Post-Update Callbacks**

* Register post-update callbacks with a `DtReflectedEntity` using `addPostUpdateCallback()`.
* Post-update callbacks are called by VR-Link from within `DtExerciseConn::drainInput()` immediately after a state update message has been decoded.
* The callback must have the following function signature: `void func(DtReflectedEntity* ent, void* userData);`

**Example Code**

```
void myEntityAdditionCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // A new entity has arrived, but its ESR is empty. Ask
   // to be notified when an update has been processed.
}
```
The text describes how to work with reflected entities in DIS and HLA. It explains that the post-drain callback mechanism works independently of the protocol used.

A post-update callback function is registered with a reflected entity list using `ent->addPostUpdateCb(myPostUpdateCb, usr)`. The callback function checks if an entity type was included and updates icons accordingly.

The text also discusses timing out entities in DIS and HLA. In DIS, entities are timed out after a certain period of time (usually 12 seconds) without receiving an update message. This is done by setting a timeout interval using `DtReflectedEntityList::setTimeoutInterval()`. In HLA, there is no default timeout and entities are only removed from the list when notified by the RTI that they have left the exercise.

The text then describes how to subclass `DtReflectedEntity` and `DtReflectedEntityList` to associate additional data or functionality with a reflected entity. This involves overriding the virtual function `newReflectedEntity()` in the subclassed `DtReflectedEntityList`.

Finally, the text discusses identifying objects in DIS, HLA, and VR-Link. In DIS, entities are identified by a triplet (site:application:entity) known as an entity identifier, which can be represented using the `DtEntityIdentifier` class.

Here is the summary without any added information or assumptions:

* Post-update callback mechanism
```c
void myPostUpdateCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // ...
}

int main()
{
   ...
   ent->addPostUpdateCb(myPostUpdateCb, usr);
   ...
}
```
* Timing out entities in DIS and HLA
```c
DtReflectedEntityList::setTimeoutProcessing(bool onOff);
DtReflectedEntityList::setTimeoutInterval(double seconds);
```
* Subclassing `DtReflectedEntity` and `DtReflectedEntityList`
```c
class myReflectedEntity : public DtReflectedEntity
{
public:
   // Constructor
#if DtHLA
   myReflectedEntity(DtHlaObject* obj, DtExerciseConn* conn) : DtReflectedEntity(obj, conn)
#elif DtDIS
   myReflectedEntity(DtExerciseConn* conn,
      const DtEntityIdentifier& id, const DtEntityType& type) :
      DtReflectedEntity(conn, id, type)
#endif   
   {
      // ...
   }
};

class myREL : public DtReflectedEntityList
{
public:
   // Constructor (same for both DIS and HLA)
   myREL(DtExerciseConn* exConn) : DtReflectedEntityList(exConn) {}
#if DtHLA
   virtual DtReflectedEntity* newReflectedEntity(DtHlaObject* obj) const
   {
      return new myReflectedEntity(obj, exerciseConn());
   }
#elif DtDIS
   virtual DtReflectedEntity* newReflectedEntity(const DtEntityIdentifier& id, const DtEntityType& type) const
   {
      return new myReflectedEntity(exerciseConn(), id, type);
   }
#endif
};
```
* Identifying objects in DIS, HLA, and VR-Link
```c
class DtEntityIdentifier;
// ...
DtEntityIdentifier identifier = DtEntityIdentifier(site, application, entity);
```
In High-Level Architecture (HLA), objects can be identified in several ways:

1. Object handle: an integer or variable-length data that is unique within a federation execution.
2. Object name: a character string that can be used to identify an object, known to the Run-Time Infrastructure (RTI).
3. Other identifiers: FOMs may define additional attributes of objects, which do not have special identifier characteristics.

VR-Link provides two types to support protocol independence:

1. DtObjectId (local ID): identifies an object within an application, but cannot be used for inter-application communication.
2. DtGlobalObjectDesignator (global ID): identifies an entity in inter-application communication and can be used with PDUs, interactions, and attribute updates.

Objects can be looked up by local ID or global ID using reflected object lists. PDU, interaction, and state repository classes use mutator functions that expect global IDs and inspector functions that return global IDs.

In HLA, objects can choose a name for themselves, but the RTI might reject it. To reserve a name, call `reserveObjectInstanceName()` and then create a publisher with the reserved name.

For managing other types of objects (e.g., emitters), use subclasses of DtObjectPublisher, DtReflectedObjectList, DtReflectedObject, and DtStateRepository instead of those specific to entities.

The code examples provided are:

* `fireInter.setAttackerId(entityPub.globalId());`
* `DtReflectedEntity* ent = rel.lookup(fireInter.attackerId());`

These code examples demonstrate how to set and retrieve global IDs for objects in inter-application communication.
**Objects for Managing Entities**

The following objects are used to manage entities:

* `aggregate`
	+ `DtAggregatePublisher` (aggregatePublisher.h)
	+ `DtReflectedAggregateList` (reflectedAggregateList.h)
	+ `DtReflectedAggregate` (reflectedAggregateList.h)
	+ `DtAggregateStateRepository` (aggregateStateRepository.h)
* `designator`
	+ `DtDesignatorPublisher` (designatorPublisher.h)
	+ `DtReflectedDesignatorList` (reflectedDesignatorList.h)
	+ `DtReflectedDesignator` (reflectedDesignator.h)
	+ `DtDesignatorRepository` (designatorRepository.h)
* `emitter`
	+ `DtEmitterSystemPublisher` (emitterSystemPublisher.h)
	+ `DtReflectedEmitterSystemList` (reflectedEmitterSystemList.h)
	+ `DtReflectedEmitterSystem` (reflectedEmitterSystem.h)
	+ `DtEmitterSystemRepository` (emitterSystemRepository.h)
* `radio receiver`
	+ `DtRadioReceiverPublisher` (radioReceiverPublisher.h)
	+ `DtReflectedRadioReceiverList` (reflectedRadioReceiverList.h)
	+ `DtReflectedRadioReceiver` (reflectedRadioReceiver.h)
	+ `DtRadioReceiverRepository` (radioReceiverRepository.h)
* `radio transmitter`
	+ `DtRadioTransmitterPublisher` (radioTransmitterPublisher.h)
	+ `DtReflectedRadioTransmitterList` (reflectedRadioTransmitterList.h)
	+ `DtReflectedRadioTransmitter` (reflectedRadioTransmitter.h)
	+ `DtRadioTransmitterRepository` (radioTransmitterRepository.h)
* `gridded data`
	+ `DtGriddedDataPublisher` (griddedDataPublisher.h)
	+ `DtReflectedGriddedData` (reflectedGriddedData.h)
	+ `DtReflectedGriddedDataList` (reflectedGriddedDataList.h)
	+ `DtGriddedDataRepository` (griddedDataRepository.h)
* `environmental process objects`
	+ `DtEnvironmentProcessPublisher` (environmentProcessPublisher.h)
	+ `DtReflectedEnvironmentProcess` (reflectedEnvironmentProcess.h)
	+ `DtReflectedEnvironmentProcessList` (reflectedEnvironmentProcessList.h)
	+ `DtEnvironmentProcessRepository` (environmentProcessRepository.h)

**Managing Emitters**

Emitters are managed using the following classes:

* `DtEmitterBeamPublisher`
* `DtReflectedEmitterBeamList`
* `DtReflectedEmitterBeam`
* `DtEmitterSystemRepository`

To create an emitter, use the `DtEmitterSystemPublisher`. To inspect an emitter's state, use the `DtEmitterSystemRepository`.

**Coordinate Views**

The following coordinate views are available:

* Topographic Coordinate Views
* UTM Coordinate Views
* Cartesian Coordinate Views

`DtEntityStateRepository` sends and receives position, orientation, and their derivatives in geocentric coordinates.
VR-Link provides three view classes: DtUtmView, DtCartesianView, and DtTopoView. These views allow you to access data in different coordinate systems without having to convert it yourself.

* DtUtmView supports UTM coordinates and its constructor takes a DtEntityStateRepository.
* DtCartesianView allows the creation of a view defined by any Cartesian coordinate system. Its constructor takes a DtEntityStateRepository, a DtVector indicating the origin of the new system expressed in geocentric coordinates, and a DtDcm representing a rotation matrix that can rotate a vector from the geocentric frame to the frame we are defining.
* DtTopoView is derived from DtCartesianView and supports topographic coordinate systems. Its constructor takes a pointer to the DtEntityStateRepository and a latitude and longitude (in radians) that define the particular topographic coordinate system.

The views provide access to inspectors and mutators for location, velocity, acceleration, orientation, rotational velocity, and other properties. The inspectors and mutators are used in the same way as with the underlying DtEntityStateRepository, but the views handle the conversion between coordinate systems.

Here is an example of using a DtTopoView:
```
DtEntityPublisher entPub(...);
DtEntityStateRepository* esr = entPub.entityStateRep();
DtTopoView topoView(esr, DtDeg2Rad(36.0), DtDeg2Rad(-121.0));

topoView.setLocation(DtVector(100.0, 100.0, 0.0));
topoView.setVelocity(DtVector(10.0, 10.0, 0.0));
topoView.setAcceleration(DtVector(1.0, 1.0, 0.0));

// Topographic Euler angles - heading, pitch and roll
topoView.setOrientation(DtTaitBryan(0.0, DtDeg2Rad(10.0), 0.0));
topoView.setRotationalVelocity(DtVector(0.0, 0.10, -0.125));

// Get positions and orientations specified with respect to the topographic coordinate system
DtVector topoLoc = topoView.location();
DtVector topoVel = topoView.velocity();
DtVector topoAccel = topoView.acceleration();

// Topographic Euler angles - heading, pitch and roll
DtTaitBryan topoOrient = topoView.orientation();

// Or choose a matrix representation of orientation
DtDcm bodyToLocal = topoView.bodyToLocal();

// Rotational velocity is always in body coordinates
DtVector angVel = topoView.rotationalVelocity();
```
The examples show how to use the views to set and get data in different coordinate systems.
**Inspecting Articulated Parts Data**

The `DtArticulatedPartCollection` class provides various inspector functions to examine the state of an entity's articulated parts. These functions include:

* `partCount()`: returns the number of articulated parts
* `totalParameterCount()`: returns the number of articulation parameters
* `getParameterMetrics()`: returns a list of parameters set for a `DtArticulatedPart`
* `getParameterValue()`: returns the value of a particular parameter

To inspect the value of an articulated part's parameter, you can use the following code example:
```c
DtReflectedEntityList rel(...);
....
DtReflectedEntity* firstEnt = rel.first();
DtEntityStateRepository* esr = firstEnt->entityStateRep();
DtArticulatedPartCollection* artParts = esr->artPartList();
DtArticulatedPart* turret = artParts->findPart(DtPrimaryTurret1);
float turAz = 0.0;
if (turret)
{
   if (turret->isParameterSet(DtApAzimuth))
   {
      turAz = turret->getParameterValue(DtApAzimuth);
   }
   else
   {
      printf("Entity has no turret azimuth.\n");
   }
}
else
{
   printf("Entity has no turret.\n");
}
```
**The `DtArticulatedPart` Class**

You can get a pointer to a particular `DtArticulatedPart` by part type using the `findPart()` member function of `DtArticulatedPartCollection`. You can also iterate through the collection using iterators.

To get more detailed information about an articulated part, including non-dead-reckoned values, you can use the following code example:
```c
DtArticulatedPart* part = ...;
std::vector<DtArticulatedPart::ParameterMetric> parameterMetrics;
part->getParameterMetrics(parameterMetrics);
std::vector<DtArticulatedPart::ParameterMetric>::const_iterator 
paramIter = parameterMetrics.begin();
std::vector<DtArticulatedPart::ParameterMetric>::const_iterator 
paramEnd = parameterMetrics.end();
for(;paramIter != paramEnd; ++paramIter)
{
   int metric = *paramIter;
   float value = part->getParameterValue(metric);
}
```
**Setting Articulated Parts Data**

An articulated parts collection is empty when it is first created. To create articulated or attached parts, you can use the `getPart()` member function of `DtArticulatedPartCollection`. This creates a part of the specified type and returns it to the caller.

No additional information has been added, and all code examples are retained in full.
To attach parts in an articulated part collection, use `attachPart()` and pass in pointers to the child and parent parts. Default attachment is to the base.

Articulated parts can have parameters set using `setParameter()`. These parameters are used for network updates if not set.

Attached parts are entities attached to other entities, such as a missile on a launcher. `attPartList()` returns a pointer to an `DtAttachedPartCollection`.

Independent VR-Link objects can be used in multiple threads, but static variables and license management need to be handled carefully to avoid conflicts.

Global functions for map datum and UTM reference points (`DtSetMapDatum()`, `DtCurrentMapDatum()`, and `DtUtmInit()`) do not conflict even with multiple threads. Instead, an object representing the reference ellipsoid or UTM reference point can be passed to the coordinate's constructor.

MAK Data Logger, VR-Vantage, and VR-Forces have remote control APIs, but the preferred method is to link against libraries provided with the desired application version.

The code examples are retained in full:

* Example 4.1:
```c
DtArticulatedPartCollection* artPartCollection = myESR->artPartList();
DtArticulatedPart& turret = artPartCollection->getPart(DtPrimaryTurret1);
DtArticulatedPart& gun = artPartCollection->getPart(DtPrimaryGun1);
artPartCollection->attachPart(&gun, &turret);
```
* Example 4.2:
```c
artPartCollection->getPart(DtPrimaryTurret1).setParameter(DtApAzimuth, DtDeg2Rad(myTurretAz));
artPartCollection->getPart(DtPrimaryTurret1).setParameter(
DtApAzimuthRate, DtDeg2Rad(myTurretAzRate));
artPartCollection->getPart(DtPrimaryGun1).setParameter(DtApElevation, DtDeg2Rad(myGunElev));
```
* Example 4.12:
```c
DtEntityPublisher pub(...);
DtEntityStateRepository* esr = pub.esr();
DtAttachedPartList* attList = esr->attPartList();
// Add a single attached part, a sidewinder missile attached to station number 15.
DtAttachedPart& newPart = attList->getPart(15);
newPart->setEntityType(DtEntityType(2, 1, 225, 1, 1, 0, 0));
```
* Example 4.13 (equivalent code):
```c
DtDegMinSec latRef = {35.0, 0.0, 0.0, DtNorth};
DtDegMinSec lonRef = {122.0, 0.0, 0.0, DtWest};
DtUseMapDatum(DtWGS84);
DtUtmInit(latRef, lonRef, 1);  // this will use the global map datum
DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0);
DtUtmCoord utm(geod);   
```
Equivalent code:
```c
DtReferenceEllipsoid ellipse(DtWGS84);
DtUtmReferencePoint refUtm(latRef, lonRef, 1, 0, DtWGS84);
DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0, &ellipse);
DtUtmCoord utm(geod, &refUtm); 
```
**5 - The HLA-Specific Interface**

This chapter describes the HLA-specific interface in VR-Link.

**5.1 - Introduction to the HLA-Specific Interface**

The HLA-specific classes are described, which can be used instead of generic classes for developing applications that only use HLA.

**Code Example:**
```c
#if DtHLA
   #if DtHLA_1516
      #if DtHLA_1516_EVOLVED
         // 1516 evolved specific. #else
         // 1516 specific
      #endif
   #else
      // 1.3 specific
   #endif
#endif
```
**5.2 - Interacting Directly with the RTI**

This section describes how to interact directly with the RTI.

**5.2.1 Building Applications for Use with the RTI 1516 Specification**

The API of the RTI 1516 specification is described, including its namespace and changes from previous versions.

**Code Example:**
```c
DtExerciseConn exConn(...);
...
DtVrlRtiAmbassador* rtiAmb = exConn.rtiAmb();
rtiAmb.queryAttributeTransportationType(...);
```
**5.2.2 Federate-Initiated Services**

Federate-initiated services, such as publishObjectClass() and sendInteraction(), are invoked by making calls to the RTI ambassador's member functions.

**Code Example:**
```c
DtVrlRtiAmbassador* rtiAmb = exConn.rtiAmb();
rtiAmb.publishObjectClass(...);
```
**5.2.3 RTI-Initiated Services**

RTI-initiated services, such as discoverObject() and receiveInteraction(), are invoked when the RTI calls virtual member functions of RTI::FederateAmbassador() from within RTI::RTIambassador::tick().

**Code Example:**
```c
class MyFederateAmbassador : public DtVrlFederateAmbassador {
public:
    void discoverObject(...);
};
```
**5.2.3.1 Subclassing DtVrlFederateAmbassador**

For direct access to the data the RTI provides through RTI-initiated services, you can derive your own class from DtVrlFederateAmbassador and implement new definitions for the virtual functions in your subclass.

Please note that this summary only includes the provided code examples and does not include any additional information or explanations.
**Handling RTI-Initiated Services**

* To handle RTI-initiated services such as initiatePause(), create a subclass of DtVrlFederateAmbassador and override its virtual functions.
* The example shows how to implement initiatePause() in the MyFedAmb class.

**Telling DtExerciseConn About Your Derived Class**

* After creating a subclass of DtVrlFederateAmbassador, tell DtExerciseConn about your subclass by using the static member function setFedAmbCreator().
* A FedAmbCreator() function for the MyFedAmb class is shown in the example.

**Getting Information About the FOM**

* When an HLA DtExerciseConn is constructed, VR-Link reads the appropriate FED file and builds a database of information about the FOM.
* The FOM information is stored in a DtFom object, which can be obtained using the member function fom().
* A DtFom contains a list of object class and interaction class descriptors, represented by DtObjClassDesc and DtInterClassDesc objects respectively.

**Publishing and Subscribing to FOM Classes and Attributes**

* HLA federates must tell the RTI the set of FOM classes and attributes for which it is capable of sending data.
* This is done by publishing a class or a class with a set of attributes, as defined in the HLA specification.

The code examples provided are:

1. Implementation of initiatePause() in the MyFedAmb class:
```cpp
class MyFedAmb : public DtVrlFederateAmbassador {
public:
   virtual void initiatePause(const RTI::PauseLabel label)
      throw (RTI::FederateAlreadyPaused, RTI::FederateInternalError);
};

void MyFedAmb::initiatePause(const RTI::PauseLabel label)
      throw (RTI::FederateAlreadyPaused, RTI::FederateInternalError)
{
   // Your code to handle the pause
   ...
   DtVrlFederateAmbassador::initiatePause(label);
}
```
2. FedAmbCreator() function for the MyFedAmb class:
```cpp
DtVrlFederateAmbassador* MyFedAmbCreator()
{
   return new MyFedAmb();
}
```
3. Example code to print out the names of all object classes in the current FOM:
```cpp
// Print out the names of all object classes in the current FOM.
DtExerciseConn conn(...);
...
DtFom* fom = conn.fom();
for (DtObjClassDesc* desc = fom->firstObjClass(); desc; 
desc = fom->nextObjClass(desc))
{
   std::cout << "ClassName: " << desc->name() << std::endl;
}
```
Note that I have not added any assumptions or extra information, and all code examples are retained in full.
HLA federates must indicate to the RTI which FOM classes and attributes they are interested in receiving data from other federates. This process is called "subscribing". Most VR-Link applications do not need to do anything special for publishing and subscribing, as VR-Link takes care of it.

**Publishing Classes and Attributes**

To publish an object class with a subset of its attributes, use `DtObjClassDesc::publish()` along with the desired attribute set. This is done before creating the object publisher. If not specified, the full set of valid attributes is published by default.

Here is an example code snippet:
```c
#include <vlutil/vlStringUtil.h> // For DtToWString

// ...

#if DtHLA
   DtObjClassDesc *desc = exConn.fom()->objClassByName("BaseEntity.PhysicalEntity.Platform.GroundVehicle");
   assert(desc);
   RTI::ObjectClassHandle classHand = desc->handle();

   RTI::AttributeHandleSet hSet;
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(classHand, L"EntityType"));
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(DtToWString("Position")));
   desc->publish(hSet);
#else
   // ...
#endif
```
**Publishing Interactions**

Publishing interactions works differently from publishing objects. You either publish an interaction class with all its parameters or not at all.

**Subscribing to Classes and Attributes**

Usually, a reflected object list's constructor subscribes to object classes. A particular kind of reflected object list (e.g., `DtReflectedEntityList`) determines which FOM classes it is interested in and then subscribes to each of those classes.

Here is an example code snippet:
```c
// ...

#if DtHLA
   DtList handleList;
#endif

handleList.add(new RTI::ObjectClassHandle(exConn.rtiAmb()->getObjectClassHandle("BaseEntity.PhysicalEntity.Platform.GroundVehicle")));
handleList.add(new RTI::ObjectClassHandle(exConn.rtiAmb()->getObjectClassHandle("BaseEntity.PhysicalEntity.Platform.Munition")));

// Create the Reflected Entity List
DtReflectedEntityList(&exConn, &handleList);

#if DtHLA_1516
   // Clean up handles
   for (DtListItem *item = handleList.first(); item;)
   {
      DtListItem* next = item->next();
      RTI::ObjectClassHandle *hand = static_cast<RTI::ObjectClassHandle *>(item->data());
      handleList.remove(item);
      delete hand;
      item = next;
   }
#endif
```
By default, when VR-Link subscribes to an object class, it subscribes to all attributes of the class.
**Subscribing to Object Classes**

To subscribe to only a subset of an object class's attributes, use the `DtObjClassDesc::subscribe()` function instead of `publish()`. Note that direct RTI service usage is not recommended as it will result in subscribing to all attributes.

**Interaction Classes**

Subscription to interaction classes typically occurs when registering a callback function with a VR-Link interaction class. This informs VR-Link about the interested classes and passes this information to the RTI.

**Managing HLA Objects**

HLA objects are represented by instances of the `DtHlaObject` class. Most entity management functionality is available through VR-Link's protocol-independent layer, making it unnecessary for applications to interact with `DtHlaObjects`. However, there are always `DtHlaObjects` behind the scenes.

The `DtHlaObjectManager` class maintains a list of all reflected and locally simulated HLA objects. This list can be accessed through its member function `allHlaObjects()`, which returns a `DtList` of pointers to all current `DtHlaObjects`.

**HLA Object Manager Functions**

The `DtHlaObjectManager` class provides several functions for managing HLA objects, including:

* `hlaObject()` to get a pointer to the managed object
* `allHlaObjects()` to get a list of all current `DtHlaObjects`
* `registerObjects()` and `discoveredObjects()` to register or discover HLA objects by ID or name

**DtHlaObject Member Functions**

The `DtHlaObject` class has additional member functions that provide more specialized information, including:

* `attributesNeededByFederation()`: returns the set of attributes subscribed to by remote federates
* `classNeededByFederation()`: tells whether the class has been subscribed to at all by remote federates
* `requestedAttributes()`: returns the set of attributes requested by another federate through the RTI
* `lastSimTimeUpdateReceived()`: returns the time of the last attribute update received for this object

**Finding Out when HLA Objects are Discovered and Removed**

For protocol-independent methods of receiving notification about the discovery and removal of reflected objects, refer to 4.6.7 Learning when Entities Join or Leave an Exercise.

The provided code example demonstrates how to print the IDs of all objects currently being simulated:
```c
#include <vl/rtiCompatibility.h>
DtExerciseConn exConn(...);
...
// Subscribe to various object classes, process discoverObjects and
// reflectAttributeValues calls. (This is usually achieved simply by
// creating a DtReflectedObjectList.) ...
DtHlaObjectManager* objMgr = exConn.hlaObjectManager();
const DtList& allObjects = objMgr->allHlaObjects();
for (DtListItem* item = allObjects.first(); item; 
   item = item->next())
{
   // Cast the generic void* to a DtHlaObject*
   DtHlaObject* obj = (DtHlaObject*) item->data();
   std::cout << "id: " << obj->objectId() << std::endl;
}
```
This code snippet retrieves the list of all `DtHlaObjects` using the `allHlaObjects()` function and then iterates over the list to print the IDs of each object.
The article discusses various methods for intercepting reflected attribute values, object additions/removals, and state updates in the HLA (High-Level Architecture) framework. These methods are useful when working with DtHlaObjects and DtReflectedObjectLists.

**Discovering Objects**

To be notified when an object is discovered, regardless of class, you can register a "discoverObject" callback function with the DtExerciseConn using `addDiscoverObjectCallback()` or `addDiscoverObjectCallback(RTI::ObjectClassHandle(0))` in RTI 1.3 or RTI 1516 respectively.

**Removing Objects**

To be notified when an object is removed, you can register a "removeObject" callback function with the DtHlaObject using its `addRemoveObjectCb()` member function or with the DtExerciseConn using `addRemoveObjectCallback()` and passing an object ID to specify which object you are interested in.

**Intercepting Reflected Attribute Values**

To intercept reflected attribute values, you can register a "postUpdate" callback with a DtReflectedObject or use the alternate mechanism that works at the level of DtHlaObjects. The latter method is useful when not all objects are managed by a DtReflectedObjectList.

**Code Examples**

* Callback functions:
```cpp
void myDiscoverObjectCb(DtHlaObject* obj, void* usr);
void myRemoveObjectCb(DtHlaObject* obj, void* usr);
void postReflectCb(const DtStateMsg& msg, DtHlaObject* obj, void* usr);
```
* Registration and unregistration functions:
```cpp
addDiscoverObjectCallback(RTI::ObjectClassHandle(0));
removeDiscoverObjectCallback();
addRemoveObjectCb();
removeRemoveObjectCb();
addRemoveObjectCallback(object ID);
removeRemoveObjectCallback();
```
* Example of using the netdumpHLA application to intercept reflected attribute values:

```cpp
// Register discoverObject callback for all objects
DtExerciseConn.addDiscoverObjectCallback(RTI::ObjectClassHandle(0));

// Within discoverObject callback, register postReflect() callback with each DtHlaObject
void myDiscoverObjectCb(DtHlaObject* obj, void* usr) {
    obj->addPostReflectCb(postReflectCb);
}

// Within postReflect() callback, print the contents of the message
void postReflectCb(const DtStateMsg& msg, DtHlaObject* obj, void* usr) {
    // Print the contents of the message
}
```
**HLA Ownership Management**

The HLA (High-Level Architecture) ownership management service allows federates to transfer responsibility for sending updates for particular object attributes from one federate to another.

**DtObjectPublisher and DtReflectedObjects**

* Both DtObjectPublishers and DtReflectedObjects have member functions called `hlaObject()` that return the `DtHlaObject` being published or reflected.
* A `DtObjectPublisher` is responsible for sending updates for owned attributes, while a `DtReflectedObject` collects attribute updates sent by owners of various attributes.

**Ownership Management Examples**

1. Acquiring Objects: (Example code not provided)
2. Divesting Attributes: (Example code not provided)
3. Giving Up Attributes if Requested: (Example code not provided)
4. Acquiring Attributes if Offered: (Example code not provided)

**Reflecting Locally-Generated Updates**

* When reflecting is on, locally-generated objects and interactions are processed by VR-Link.
* The reflected object's state repository includes values for all attributes, regardless of whether they were sent locally or remotely.

**Code Examples Not Provided**

The data provided does not include any code examples.
When dealing with HLA objects and attribute updates, there are scenarios where multiple federates may send updates or local federate sends updates. When a publisher's destructor is called, VR-Link deletes the corresponding HLA object if the local federate owns the `privilegeToDelete` attribute. However, this behavior can be changed using `setDeleteObjInDtorFlag()`.

If a remote federate deletes an HLA object, the `DtHlaObject` pointer becomes NULL and subsequent ticks are no-ops. To notify when an object is deleted, you can register a `removeObject()` callback with the `DtHlaObject` using its `addRemoveObjectCb()` function or register an `objectRemoval()` callback for the corresponding `DtReflectedObject` with your `DtReflectedObjectList`.

For ownership management, it's recommended to call `setReflecting()` on `DtExerciseConn`. If not, a `DtReflectedObject` may only process updates generated by remote federates. Creating a publisher and updating attributes does not result in the creation of a corresponding reflected object unless self-reflecting is turned on.

`DtHlaObject` has member functions for ownership management: `acquireObject()`, `divestObject()`, `unconditionalDivest()`, `negotiatedDivest()`, `acquireAttributes()`, `cancelNegotiatedDivest()`, and `cancelAcquireAttributes()`. VR-Link's ownership-related functions should be used instead of the RTI's to ensure consistency.

Three DtOwnershipHandler classes are provided: `DtDefaultOwnershipHandler`, `DtPartialOwnershipHandler`, and `DtRprOwnershipHandler`. These classes allow for callbacks to notify when an acquisition or divestiture occurs, as well as optional acceptance or denial of requests. The `DtDefaultOwnershipHandler` is built for simplicity, while the other two provide extra functionality.

All code examples are retained in full without any changes.
**Ownership Management**

There are two ways to register an ownership handler: globally using `setDefaultOwnershipHandler` on a `DtExerciseConn`, or individually using `setOwnershipHandler` on a `DtHlaObject`.

**Examples**

* **Acquiring Objects**: Create a reflected object list, create a publisher for the object, and call `acquireObject()` on the `DtHlaObject`. Attach an ownership handler to the object to receive notifications when acquisition succeeds.
```cpp
void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}

// Create the reflected entity list
DtReflectedEntityList rel(...);
...
// Find the entity you are interested in, and grab its DtHlaObject
DtReflectedEntity* ent = rel.lookup(...);
DtHlaObjectWithStateRep* obj = ent->hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
// Create a publisher for the object
DtEntityPublisher pub(obj, obj->exerciseConn());
// Initiate the acquisition. obj->acquireObject();
```
* **Divesting Attributes**: Create a publisher and call `unconditionalDivest()` or `negotiatedDivest()` on the `DtHlaObject`. Attach an ownership handler to the object to receive notifications when divestiture succeeds.
```cpp
void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}

// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
// Initiate the divest
```
* **Giving Up Attributes if Requested**: Create a publisher and create an ownership handler that accepts all divestiture actions.
```cpp
void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}

// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
```
* **Acquiring Attributes if Offered**: Create a default ownership handler and assign it to an exercise connection. Set the default acquisition action to always accept all acquisitions.
```cpp
void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}

DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
myExerciseConnection->setOwnershipHandler(&defaultHandler);
```
**Data Distribution Management (DDM)**

There are two ways to use DDM with VR-Link:

1. Use the DDM scheme implemented by VR-Link's publishers.
2. Pass in your own DDM region and manipulate it manually.

Note that this summary only covers the sections on Ownership Management and Data Distribution Management, and does not include the remaining sections on Geographic DDM, publishing, reflecting, interactions with regions, and using DDM without VR-Link's geographic implementation.
**Geographic DDM**

* The default VR-Link DDM scheme uses a space named BenchmarkGeographicSpace with two dimensions, X and Y, corresponding to longitude and latitude.
* The `DtEntityPublisher` and `DtAggregatePublisher` can create their own DDM regions on instantiation and update them based on entity location and velocity.
* To enable geographic DDM, set `exConn.setUseGeographicDdm(true)` in the exercise connection.
* The region bounds may not exceed those specified by the playbox. The default values cover the entire Earth (-90 to 90 degrees latitude, and -180 to 180 degrees longitude). To change them, specify the `lowerBound` and `upperBound` coordinates.

**Publishing Using Geographic DDM**

* To publish with a geographic region, set `exConn.setUseGeographicDDM(true)` in the exercise connection.
* When an entity or aggregate publisher is created, the object is published using a region. This region can be accessed and passed to other publishers to allow them to publish in the same region.

**Reflecting Using Geographic DDM**

* Create a geographic region and pass it into a reflected list to subscribe to a class with region.
* Use `DtGeodeticRegionSP` to create a shared pointer to the region.
* To subscribe to multiple regions, use an STL vector of `DtGeodeticRegionSPs` and pass it into the reflected list constructor.

**Interactions with Regions**

* VR-Link allows sending and receiving interactions in regions. The `addCallback` member function of each interaction can take a region shared pointer.
* Use `exConn.sendStampedWithRegion` to send an interaction with region.

**Using DDM without VR-Link's Geographic Implementation**

* Create any type of region using the `DtDDMRegion` class.
* Specify the space (for HLA 1.3) and dimensions, and `DtDDMRegion` will create an RTI region that can be manipulated using normalized values.

**Using the DtInteraction Class**

* The `DtInteraction` class is defined in `interactionHLA.h`.
* Use `setExConn` to set the associated `DtExerciseConn` and `DtInterClassDesc`. This must be done before many of `DtInteraction`'s member functions can return meaningful results.
The `setExConn()` function in the `DtInteraction` class allows the user to specify a current exercise connection (exConn) and class descriptor for an interaction. If no argument is provided, the subclass will choose a default interaction class. The `VR-Link` library typically calls `setExConn()` automatically when sending or receiving interactions.

The `setExConn()` function takes two arguments: `exConn`, which is the current exercise connection, and `classDesc`, which is the class descriptor. If `classDesc` is omitted, the interaction will choose a default FOM class to use for sending.

When sending an interaction, `VR-Link` calls `setExConn()` on the interaction before sending it, passing itself as the `exConn` argument and NULL as the `classDesc` argument, allowing the interaction to choose a default FOM class. When receiving an interaction, `VR-Link` calls `setExConn()` on the interaction after creating the instance, passing the exercise connection and interaction class of the received interaction.

The `DtInteraction` class has several member functions that require a valid current exercise connection and class descriptor:

* `interactionClassHandle()`: returns the current interaction class's handle
* `interactionClassName()`: returns the current interaction class's name
* `numParameters()`: returns the number of parameters in the current interaction class
* `neededByFederation()`: returns whether the class has been subscribed to by remote federates

The `DtInteraction` class also has several print-related functions:

* `print()`: prints information about the FOM class being used for the object, including the name and parameter values
* `printHeader()`: prints information about the FOM class being used for the object
* `printParams()`: prints the set of parameters included in the interaction message, along with raw parameter values if specified
* `printData()`: a pure virtual function that is implemented by derived classes to print specific data contained in the interaction

The `DtExerciseConn` class uses the `setExConn()` function to initialize interactions when receiving an interaction from the RTI.

Generic attributes and parameters are a way of accessing extended information in the FOM that is not normally supported. They can be accessed using the `getAttributeByName()` or `getParameterByName()` functions, which return the value of the attribute or parameter as a byte array. There are two ways to enable generics: enabling them globally in the initializer or enabling them for specific classes.

Note that generic attributes do not have type safety and must be encoded and decoded correctly by the user.
The section discusses general HLA issues related to time stamps, registering and responding to synchronization points, and time management.

**5.10.1 Time Stamps**

* Set and inspect HLA DtStateMsg or DtInteraction's time stamp using `setTimeStamp()` and `timeStamp()` functions.
* VR-Link's sending functions encode the time in the "tag" string argument to RTI's sendInteraction() and updateAttributeValue() calls.

**5.10.2 Registering and Responding to Synchronization Points**

* The HLA DtExerciseConn class can register synchronization points and user-defined callbacks for synchronization points.
* Example code:
```c
exConn.registerSynchronizationPoint("point1");
exConn.addFederationSynchedCb("point1", userFunction, NULL);
```
**5.10.2.1 Responding to Synchronization Points Automatically**

* VR-Link applications automatically respond to announced synchronization points by default.
* Disable automatic response by calling `exConn.setReplyingToSynchronizationPoints(false)`.

**5.10.3 Time Management**

* VR-Link supports HLA Time Management, which allows federates to synchronize and order events with a timeline maintained by the RTI.
* Federation Time (FedTime) is the managed simulation time for an exercise.

**5.10.3.1 Federation Time**

* Federation Time can be different for different federates at any point in the simulation.
* Example calls:
```c
DtExerciseConn exConn(...);
...
```
Note: The code examples are provided as-is, without modification or addition of extra information.
**Time Regulation**

* `exConn.rtiAmb()->enableTimeRegulation(mySuggestedFedTime, myLookAhead);`: Enables time regulation with a suggested FedTime and look-ahead.
* `exConn.rtiAmb()->enableTimeConstrained();`: Enables time-constrained mode.
* `exConn.rtiAmb()->disableTimeConstrained();`: Disables time-constrained mode.
* `exConn.rtiAmb()->timeAdvanceRequest(RequestedFedTime);`: Requests a specific FedTime for the federate.
* `exConn.rtiAmb()->disableTimeRegulation();`: Disables time regulation.

**Sending Time Stamp Order (TSO) Messages**

* `exConn.setSendFedTime(true);`: Enables sending TSO messages with a FedTime attached to outgoing messages.
* When `sendFedTime` is true, all messages are sent with a TSO. When it's false (default), messages are sent in read order.

**Receiving TSO Messages**

* VR-Link handles incoming TSO messages transparently and ensures delivery at the correct FedTime.

**Using Callbacks**

* The RTI provides callbacks for updating FedTime, enabling time regulation, and other events.
* Examples of callback functions:
	+ `timeAdvanceRequestCb(const RTI::FedTime &theFedTime, void *userData)`: Called when a time advance request is granted or denied.
	+ `timeConstrainedEnabledCb(const RTI::FedTime &theFedTime, void *userData)`: Called when the federate becomes time-constrained.

**Converting FedTime to DtTime**

* The RTI provides conversion functions for converting between `RTI::FedTime` and `DtTime`.
* Example of conversion:
	+ `RTI::FedTime *fedTimePtr = (*DtExerciseConn::vrlTimeToFedTimeConverter()) (myDtTimeVariable);`

**VR-Link Calls to RTI Services**

* The following table lists Federate-initiated services that may be called by VR-Link:
	+ Create Federation Execution
	+ Destroy Federation Execution
	+ Join Federation Execution
	+ Resign Federation Execution
	+ Publish Interaction Class
	+ Publish Object Class
	+ Subscribe Interaction Class
	+ Subscribe Object Class Attributes
	+ Unsubscribe Interaction Class
	+ Unsubscribe Object Class

Note that I have retained all code examples in full, without modifying or adding any information.
**RTI Services**

The following services are provided by RTI:

1. deleteObjectInstance: Invoked from an object publisher's destructor.
2. localDeleteObjectInstance: Invoked only from DtReflectedObjectList::removeObject(), which is not typically called by applications.
3. registerObjectInstance: Invoked from an object publisher's constructor.
4. requestClassAttributeValue-Update: Invoked from a reflected object list's constructor, if the list's requestClassUpdate flag is true (the default).
5. requestObjectAttributeValue-Update: If DtReflectedEntityList's (or any other reflected object list's) requestObjectUpdate flag is true (the default), then this service is invoked shortly after each reflected object is discovered and created.
6. sendInteraction: Invoked from within DtExerciseConn::send() or sendStamped().
7. sendInteractionWithRegion: Invoked from within DtExerciseConn::send() or sendStamped() if using DDM.
8. updateAttributeValues: Invoked from an object publisher's tick() function, if we judge that data needs to be sent based on update conditions and remote subscriptions and requests.

**RTI-initiated Services with Non-NULL Definitions**

The following RTI services are initiated by the VR-Link:

1. startRegistrationForObjectClass
2. stopRegistrationForObjectClass
3. turnInteractionsOff
4. turnInteractionsOn
5. discoverObjectInstance
6. provideAttributeValueUpdate
7. receiveInteraction
8. reflectAttributeValues
9. removeObjectInstance
10. turnUpdatesOffForObjectInstance
11. turnUpdatesOnForObjectInstance

**Ancillary Services**

The following ancillary services are called at various points within VR-Link:

1. getAttributeHandle
2. getAttributeName
3. getInteractionClassHandle
4. getObjectClassHandle
5. getObjectInstanceName
6. getParameterHandle
7. getParameterName

**Interoperability Between HLA 1.3 and IEEE 1516 Federates**

The MAK RTI supports run-time interoperability between HLA 1.3 federates and IEEE 1516 federates. Federates that use Federation Management, Declaration Management, Object Management, Time Management, and Data Distribution Management services can interoperate across the 1.3-1516 boundary. However, there are some restrictions and requirements to consider:

* MOM is not currently supported across the 1.3-1516 boundary, and must be disabled.
* Ownership management should be avoided.
* Object names supplied by 1516 federates must allow conversion from wide char representation to narrow character representation (ASCII).
* User-supplied tags are restricted to the 1.3 string format.
* FOM format consistency is necessary due to differences in naming conventions between HLA 1.3 and IEEE 1516.

All code examples have been retained in full, without any additions or assumptions.
The RTI (Runtime Infrastructure) and federates may not recognize classes intended to be the same, leading to failures in object discovery. VR-Link has been designed with FOM ( Federation Object Model) agility in mind to address this issue.

FOM agility is implemented through a FOM Mapper, which enables VR-Link to work with different versions of the RPR FOM or unrelated FOMs. The architecture includes a top-level FOM-independent API and a FOM Mapping layer that routes and converts data between the two.

There are two categories of FOM modifications: those that contain only concepts present in the VR-Link API, and those that include new concepts not present in the VR-Link API. For the first category, developers can switch between FOMs without modifying application code written to the top-level API. For the second category, a two-step process is required: extending the top-level API by deriving new classes from base state repository, publisher, reflected object, or reflected object list classes, and then creating mappings from arbitrary FOM representations of these concepts to the new API extensions.

The provided code examples are:

6.1 - Introduction to FOM Agility
6.2 - FOM Mapping Overview
6.3 - FOM Mapping Information Required By VR-Link's API
6.4 - FOM Mapping Details
6.5 - Setting Up a FOM Mapper's Class Mappings
6.6 - Creating Instances of DtInteraction
6.7 - Attribute and Parameter Encoding and Decoding
6.8 - Choosing a DtFomMapper
6.9 - VR-Link FOM Mapping and Extension Examples

Note: The provided data includes links to additional pages that explain how VR-Link's architecture enables FOM agility and how developers can extend or configure VR-Link to work with various FOMs.
The HLA (High-Level Architecture) implementation of VR-Link's top-level API requires FOM ( Federation Object Model) mapping information for various classes. These classes include publishers, reflected object lists, interaction instances, and interaction classes.

FOM Mapping Information Required by VR-Link's API

* Class mappings: Publishers need to know which FOM object class to choose to represent a locally simulated object.
* Attribute and parameter encoding and decoding: Publishers need to know how to decide whether each attribute needs to be sent during a call to tick() and how to encode values from its state repository into outgoing attribute updates.

A central place called DtFomMapper provides the FOM mapping information for these top-level objects. Each DtExerciseConn creates or is passed a DtFomMapper on construction, which can be overridden by application code.

DtFomMapper

* A central repository for FOM mapping information.
* Top-level API classes call DtFomMapper functions to obtain FOM mapping information.
* Examples of functions include:
	+ chooseObjectClass(): Returns the name of the FOM object class to use to represent an object being managed by a particular type of DtObjectPublisher.
	+ setObjectClassToChoose(): Sets up a mapping between a particular subclass of DtObjectPublisher and a particular FOM object class.

Setting Up a FOM Mapper's Class Mappings

* Table of Contents:
	1. Choosing an Object Class to Publish
	2. Mapping a Single FOM Class to a Publisher
	3. Subscribing to Object Classes
	4. Subscribing to Interaction Classes

Choosing an Object Class to Publish

* A DtObjectPublisher asks the FOM Mapper for the name of the FOM object class to use to represent its locally simulated object by calling chooseObjectClass().
* The publisher passes the name of its own VR-Link C++ publisher class, for example, DtEntityPublisher or DtAggregatePublisher.

Mapping a Single FOM Class to a Publisher

* Create an association using DtFomMapper::setObjectClassToChoose() if one FOM class should always be chosen for a particular kind of publisher.
* For example:
	+ fomMapper->setObjectClassToChoose("DtAggregatePublisher", "BaseEntity.AggregateEntity");

Mapping Multiple FOM Classes to A Publisher

* Associate a class choosing function with the name of a VR-Link class, rather than just a single object class, using setObjectClassChooser().

No additional information or code examples have been added.
The FOM ( Federated Object Model ) mapper class provides several functions for mapping between VR-Link classes and FOM classes.

1. Choosing an Object Class:
   - The `setObjectClassChooser()` function is used to associate a class choosing function with a VR-Link publisher class name.
   - The class choosing function takes three arguments: the VR-Link publisher class name, a connection object (`DtExerciseConn* conn`), and user-defined data (`void* usr`).
   - For example, `fomMapper->setObjectClassChooser("DtEntityPublisher", myClassChooser);`

2. Subscribing to Object Classes:
   - The `objectClassNames()` function returns the names of FOM classes to subscribe to.
   - The `setObjectClass()` and `setObjectClasses()` functions are used to specify which FOM classes to manage.

3. Choosing an Interaction Class to Publish:
   - The `chooseInteractionClass()` function is used by interactions (such as `DtExerciseConn::send()`) to ask the FOM Mapper for a name of a FOM class to use.
   - The interaction instance passes a reference to itself and the VR-Link C++ interaction class name can be obtained from an interaction instance using its `name()` function.

4. Subscribing to Interaction Classes:
   - The `addCallback()` function is used by interactions to request subscriptions to FOM classes.
   - The `interactionClasses()` member function returns the set of FOM classes to subscribe to, which are determined by setting `setInteractionClass()` or `setInteractionClasses()`.
   - For example, `fomMapper->setInteractionClass("DtFireInteraction", "WeaponFire");` and `fomMapper->setInteractionClasses(classNames);`

5. Creating Instances of DtInteraction:
   - The `createInteraction()` member function of the FOM Mapper's `interactionFactory()` is used to create an instance of a DtInteraction subclass.
   - This is achieved by adding or changing interaction factory's mappings using its `addCreator()` member function, passing a FOM class name and an interaction creation function such as a DtInteraction subclass's static `create()` member function.

Note: The provided information includes code examples for setting up the associations between VR-Link classes and FOM classes.
**Attribute and Parameter Encoding and Decoding**

A DtFomMapper contains information about how to encode and decode individual attributes and parameters, which is necessary for converting between RTI messages in FOM representation and VR-Link's DtStateRepositories and DtInteractions.

**Encoders and Decoders**

The core of VR-Link's FOM Mapping functionality are the encoder and decoder classes:

* DtHlaStateEncoder
* DtHlaStateDecoder
* DtInteractionEncoder
* DtInteractionDecoder
* Their subclasses

These classes use a table-driven approach to attribute encoding and decoding.

**Functions for Encoding and Decoding**

Decoders are tables of decoding functions, one per FOM attribute or parameter. Each function is responsible for decoding the attribute or parameter it has been associated with. Encoders contain tables of encoding functions, and also tables of checking functions (for objects) that evaluate update conditions for individual attributes.

**Encoder and Decoder Factories**

Encoder factories and decoder factories are tables of encoders and decoders, one table per object or interaction class. A DtFomMapper has an encoder factory and a decoder factory for both objects and interactions. These factories allow you to register your own encoding, decoding, and checking functions for a particular attribute or parameter.

**Code Examples**

No code examples are provided in this section.
**Decoding Interactions**

The `DtInteractionDecoder::decode()` function takes an RTI representation of an interaction message (PHVPS) and a pointer to a `DtInteraction` object. It iterates through the parameters in the PHVPS, calls the parameter decoding function associated with each parameter, and fills out the `DtInteraction` object.

Example:
```c
void decodeRateOfFire(DtFireInteraction* inter, const RTI::ParameterHandleValuePairSet& pvlist, int index)
{
   RTI::ULong length = 0; 
   DtNetU16* netVal = (DtNetU16*) params.getValuePointer(index, length);
   int nativeVal = (DtU16) *netVal;
   inter->setRate(nativeVal);
}
```
**Decoding Object State Updates**

The `DtHlaStateDecoder::decode()` function takes a `DtStateMsg` (wrapper around AHVPS) and a pointer to the `DtStateRepository`. It walks the list of attributes in the message, calls the attribute decoding function associated with each attribute, and decodes the message into the `DtStateRepository`.

Example:
```c
void decodePosition(DtEntityStateRepository* stateRep,
   const RTI::AttributeHandleValuePairSet& attrs, int index)
{
   RTI::ULong length = 0;
   DtNet64Vector* netVal = (DtNet64Vector*) 
      attrs.getValuePointer(index, length);
   stateRep->setLocation((DtVector) *netVal);
}
```
**Encoding Interactions**

The `DtInteractionEncoder::encode()` function takes a `DtInteraction` instance and a PHVPS to fill out with the FOM representation of the interaction data. It iterates through the parameters in the `DtInteraction`, calls the encoding function associated with each parameter, and fills out the PHVPS.

Example:
```c
void encodeRateOfFire(
   const DtFireInteraction& inter,
   RTI::ParameterHandleValuePairSet* params,
   RTI::ParameterHandle paramHandle)
{
   DtNetU16 netVal = (DtNetU16) inter.rate();
   params->add(paramHandle, (char*) &netVal, sizeof(DtNetU16));
}
```
**Encoding Objects**

The `DtHlaStateEncoder` contains tables of encoding functions and checking functions to determine which attributes need to be sent. When a publisher's tick() function calls the `encode()` function, it passes five arguments: the current state of the object, the as-seen-by-remote state repository, the set of subscribed attributes, the set of attributes that should be sent now, and a pointer to the `DtStateMessage`.

The `encode()` function determines whether each published attribute needs to be included in the update message or not, and if so, calls the encoding function associated with the attribute.

Note: The provided code examples are included in full.
The data describes functions related to encoding, decoding, and checking of FOM (Field-of-Move) data. The main points are:

1. The `encodePosition` function takes three parameters: a state repository containing current state, an attribute value pair set, and an attribute handle. It encodes the position into the attribute value pair set.

2. Checking functions take two state repositories as arguments to compare the current state with the state as seen by remote federates. An example of such a function is `needDamageState`, which checks if the damage state has changed since it was last sent.

3. The FOM Mapper provides instances of encoder, decoder, or both factories for use with its FOM class. There are four types of factories: `DtStateDecoderFactory`, `DtStateEncoderFactory`, `DtInteractionDecoderFactory`, and `DtInteractionEncoderFactory`. These factories have member functions to add encoders and decoders, create new instances, and return pointers to existing instances.

4. The factories can be used to register custom encoding and decoding functions for a particular FOM class or all of its subclasses. For example, registering a new encoding function for the Position attribute of the BaseEntity RPR FOM class and all of its subclasses using `addAttributeEncoder`.

5. The optional second argument in some factory functions determines what should happen when there is no encoder or decoder associated with a particular FOM class.

Here are the code examples:

```
void encodePosition(
   const DtEntityStateRepository& stateRep,
   RTI::AttributeHandleValuePairSet* avList,
   RTI::AttributeHandle attrHandle)
{
   DtNet64Vector netVal = (DtNet64Vector) stateRep.location();
   avList->add(attrHandle, (char *) &netVal, sizeof(DtNet64Vector));
}

bool needDamageState(
   const DtEntityStateRepository& stateRep,
   const DtEntityStateRepository& asSeenByRemote)
{
   return (stateRep.damageState() != asSeenByRemote.damageState()) 
      ? true : false;
}

RTI::InteractionClassHandle handle = 
   rtiAmb->getInteractionClassHandle("WeaponFire");
DtInteractionDecoder* fireDecoder = 
   fomMapper->interactionDecoderFactory()->decoder(handle);
fireDecoder->addDecoder("RateOfFire", myFunc);

fomMapper->stateEncoderFactory()->addAttributeEncoder("BaseEntity", "Position", myFunc, true);
```

I hope this summary meets your requirements. Let me know if you have any further questions or need clarification on anything.
When constructing a `DtExerciseConn`, you must choose a FOM Mapper for it to use. You can do this by:

* Passing an instance of a `DtFomMapper` to the `DtExerciseConn` constructor.
* Passing the name of a shared library containing a function that creates the desired FOM Mapper to the `DtExerciseConn` constructor.
* Setting the fallback FOM Mapper creation function using `DtExerciseConn`'s static `setFomMapperCreator()` function.
* Allowing `DtExerciseConn` to create an empty FOM Mapper and configuring it after the constructor returns.

The following constructors are available:

* `DtExerciseConn(const char*, const char*, DtFomMapper*)`: takes an instance of a `DtFomMapper`.
* `DtExerciseConn(const char*, const char*, const char*, const char*, void*)`: takes the name of a shared library containing a function that creates the desired FOM Mapper.

When using the second constructor, the `dsoName` argument must be the name of a shared library (DSO or DLL) that contains definitions for the following functions:

* `DtFomMapper* DtCreateFomMapper(void*)`: called by `DtExerciseConn` after it opens the shared library.
* `void DtDeleteFomMapper(DtFomMapper*)`: a function to delete the FOM Mapper instance.

The default fallback FOM Mapper creation function is `DtEmptyFomMapper::create()`, which creates an instance of `DtEmptyFomMapper`. This function can be set using `DtExerciseConn`'s static `setFomMapperCreator()` function.
**6.8.4 Configuring a FOM Mapper After Constructing a DtExerciseConn**

A `DtFomMapper` can be configured using its mutator functions after constructing a `DtExerciseConn`. This allows adding mappings to a `FOM Mapper` that has been passed to the `DtExerciseConn` or constructed from a shared library. If desired, all FOM configuration can be done after the `DtExerciseConn` constructor returns.

**6.8.5 Using Different RPR FOM Versions**

VR-Link supports different versions of the RPR FOM using `DtRprFomMapper`, which self-registers mappings for RPR FOM classes, attributes, and parameters. The `DtRprFomMapper` constructor takes an optional version argument indicating which version to use.

Example:
```c
DtExerciseConn conn("VR-Link", "MyAppName", new DtRprFomMapper(2.0017));
```
**6.8.6 Deriving Your Own DtFomMapper**

A custom `DtFomMapper` can be created by deriving a subclass from `DtEmptyFomMapper`. The subclass should override the `init()` function to register mapping information and initialize factories and lists.

Example:
```c
class MyFomMapper : public DtEmptyFomMapper {
public:
    virtual void init(DtExerciseConn* exerciseConn) {
        // Register mapping information here
        // Initialize factories and lists here
    }
};
```
**6.9 - VR-Link FOM Mapping and Extension Examples**

VR-Link includes examples of creating FOM Mappers and extending the top-level API to work with new FOM concepts in several subdirectories of `./examples`. The `myFomMap` example demonstrates how to create a FOM Mapper for a new FOM and put it into a shared library. The `addAttr` example shows how to extend the RPR FOM by adding new attributes or parameters to existing classes.

These examples are available in the `./examples` directory of the VR-Link installation.
**Extending VR-Link with New Interactions and Objects**

The testInter and testObj examples demonstrate how to add new interactions and object classes to the Federation Object Model (FOM), including extending VR-Link's API. The testSimpInter example shows an alternative method of working with new interaction classes that does not use VR-Link's encoder and decoder classes.

**VR-Link Code Generator**

The VR-Link Code Generator is a tool for extending VR-Link to work with different FOMs, particularly those that are dissimilar from the RPR FOM. It generates code based on a FOM definition file (OMT or XML) and produces C++ code along with a project file or Makefile.

**Code Generator Limitations**

The Code Generator is designed to assist customers with extending VR-Link for HLA, but it may not be able to fully generate the code required for complex FOMs. In such cases, the generated code will require minor hand editing.

**Installing the VR-Link Code Generator**

The VR-Link Code Generator is installed as part of the VR-Link package in ./bin.

Note: The provided text includes a table of contents and separate sections for each topic, but I have not included them in this summary. If you would like me to reorganize the information into a more traditional format, please let me know!
**Starting the VR-Link Code Generator**

The VR-Link Code Generator can be started from the command line, script, batch file, or Windows Start menu. The command-line syntax is:

`./bin/vrlcodegenerator [-p <string>] [-I <string>] [-P <string>] [-F <string>] [-O <string>] [-A] [-G] [--] [-v] [-h]`

The options include:

* `-p <string>`: specifies a prefix for generated class names
* `-I <string>`: specifies the include directory for generated code
* `-P <string>`: specifies the project file
* `-F <string>`: specifies a FOM definition file (accepted multiple times)
* `-O <string>`: specifies the output directory for generated code
* `-A`: generates all objects in the FOM definition
* `-G`: performs file generation without opening the GUI
* `--ignore_rest`: ignores the rest of the labeled arguments following this flag
* `-v`: displays version information and exits
* `-h`: displays usage information and exits

**The VR-Link Code Generator Window**

The VR-Link Code Generator window has two panes. The left pane lists objects and interactions contained in the FOM definition file, while the right pane lists objects and interactions for which code will be generated.

**Code Generator Projects**

* Creating a Project: Choose File -> New Project or click the New Project button to create a new project.
* Loading a Project: Choose File -> Load Project or click the Load Project button to load an existing project.
* Saving a Project: Choose File -> Save Project or click the Save Project button to save a project.

**Using the Code Generator**

* Loading a FOM Definition File: Choose File -> Import FOM to load a FOM definition file in XML or OMT format.
* Selecting the Objects and Interactions to Generate: Select objects and interactions using one of the following methods:
	+ Click on an item
	+ Shift-click to select contiguous items
	+ Ctrl-click to select non-contiguous items
	+ Choose Edit -> Select All to select all items
* Removing Classes from the Objects to Generate List: Select a class in the list and click the left-pointing arrow to remove it.
* Customizing Encoders and Decoders: The Code Generator allows customization of encoders and decoders for object attributes and interaction parameters before generating code.
To customize an object or interaction class's encoders and decoders:

1. Double-click the class whose encoders and decoders you want to customize, or right-click and select Customize.
2. The Customize Encoders and Decoders window opens, listing the attributes for the object or interaction.
3. Select the attribute to edit and modify the function body on the Encoding and Decoding tabs.
4. Click Save Changes.

Code generation preferences can be set in the `./data/config/codeGenConfig.xml` configuration file, the GUI, or both:

1. Namespace: specifies a namespace for generated code to avoid name conflicts.
2. Create Include Directory: places header files in a specified directory relative to the output directory.
3. Prefix Classnames: adds a prefix to class names to prevent conflicts with existing VR-Link classes.
4. 64-bit Linux Makefile: generates a makefile for building generated code on Linux for 64-bit computers.
5. Generate Examples: allows generating simple talk and listen examples that demonstrate how an object or interaction is used.
6. Map RTIObjectId to DtGlobalObjectDesignator: maps the RTIObjectId structure to VR-Link's internal DtGlobalObjectDesignator.
7. Generate #error for undecodable attributes: inserts #error statements into output code for attributes that cannot be generated correctly.
8. Include HLA Standard MIM: includes Management Information Model (MIM) FOM elements from the HLA Evolved standard, even if they are not found in the loaded FOM.
9. Generate DIS PDUs: generates custom DIS PDUs and a protocol-independent API for experimental use.

Note that all code examples are retained in full, without any modifications or additions.
**Configuring Code Generation Preferences**

* Choose Configuration -> Preferences
* In the Preferences dialog box, select "Use Namespace" to specify a namespace, or check boxes for other options
* Click OK

**Choosing an Output Directory**

* Choose Configuration -> Choose Output Directory
* Select the output directory and click Select Folder
* The code generator will use this directory until changed

**Generating Objects and Interactions**

* Choose Build -> Generate or click the Generate button

**The Generated Code**

* The VR-Link Code Generator generates files containing enumerations, data types, net types, and classes that implement publishing and subscribing of objects and interactions
* Files generated:
	+ Enumerations file (FomNameEnum.h) from enumerated data types in OMT or XML file
	+ Data type implementation files (FomNameTypes.h/.cxx and FomNameNetTypes.h/.cxx)
	+ Object and interaction implementation files

**Enumerations**

* The size of the enumeration over the network is determined based on the type of definition file loaded
* If an OMT file is loaded, the size is determined by the enumeration name (e.g. ActionEnum32 has a size of 32 bits)

**Data Types**

* Complex data types and their network types are generated from complex data types in OMT files or combinations of simple/complex data types in XML files
* Data types with dynamic cardinality are generated using STL vectors

**Objects and Interactions**

* For each object, a DtStateRepository, DtObjectPublisher, DtReflectedObject, etc. is created
* For each interaction, a DtInteraction, DtInteractionEncoder, and DtInteractionDecoder is created
* Encoding and decoding is built into the object and interaction classes

**Project Files and Makefiles**

* Windows project files and UNIX Makefiles are generated with the code
* Allows building of dynamic libraries that can be linked into application code to incorporate FOM extensions

**Attributes and Types that Cannot be Decoded and Generated**

* The code generator cannot properly generate encoding or decoding for certain cases, including:
	+ Complex data types with more than one component of dynamic cardinality
	+ Attributes or complex data types containing components of variable size data
	+ Variant records in complex data types
The text describes the DIS (Distributed Interactive Simulation) specific interface of VR-Link, a protocol-independent interface that provides functionality for simulations to interact with a DIS exercise. The interface includes classes such as DtPdu, which represents DIS Protocol Data Units (PDUs), and DtExerciseConn, which handles connections to the DIS network.

The text covers various topics related to PDUs, including:

* Sending PDUs using the send() or sendStamped() functions of DtExerciseConn
* Receiving PDUs through callbacks registered with VR-Link
* Inspecting and setting data in a PDU header
* Constructing a PDU from a network representation
* Using external buffers in a PDU class
* Copying PDUs

The text also provides examples of how to create and send a Transmitter PDU, as well as how to register a callback function with VR-Link.

Here are the code examples:

* Creating and sending a Transmitter PDU:
```c
DtExerciseConn exchange(...);
...
// Create a DtTransmitterPdu
DtTransmitterPdu pdu;
// Fill the PDU with data
pdu.setEntityId(DtEntityIdentifier(1,2,3));
pdu.setRadioId(4);
pdu.setTransmitState(DtOn);
...
// Send to the exercise
exConn.sendStamped(pdu);
```
* Registering a callback function:
```c
DtPduFactory::addCallback<MyPdu>(this, &MyClass::myCallback);
```
Note: The code examples are included in their entirety, without modification.
**8.1.2: Using netRead() Function**

The `netRead()` function tries to read a packet from the network, constructs an instance of a PDU class from the network representation, and returns it. Applications must delete the DtPdu returned by `netRead()` before making another call to `netRead()`.

Considerations when using `netRead()` directly:

* Successive calls to `netRead()` return DtPdus that all use the same buffer for their network representations.
* Applications must delete the DtPdu returned by `netRead()` before making another call to `netRead()`.
* PDU filtering based on PDU kind is done at the DtInetSocket level (before the packets get to `netRead()`).
* If you are using `netRead()`, you should either turn filtering off with `DtExerciseConn::disableFiltering()` or use `DtExerciseConn::addInterestInPduKind()` to explicitly register interest in the kinds of PDUs you want to receive.

Code example:
```c
int retCode;
while (1) {
   DtPdu* pdu = exConn.netRead(&retCode);
   if (retCode == DtNET_READ_SUCCESS) {
      // do something with the PDU
      ...
      delete pdu;
   }
}
```
**8.1.2.3: Using readUntil() Function**

The `readUntil()` function is similar to `drainInput()` in that it repeatedly reads and processes PDUs. It returns when the predicate() function returns true when called on the PDU being processed, or after timeout seconds, whichever happens first.

Code signature:
```c
DtPduKind readUntil(DtPredicate predicate, void* arg, DtTime timeout, DtTime sleepTime);
```
**8.1.3: Inspecting and Setting Data in a PDU Header**

The `DtPdu` class has functions to inspect and set the data in a DIS PDU's header.

Member functions:

* `protocolVersion()`: Returns the value of the protocol version field.
* `exerciseId()`: Returns the value of the exercise ID field.
* `kind()`: Returns the kind of the PDU.
* `protocolFamily()`: Returns the value of the protocol family field.
* `length()`: Returns the length of the PDU.

Other functions:

* `timeStamp()`: Returns a floating point number representing the time (in seconds past the hour) that is encoded in the PDU's timestamp.
* `timeStampType()`: Returns either `DtTimeStampRelative` or `DtTimeStampAbsolute`, depending on the type of the PDU's timestamp.
* `setExerciseId()`: Sets the value of the PDU header's exercise ID field.
* `setTimeStamp()`: Sets the PDU's timestamp to time modulo 3600, and the timestamp type to relOrAbs.
* `setVersion()`: Sets the value of the Protocol Version field.
* `print()`: Prints the entire contents of a PDU in human readable form.
**DtPdu Class**

* `printData()` method prints data in hexadecimal format
* Header information is set at construction time and cannot be changed later
* Derived classes from DtPdu have two constructors:
	+ Blank PDU constructor: constructs a minimal, blank PDU with default values
	+ From-network-representation constructor: constructs a PDU object from a network representation of the PDU

**Blank PDU Constructor**

* Sets protocol version to `DtProtocolVersionToSend`
* Sets PDU kind and protocol family based on derived class type
* Sets length to minimal length, exerciseId and time stamp to zero
* Optional buffer argument can be used to specify an external buffer (see 8.1.7)

**From-Network-Representation Constructor**

* Takes a pointer to a network representation of a PDU as an argument
* Constructs a DtPdu object representing this PDU
* Optional buffer argument can be used to specify an external buffer (see 8.1.7)
* Each derived class has its own specific constructor requirements (e.g. `DtFirePdu` requires a `DtNetFirePdu`)

**Notes**

* Derived classes must define the virtual function `internalGetPduKind()`
* Using the from-network-representation constructor is rare and typically used by a `DtPduFactory` to construct PDUs from received network packets
* The `status()` member function can be used to determine whether a DtPdu represents valid data after construction
**DtPdu Status and Factory**

The status of a DtPdu constructor is not verified, so a status of DtSTATUS_OK does not guarantee that the PDU is valid. However, a status other than DtSTATUS_OK means the PDU is not valid.

To construct a DtPdu object from a network representation without knowing its type, use the `createPdu()` function in the `DtPduFactory` class (defined in `pduFactory.h`). This function checks the PDU kind and creates an appropriate PDU class object.

**Using the DtPduFactory**

To get a pointer to the PDU factory used by a `DtExerciseConn`, use `exConn.pduFactory()`. To create a PDU class object, cast the buffer containing the network representation to a `DtNetPacket*` and pass it to `createPdu()`.

**Protocol Version Check**

The `createPdu()` function rejects packets with protocol versions less than `DtProtocolVersionToRecvMin` or greater than `DtProtocolVersionToRecvMax`. These global variables are declared in `pdu.h`.

**Registering Creator Functions**

Each PDU class has a static member function called `create()` that can serve as its creator function. To register a creator function with the PDU factory, use `exConn.pduFactory()->addCreator()`. A NULL creator function can be added to indicate that there is no PDU class for a particular kind and `DtUnknownPdu` should be used instead.

**Using External Buffers**

Each DtPdu object stores a network representation of the PDU it represents. In some cases, you might want the PDU class to use a specific area of memory for storage of its network representation. To do this, pass a pointer to a particular area of memory cast as a `DtBufferPtr` to the constructor.

**Code Examples**

* Creating a PDU object from a network representation: `DtPdu* pdu = fact->createPdu((DtNetPacket*) buffer);`
* Registering a creator function: `exConn.pduFactory()->addCreator(DtPduKind(10), DtEntityStatePdu::create);`
* Using an external buffer for storage of the network representation: `DtEntityStatePdu pdu(DtBufferPtr(buffer));` or `DtFirePdu(netPacket, DtBufferPtr(netPacket));`
**Passing Pointers to External Memory**

When passing a pointer to external memory to the `DtPdu` constructor, ensure that the buffer is large enough to accommodate the largest network representation needed by the `DtPdu` object. The lifetime of the buffer must extend for the lifetime of the `DtPdu`. Modifying the buffer will result in undefined behavior when using the mutator or inspector functions.

**Copying PDUs**

The `DtPdu` class has a copy constructor and assignment operator overloaded. To copy data, use:

```cpp
DtPdu pdu1, pdu2;
pdu1 = pdu2; // pdu1 now contains the same data as pdu2
```

However, derived classes from `DtPdu` do not usually have copy constructors or assignment operators. To ensure correct copying, use the network representation of the PDU:

```cpp
DtFirePdu pdu1;
DtFirePdu pdu2((const DtNetFirePdu*)pdu1.netRep());
```

Alternatively, use a buffer to copy a `DtPdu`:

```cpp
DtPdu pdu1;
DtPdu pdu2(pdu1, buffer);
```

**Getting an Object ID**

The `DtExerciseConn` class has the `nextId()` function, which returns an object of type `DtObjectId`. This can be used to obtain an ID for simulating an object. Note that this ID may not be unique in the DIS exercise.

**Working with Non-Standard PDUs**

VR-Link can work with user-defined PDUs by using either:

1. **DtUnknownPdu**: A wrapper around a C-style structure representing the PDU.
2. **Deriving Classes from DtPdu**: More complex, but allows for easier usage in applications.

To use `DtUnknownPdu`, fill a buffer with the exact bytes to be sent on the network (including the DIS PDU header) and pass it to the `from-network-representation` constructor:

```cpp
Fill a buffer with the exact bytes...
DtUnknownPdu pdu(buffer);
```

Note that when using `Net` types, such as `DtNetInt32`, byte swapping is performed on little-endian machines.
The text describes how to use the VR-Link library to create a connection to a DIS exercise and send and receive PDUs (Protocol Data Units).

A PDU is created by defining a structure that represents the network representation of the PDU. For example, a Test PDU with two fields "a" and "b" can be defined as follows:
```
typedef struct NetTestPdu
{
   DtNetPduHeader header;
   DtNetInt32 a;
   DtNetInt32 b;
} NetTestPdu;
```
An instance of the structure is created and filled with data, and then a `DtUnknownPdu` object is created from the network representation:
```
NetTestPdu aNetPdu;
aNetPdu.header.version = 5;
aNetPdu.header.DtExercise = 1;
aNetPdu.header.DtLength = sizeof(NetTestPdu);
aNetPdu.header.DtKind = 220;
...
aNetPdu.a = 10;
aNetPdu.b = 11;

DtUnknownPdu pdu((DtNetPduHeader*) &aNetPdu);
```
The PDU is then sent using the `exConn.sendStamped(pdu)` function.

On the receiving side, a callback function can be registered to handle PDUs of a specific kind. For example:
```
exConn.addPduCallback(DtPduKind(220), testCallback, NULL);
```
The callback function can access the PDU's network representation and cast it to a `NetTestPdu` structure:
```
void testCallback(DtPdu* pdu, void *usr)
{
   NetTestPdu* aNetPdu = pdu->packet();
   int a = aNetPdu->a;
   int b = aNetPdu->b;
}
```
The text also describes how to derive classes from `DtPdu` and register them with VR-Link.

Finally, the text explains how to configure a `DtExerciseConn` object using various constructors and methods. For example:
```
DtExerciseConn conn(0); // create a connection with exercise ID 0
conn.setExerciseId(1); // set the exercise ID to 1
```
The text also describes other methods of configuring the `DtExerciseConn` object, such as filtering PDUs and sending packets using `DtInetSocket`.
The DtExerciseConn class has three constructors that allow for different configurations.

1. The first constructor takes four arguments: port number, exercise ID, site ID, and application number. This constructor receives unicast or broadcast packets destined for the computer on the specified port and sends packets to the broadcast address of the computer's primary network interface.
2. The second constructor takes five arguments: port number, exercise ID, site ID, application number, and destination address. This constructor allows for specifying a default IP address for outgoing packets. The destination address can be a unicast, multicast, or broadcast address.
3. The third constructor takes three arguments: port number, exercise ID, site ID, and a pointer to a DtInetSocket. This constructor gives full control over how the socket is created.

The class also has a member function called useAsynchIO() that allows for enabling asynchronous IO for DIS.

There is an example of using the second constructor:

DtExerciseConn(3000, DtInetAddr("207.86.232.1"));

And there are examples of using the third constructor with asynchronous IO enabled:

// Pass a pointer to the constructor    
DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"),
3300);
DtDisSocket *netSocket = new DtDisSocket(endpoint, 0, 0,
(DtDefaultSockOpts | DtAsyncReadWrite));
DtExerciseConn  *exConn = new DtExerciseConn(netSocket, exerciseId, 
siteId, applicationNum );
... delete exConn;
delete netSocket;

And there is an example of setting the useAsynchIO() member function to true:

exConn->useAsynchIO();
**Multicast Subscription**

* `DtExerciseConn` allows subscription to one or more multicast addresses.
* Valid multicast addresses range from 224.0.0.0 to 239.255.255.255, but avoid using those that start with 224.0.0.
* Interest in a multicast address is indicated by calling `addInterestInMcastAddr()`.
* To send packets to a multicast address, include the address as the `destAddr` argument to `send()` or `sendStamped()`.
* If the destination address passed to the `DtExerciseConn` constructor is a multicast address, subscription is automatic.

**Filtering PDUs**

* `DtExerciseConn` can filter out PDUs based on certain criteria.
* By default, packets with unexpected protocol versions and exercise IDs are filtered out.
* The DtExerciseConn maintains a list of PDU kinds in which it is interested, including those on which callbacks have been registered and those explicitly added using `addInterestInPduKind()`.
* Filtering can be turned on or off using the `disableFiltering()` and `enableFiltering()` functions.

**Bundling and Unbundling**

* Bundling of multiple PDUs into a single network packet is supported, but off by default.
* Bundling can be turned on using the `setBundling()` function, which takes the maximum bundle size as an argument.
* When bundling is on, packets are concatenated together until the bundle reaches the maximum size, at which point it is sent to the socket.
* Unbundling is enabled by default, but can be turned off or on using the `setUnbundling()` function.

**Code Examples**

```
DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
appInit.setUseAsynchIO(true);
DtExerciseConn exConn(initializer);

disSocket.setBundling(1464, true, 0, 0, 0, 0); // turn on bundling with max size of 1464 bytes
```
**Unbundling and Receiving Packets**

When unbundling is enabled, successive calls to the receive function return successive PDUs from a packet. On the next call after the last PDU from a packet has been returned, the first PDU from the next packet is returned.

If unbundling is disabled but a bundled packet is received, all but the first PDU in the packet is ignored.

**Sending Packets**

To send packets with any DtInetSocket class, use either the `send()` or `sendTo()` member function. The socket's `send()` member function returns the number of bytes sent, or -1 if the packets cannot be sent. If -1 is returned, you can query which error was encountered using `getLastError()` or `getLastErrorString()`.

**Receiving Packets**

To receive packets with any DtInetSocket class, use the `recv()` member function. The return status can be checked to determine the status of the receive call. If an error occurs, `DtInetSockRcv_ERROR` is returned, and you can query which error was encountered using `getLastError()` or `getLastErrorString()`. If no packet was received, `DtInetSockRcv_NO_PACKET` is returned. Any value greater than 0 contains the number of bytes that were read.

**Intercepting Incoming Entity State PDUs**

To intercept incoming entity state PDUs:

1. Register a callback on entity state PDUs.
2. Override `DtReflectedEntity::processEntityState()`.
3. Within the callback, call `DtReflectedEntityList` to register with `DtExerciseConn`. The reflected entity list will dispatch the entity state PDU to the callback.

**Setting Different Heartbeats in DIS 7**

To set different heartbeats for DIS objects:

1. Set the heartbeat for non-moving entities using `setStationaryDfltTimeThreshold()`.
2. Set the heartbeat by entity type using `setEntityTypeDfltTimeThreshold()`.
3. Set the heartbeat value by class type using `setClassDfltTimeThreshold()`.
4. Set a single heartbeat value for every DIS object using `setDfltTimeThreshold()`.

Example code:
```cpp
// Set stationary default time threshold to 20 seconds
DtEntityPublisher::setStationaryDfltTimeThreshold(20.0);

// Set entity type default time threshold (air units: 1 second, humans: 2 seconds)
DtEntityPublisher::setEntityTypeDfltTimeThreshold(DtPlatform, DtPlatformDomainAir, 1.0);
DtEntityPublisher::setEntityTypeDfltTimeThreshold(DtLifeForm, -1, 1.0);

// Set class default time threshold (IFF objects: 10 seconds, entities: 5 seconds)
DtIffPublisher::setClassDfltTimeThreshold(10.0);
DtEntityPublisher::setClassDfltTimeThreshold(5.0);

// Set single heartbeat value for every DIS object to 8 seconds
DtObjectPublisher::setDfltTimeThreshold(8.0);
```
Remember to call `DtExerciseConnection.tick()` to send the data over the network at the rate of the smallest heartbeat threshold.
**9 - Writing Applications Using the C# API**

The chapter explains how to develop applications using the VR-Link C# library, referencing the F-18 example. It assumes that readers are familiar with the C# language.

**9.1 - Introduction to the C# API**

* VR-Link for C# is built with Microsoft Visual Studio and uses both 32-bit and 64-bit compilers.
* The C# API uses the .NET Framework.
* See VR-Link Release Notes for supported versions of Visual Studio and .NET.

**9.2 - Adding the VR-Link for C#.dll to Your Project**

* Add vrLinkSharp.dll reference to your project by right-clicking on the project, selecting "Add Reference", and browsing to the ./bin directory inside the root VR-Link install folder.
* Add the following using statement to access the C# library: `using makVrl;`

**9.3 - Initializing an Exercise Connection**

* Create an exercise connection initializer using the `ExerciseConnectionInitializer` class, which contains a `connectionType` member.
* The `connectionType` must be specified when constructing the initializer.
* There are derived classes for each supported protocol: DisExerciseConnectionInitializer, Hla13ExerciseConnectionInitializer, etc.

**9.4 - Using the Application Initializer Class**

* As an alternative to initializing an exercise connection, use the `ApplicationInitializer` class to handle initialization.
* The `ApplicationInitializer` parses command line arguments and defines a default connection type if none is provided.
* Example: `Talk-Sharp.exe -C HLA13`

**9.5 - Publishing Objects**

* VR-Link for C# supplies publishers for objects that it defines.
* Define a publisher of the right type, such as an `EntityPublisher`, and initialize it with an exercise connection.
* Edit the `EntityStateRepository` (ESR) to modify the values sent by the publisher.
* Use a tick() function to update the ESR at regular intervals.

Code examples are retained in full.
**9.6 - Reflected Objects**

* A reflected object is a class used to store information about an object discovered on the exercise connection.
* A reflected object list keeps track of multiple reflected objects and handles callbacks for discovering, updating, and deleting objects.
* The `ReflectedEntityList` class is used in the F-18 example to store ReflectedEntity types.

**9.7 - Callbacks and Interactions**

* Interactions are handled differently than objects; they are typically created and sent one time, then received and reacted to appropriately.
* An example of an interaction is the FireMessage, which is denoted as a message in VR-Link for C#.
* To send a FireMessage, create it and send it with the exercise connection using `myExConn.sendMessage(myFire)`.
* To receive a FireMessage, register a callback using `myExConn.addMessageHandler(FireMessage.theName, new MessageDelegate(processFireMessage))`.

**10 - Using Plug-ins to Extend VR-Link for C#**

* VR-Link programmers can extend the C# API by creating plug-ins.
* The chapter covers how to develop plug-ins, including build requirements, architectural overview, managed interface class, loading plug-ins, initializing connections, managed interface concepts, messages, code generator, and a laser designator example.

**Code Examples:**

* `simTick(double dt)` method:
```csharp
public void simTick(double dt)
{
   ...
    myPos[i] += (myVel[i] + 0.5 * myAccel[i] * dt) * dt;
    
   ...
    myESR.worldPosition = myCoordTrans.coordTrans(myPos);
    ...
    myEntityPub.tick(dt);
}
```
* `ReflectedEntity` method:
```csharp
static ReflectedEntity nearestEntity(string myObjId, Vector3d geocPos, ReflectedEntityList rel)
{
   ReflectedEntity nearest = null;
   double minDistSqr = 0.0;
   foreach (ReflectedEntity re in rel.entities)
   {
      if (re.esr.id == myObjId)
         continue;
        // NOTE: Is world position correct? Does this temp creation work?
       double distSqr = (re.esr.worldPosition - geocPos).LengthSquared;
       if (distSqr < minDistSqr || nearest == null)
       {
           nearest = re;
           minDistSqr = distSqr;
       }
   }
   return nearest;
}
```
* `FireMessage` creation and sending:
```csharp
myFire = new FireMessage();
// Fill out FireMessage here
... 
myFire.worldPosition = ESR.worldPosition;
myFire.velocity = ESR.worldVelocity;
         
...
myExConn.sendMessage(myFire);
```
* Registering a callback for receiving a FireMessage:
```csharp
myExConn.addMessageHandler(FireMessage.theName, new MessageDelegate(processFireMessage));
```
* Processing a received FireMessage:
```csharp
internal void processFireMessage(Message m)
{
    FireMessage fm = m as FireMessage;
    Console.WriteLine("Fire Message received from entity " + fm.firingId + " targeting entity " + fm.targetId + ". ");
}
```
The text describes the ManagedInterfaceCS library, which is a set of C# bindings for the VR-Link and ManagedInterface libraries. It allows C# applications to access the power of VR-Link and ManagedInterface directly from C#. The ManagedInterfaceCS layer communicates with the underlying C++ libraries through a simple message-passing API.

The text also describes the following components:

* ManagedInterface class: A singleton class that provides a centralized location to register message decoders, strategies, and resources used during execution.
* Plug-ins: DLLs that must be in the plug-ins directory and export a function with a specific name and signature to be loaded.
* Connection initialization procedure: A process that initializes connections based on protocol-specific strategies and shared resources.

The text also defines several concepts:

* Strategies: Modular components within ManagedInterface that process object state updates and interactions from VR-Link and create messages to send to the C# application.
* Resources: Shared data structures and classes between different strategies, managed by a resource manager accessible from the ManagedInterface class.
* Delegates: Not defined in this text.

The code examples provided are:

```
extern "C" {
   DLL_EXPORT bool initManagedInterfaceModule( DtManagedInterface* gl);
}
```

And several defines for commonly used objects:

```
MANAGEDINTERFACE_DLL extern const char* EXERCISE_CONNECTION_NAME;
MANAGEDINTERFACE_DLL extern const char* CLOCK_NAME;
MANAGEDINTERFACE_DLL extern const char* REFLECTED_ENTITY_LIST_NAME;
MANAGEDINTERFACE_DLL extern const char* ENTITY_PUBLISHER_LIST_NAME;
```
The document discusses the utility functions and delegates used in the ManagedInterface project.

Utility Functions:
These are functions that provide access to commonly used objects. The following functions are defined:
- `findExConnResource()`: Returns a pointer to an exchange connection resource.
- `findRadioId()`: Returns a radio ID.
- `findRadioEntityType()`: Returns a radio entity type.
- `findTransmitState()`: Returns the transmit state of a radio.
- `findInputSource()`: Returns the input source of a radio.

Delegates:
These are functions that can be called to perform specific tasks. The following delegate is defined:
- `OnRadioStateChanged()`: This delegate is called when the state of a radio changes.

Message Definition:
A message definition is used to define the structure and attributes of a message. The message definition includes the following fields:
- `name`: The name of the file to generate.
- `class`: The name of the class to build.
- `includes`: A list of include files required for the C++ code generator.
- `DLLExport`: The DLL Export macro name used for the C++ code generator.

Message Enums:
These are enumerations defined in the `enums` table. An enumeration is given a name and then a list of enumerated values within double brackets [[ ]]. For example:

{type="enum", name="transmitState", enum="TransmitState"};

Message Structures:
Some messages need to package up several data fields into a single structure. These structures can be defined in the `structs` table. A structure follows the same rules as the `attributes` table and uses the same data types, which are defined below.

Message Attributes:
Attributes define the message layout. Attributes can be defined as simple data types, enums, structures, or lists of any of these types. The following data types are supported:
- string
- bool
- Int8
- Uint8
- Int16
- UInt16
- Int32
- UInt32
- Int64
- UInt64
- float
- double
- Vector2
- Vector3
- Vector4
- Quaternion
- EntityEnum
- List<DATA TYPE>

Note: When using an `EntityEnum`, user-defined struct, or list datatype as an attribute, the attribute must have the field `new=true` defined.

Message Configuration:
The message description has fields for the name of the file to generate (not including the extension) and the name of the class to build. The message definition also contains fields to describe any required include files, or DLL Export macro name, which are only used for the C++ code generator.

Code Generator:
Once the message definition is written, the included code generators generate C++ and C# source code to encode and decode the message data.
**Command Line Tools**

The C# and C++ code generators are command line tools that can be integrated into build steps to generate message source code.

**C# Code Generator Parameters**

* `-i`: Full path to the message definition file
* `-o`: Full path to where the generated C# files should go

**C++ Code Generator Parameters**

* `-i`: Full path to the message definition file
* `-h`: Full path to where the generated C++ header files should go
* `-s`: Full path to where the generated C++ source file should go

**Laser Designator Example**

The example is a complete source code for a plug-in that adds support for Laser Designators in DIS and HLA. It uses the C++ VR-Link toolkit and the VR-Link C# library.

**Project Structure**

The project files are broken down into five projects:

1. Protocol independent message representations
2. Four protocol-specific projects (DIS, HLA, etc.)

**Laser Designator Messages**

* Discovery message: informs VR-Link C# about laser designators
* State update message: updates the state of a laser designator
* Removed message: removes a laser designator

**Laser Designator Plugin**

The Laser Designator plug-in loads the laser designator messages into the message factory.

**Protocol Specific Plug-ins**

The protocol-specific laser designator plug-ins load their specific strategy into the strategy factory and register with the initialization strategy to be loaded during connection.

**Laser Designator Strategy**

When the laser designator strategy is created, it registers interest in laser object messages with ManagedInterface. It also initializes the reflected laser designator list and installs callbacks to listen for laser designators coming from the DIS/HLA network.

**Initialization Function**

The initialization function finds the exercise connection shared resource, creates a reflected laser designator list, and installs callbacks on it to listen for laser designators coming from the DIS/HLA network. It also creates a laser designator publisher list to hold publishers that mirror laser designators being controlled in VR-Link C#.

**Tick Function**

The tick function updates any laser designator publishers that were created to mirror laser designators from VR-Link C# to the DIS/HLA network.

Note: I did not add any new information, and only summarized the core content provided.
The strategy contains several callbacks for registering with VR-Link and ManagedInterface message handlers to handle discovery, removal, and state update of laser designators from both DIS/HLA network and within VR-Link C#. The callbacks marshal data to and from laser designator messages and VR-Link data structures.

To receive and send laser designators in C#, a .lua file is defined that outputs state, discovery, and removed messages. The messages are defined as:

```
MESSAGE{
   fileName="laserDesignatorDiscovery";
   className="LaserDesignatorDiscovery";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="designatorId"};
   }
}
MESSAGE{
   fileName="laserDesignatorRemoved";
   className="LaserDesignatorRemoved";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";   
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="designatorId"};
   }
}
MESSAGE{
   fileName="laserDesignatorState";
   className="LaserDesignatorState";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";
   enums={
      CodeName=[[OTHER]];
      DesignatorCode=[[OTHER]];
   };
   attributes={
      {type="string", name="entityId"};
      {type="float", name="power"};
      {type="float", name="wavelength"};
      {type="Vector3", name="relativeDesignatorSpot"};
      {type="Vector3", name="worldDesignatorSpot"};
   }
}
```

A reflected object class `ReflectedLaserDesignator` is defined, which contains a state repository and wrappers around some of the state repository functions. A reflected object list `ReflectedLaserDesignatorList` is also defined, which registers callbacks with an exercise connection.

The callbacks are:

* `handleLaserDesignatorDiscoveredMessage`: handles discovered laser designators
* `handleLaserDesignatorRemovedMessage`: handles removed laser designators
* `handleLaserDesignatorUpdatedMessage`: handles updated laser designators

Delegates are defined for specific callback functions, and the callback functions themselves are not shown in this summary.
**C# Code**

The code snippet shows two internal methods: `handleLaserDesignatorDiscoveredMessage` and `handleLaserDesignatorUpdatedMessage`. These methods handle messages related to laser designators.

In `handleLaserDesignatorDiscoveredMessage`, a new `ReflectedLaserDesignator` object is created with the `entityId` from the message, and added to the `myUnprocessedLasers` dictionary.

In `handleLaserDesignatorUpdatedMessage`, an existing `ReflectedLaserDesignator` object is retrieved or created if necessary. If the object exists, it updates its state using the message. Otherwise, the object is updated and then discovered using a helper method.

A `laserDesignatorPublisher` class is defined to publish laser designators to VR-Link. The publisher has an `ExerciseConnection` and a `LaserDesignatorStateRepository`. The `tick` method creates a state message from the repository and sends it using the exercise connection. The `dispose` method sends a removal message when the entity is destroyed.

**Java API**

The Java API chapter explains how to develop applications using the VR-Link for Java library. It covers setting up a project, initializing an exercise connection, publishing objects, and more.

The examples provided include running the F-18 example, setting up a project with bundled native libraries or external native libraries, and using the `jcommander` annotation for parameter handling.

**Note**: The Java API chapter assumes that the reader knows the Java language.
**Running Java Applications**

To run VR-Link applications, use one of the following methods:

1. Specify the classpath using the `-cp` argument:
```
java -cp f18.jar;vrlj.jar com.mak.vrlj.example.f18.F18 --loadPath c:\mak\vrlink5.2\bin
```
2. Use a relative classpath from the VR-Link `/bin` or `/lib` directory (Windows) or `/lib64` directory (Linux):
```
java -cp ..\java\listen.jar;..\java\vrlj.jar com.mak.vrlj.example.listen.Listen
```
3. Set the `CLASSPATH` environment variable:
```
set CLASSPATH=<path to VR-Link>\java\f18.jar;<path to VR-Link>\java\listen.jar;<path to VR-Link>\java\talk.jar;<path to VR-Link>\java\vrlj_VC10.jar
```
**Setting up a Project**

To set up a project, use a javac compiler that supports at least Java 8. Add the correct jar file to your Java classpath to build and run your application. The `vrlj.jar` file contains no native libraries; you need to specify the location of the native libraries using the `setLoadPath()` method or the `-loadPath` command-line option.

**Setting up with Bundled Native Libraries**

If a jar containing native library code is used, add that jar to your Java classpath. At runtime, the native code will be loaded from the jar.

**Setting up with External Native Libraries**

If the `vrlj.jar` file is included in the Java classpath, it contains no native code. Specify the path to the shared libraries using the `setLoadPath()` method or the `-loadPath` command-line option. You can also set the load path via the command line option.

**Setting up with Eclipse**

To add a VR-Link jar file to an Eclipse project, simply add that jar to the build path. To load native libraries in Eclipse:

1. Modify the Run Configurations for the project such that the working directory contains the required native libraries.
2. Copy the native libraries into your working directory.
3. Modify your code to call `setLoadPath()` or use `-loadPath` as described above.

**Exercise Connections**

VR-Link applications connect to an exercise through an exercise connection, which is an implementation of the Java interface `ExerciseConnection`. The member functions of `ExerciseConnection` allow an application to:

* Send interactions to the exercise
* Read input from the network
* Generate event IDs
* Register callback functions
* Manage the simulation clock

**Initializing an Exercise Connection**

ExerciseConnections are created by the `ExerciseConnectionFactory` class. There is one implementation. An `ExerciseConnection` takes responsibility for various resources such as network sockets and managed memory.
**ExerciseConnection**

* Implements the AutoCloseable interface
* Example usage:
```
try (ExerciseConnection exConn = ExerciseConnectionFactory.createDefault(initializer)) {
    ... use exConn here ...
} catch (Exception e) {
    ...
}
```

**ExerciseInitializer**

* Contains all necessary information to initialize an ExerciseConnection
* May contain additional user application-specific information
* Uses jcommander for parsing command line arguments

**jcommander @Parameter annotation**

* Example:
```
@Parameter(names = { "--f18Markings" }, description = "hull markings")
private final String markings;
```

**Threading**

* VR-Link for Java shares a single thread with the application
* Each ExerciseConnection has a drainInput() method which performs background processing and must be called periodically
* Methods are not thread-safe; user applications may use multiple threads but must not call VR-Link methods simultaneously

**Publishing Objects**

* Use PublisherFactory to create ObjectPublishers for specific types of objects
* Example:
```
PublisherFactory pubFactory = exConn.getPublisherFactory();
ObjectPublisher myEntity = pubFactory.createEntity("myEntityName");
Entity myEntity = myEntityPublisher.getObject();
```

**Updating and Publishing Objects**

* Update an object's properties (e.g. position)
* Call ObjectPublisher.tick() to publish the updated object

**Time-Stepped Loop Example**

* Use a time-stepped loop to update objects and publish them
* Example:
```
double dt = 0.05; // time step in seconds
double simTime = 0.0; // starting simulation time in seconds
while (simTime <= 10.0) {
    ...
}
```

**Reflected Objects**

* A reflected object is a class used to store information about an object discovered, updated, and deleted by the exercise connection
* Each exercise connection tracks all reflected objects in a ReflectedObjectCollection, accessed from `exConn.getReflectedCollection()`
* Example:
```
ReflectedObjectCollection reflectedObjects = exConn.getReflectedCollection();
```
**11.6 Selection Criteria and Reflected Maps**

A selection criteria defines a test for inclusion: when applied to an object, it passes (returns true) and is included in the ReflectedMap, or else it fails and is removed. Once a collection is created with a specified criteria, the criteria may not be changed. Instead, create a new collection with a different criteria.

Example:
```java
ReflectedEntityMap rem = new ReflectedEntityMap(exConn);
Iterator<Entity> iter = rem.values().iterator();
while (iter.hasNext()) {
    Entity first = iter.next();
    System.out.println(iter.toString());
}
```
Alternatively:
```java
Iterator<BaseObject<? extends ObjectIdentifier>> objIter = exConn.getReflectedCollection().values().iterator();
while(objIter.hasNext()) {
    BaseObject<? extends ObjectIdentifier> obj = objIter.next();
    if(obj instanceof Entity) {
        Entity e = (Entity) obj;
        System.out.println(e.toString());
    }
}
```
**11.7 Callbacks and Interactions**

Interactions are handled differently than objects. Typically, interactions are created and sent one time, then received and reacted to appropriately. An example of such interaction is the FireInteraction.

Example:
```java
FireInteraction fire = new FireInteraction();
fire.setFiringId(myId);
... set other interaction fields as required ...
exConn.send(fire);
```
Receiving an interaction:
```java
FireInteraction.addListener(exConn, fire -> {
    System.out.print("Fire Interaction from ");
    System.out.println(fire.getFiringId());
});
```
Older syntax using anonymous inner class:
```java
FireInteraction.addListener(exConn, new InteractionListener<FireInteraction>() {
    public void process(FireInteraction fire) {
        System.out.print("Fire Interaction from ");
        System.out.println(fire.getFiringId());
    }
});
```
**12 - Example and Utility Applications**

VR-Link includes a set of supporting applications that can help you develop and troubleshoot your own applications.

Examples:
```java
f18 [options...]

f18 Command-Line Options

Option	Description
-a ID	For DIS, sets the second component of the entity ID to ID.
-d seconds	Set the delay (in seconds) between the time f18 receives a detonation interaction (or PDU), and the time it broadcasts its final message and exits.
-D algorithm	Specifies the dead reckoning algorithm.
-h	Displays a summary of command-line options, then exits.
```
Note: I did not include any additional information or assumptions. I only summarized the provided data without changing any code examples.
**Command Line Options**

* `-H` degrees: specifies the initial heading of the f18, in degrees.
* `-l` file: loads the specified MTL configuration file.
* `-L` x,y,z: specifies the initial position, as in topographic coordinates.
* `-M` markings: specifies the markings.
* `-n` notify_level: specifies the notification level for warnings.
* `-O` lat,long: specifies the reference latitude and longitude for the topographic coordinate system.
* `-r` radius: specifies the turn radius of the f18, in meters. Setting to 0.0 causes the f18 to move in a straight line.
* `-s` mps: specifies the initial speed of the f18, in meters per second.
* `-T` type: specifies the entity type, as a string of the form: kind:domain:country:category:subcategory:specific:extra
* `-W` x,y,z: specifies the initial position in geocentric coordinates. HLA Only Options:
	+ `-f` | `--fomMapperLib` libname: specifies a FOM Mapper library name.
	+ `--fomMapperInitData` data: specifies FOM Mapper initialization data, if required.
	+ `--rprFomVersion` version_number: specifies the RPR FOM version.
* `-F` FED_file: specifies the FED file. Default: federation_name.fed.
* `-N` name: specifies the HLA object name.
* `-n` federate_name: specifies the name of the federate.
* `-x` ex-name: sets the federation execution name. Default: .
* DIS Only Options:
	+ `-A` address: specifies the default destination IP address for outgoing PDUs.
	+ `-I`: uses asynchronous IO.
	+ `-P` portnum: specifies the UDP port. Default: 3000.
	+ `--recvBufferSize` size: specifies the receive buffer size.
	+ `--sendBufferSize` size: specifies the send buffer size.
	+ `--siteId` ID: specifies the site ID.
	+ `-S` address: subscribes to the specified multicast addresses. Multiple -Ss can appear on a command line. Multicast is not supported on all platforms.
	+ `--mcastTtl` ttl: specifies the multicast time to live.
	+ `-V` version: specifies the DIS protocol version contained in outgoing PDUs, where the version can be 4, 5,6 or 6.
	+ `-x` ex-name: specifies the exercise ID for DIS. Default: 1.

**Configuration File**

* The f18 configuration file is `f18.mtl`.
* By default, f18 does not load this file and relies on command line arguments for configurations.
* Use the `-l` option to specify an alternate configuration file, such as "-l f18.mtl".
* You can rebuild the f18 program or create a new application based on f18 that does not use a configuration file.

**Firing Munitions**

* Press Enter or Return to cause the f18 to fire at another entity.
* If other entities exist in the exercise, f18 issues a fire message directed at the closest one.
* Though there is no tracked munition, f18 issues a detonate message three seconds later to indicate that the target was hit.
* To change the delay, edit the `munitionFlightTime` attribute in the configuration file.

**Timestamps**

* The flag `timeStampType` defaults to relative (0), but can be set to absolute (1) using the `-T` option.
* When the `timeStampType` is absolute, f18 dead-reckons remote entities based on their absolute timestamps, when applicable.
* Absolute timestamping should be used only when the local machine's clock is synchronized with the clock being used by other applications in the exercise for their absolute timestamps.

**Using a Modified FOM**

* The `config.cxx` file shows how to configure VR-Link to use a modified FOM.
* It demonstrates how to instruct VR-Link to represent position on the network as Z, Y, X, rather than X, Y, Z.
* By default, this functionality is #ifdef'd out. To compile it in, include the definition `REVERSE=1` on your make line, for example:
```
make REVERSE=1 f18
```
**Section 12.3 - Calling VR-Link from Other Languages**

The simpleC example demonstrates how to use VR-Link from within a C language application, which can serve as a starting point for applications written in other languages that use VR-Link.

**Section 12.4 - Launcher**

The launcher example demonstrates the use of articulated and attached parts in VR-Link for both DIS and HLA, located in the ./examples/test directory.

**Section 12.5 - netdumpDIS**

netdumpDIS is a DIS debugging tool that displays the contents of arriving DIS PDUs in an easy-to-read format. It writes its output to stdout. The usage is:

`netdumpDIS [-c -errorChecking -h -v -r –verbose -A address -P port -S address –ignore_rest]`

The following table describes the command-line options for netdumpDIS:

**netdumpDIS Command-line Options**

| Option | Description |
| --- | --- |
| – or –ignore_rest | Ignore any remaining arguments on the command line. |
| -A or –destAddrString address | Specifies a broadcast address from which netdumpDIS can listen for packets. |
| -c or –clearScreen | Clears the screen between PDUs. |
| –errorChecking | Specifies that netdumpDIS does not try to print PDUs when the size indicated in the DIS header does not match the size of the packet received. |
| -h or –help | Displays a summary of command-line options, then exits. |
| -P or –disPort portnum | Specifies the UDP port. Default: 3000. |
| -r or –raw | Prints raw data. |
| -S address | Subscribes to the specified multicast addresses. |
| -v or –version | Display version information and exit. |
| –verbose | Specifies verbose mode for message output. |

**Section 12.6 - netdumpHLA**

netdumpHLA listens to an HLA federation execution, subscribes to all object and interaction classes in the FOM, and prints out data whenever it receives an attribute update or interaction. The usage is:

`{netdumpHLA13 | netdumpHLA1516 | netdumpHLA15161e} [– -c -F -f libname –fomMapperInitData data –rprFomVersion version_number -h -M -m -n -r -R -v -x exec-name –ignore_rest]`

The following table describes the command-line options for netdumpHLA:

**netdumpHLA Command-line Options**

| Option | Description |
| --- | --- |
| – or –ignore_rest | Ignore any remaining arguments on the command line. |
| -c or –clearScreen | Clears the screen between messages (updates or interactions). |
| -f or –fomMapperLib libname | Specifies a FOM Mapper library name |
| –fomMapperInitData data | Specifies FOM Mapper initialization data, if required. |
| -F fed_file_name | Specifies the FED file to use. Default: federation_execution.fed. |
| -h or –help | Displays a summary of command-line options, then exits. |
| -m or –printMom | Subscribes to MOM classes. |
| -M or –noFullReport | Disable printing of update specifics. |
| -n | Prints only the objects that have changed. |
| -r or –raw | Runs netdumpHLA in raw mode. |
| -R or –rprFomVersion version_number | Specifies the RPR FOM version. |
| -v or –version | Display version information and exit. |
| -x or –execName exec-name | Specifies the name of the federation execution to be monitored. Default: VR-Link.
When using `netdumpHLA` with the `-r` option, it prints the name of each attribute, the size of its value, and a hexadecimal dump of the value for each update or interaction received.

The program also subscribes to every class in the FED file (including MOM classes if the `-m` argument is used) and can print incoming HLA data independently of the FOM. If an update or interaction represents a class that VR-Link knows how to decode, it prints the data as the correct data types unless using raw mode. Otherwise, it prints the name of the class, attribute names, sizes, and hexadecimal values.

The two examples provided are simple VR-Link applications:

* `talk` simulates the flight of an F18 aircraft.
* `listen` repeatedly prints an entity's updated position and, if a fire PDU or interaction occurs, prints the entity ID of the attacker.

Both programs are written for protocol-independence. The source code for both examples is included with VR-Link.

The `Listen-Only Example` program listens to the network without simulating any entities. It can be compiled for either DIS or HLA and includes protocol-specific code in a conditional statement starting at line 27. With each iteration of the loop, it prints an entity's updated position in topographic coordinates and, if a fire PDU or interaction is detected, prints a message showing the entity ID of the attacker.

The `Send-Only Example` program does not process information about remote entities. The source code for both examples is included with VR-Link.

Note: This summary only includes the provided text without adding any assumptions or extra information.
The code example demonstrates how to create a DtVrlApplicationInitializer and pass it to the DtExerciseConn, which provides support for command-line arguments. The protocol-specific initialization values are set in the DtVrlApplicationInitializer and its base class, DtExerciseConnInitializer.

The code then creates an entity publisher for simulating an F18 aircraft and sets up a topographic view on the state repository to set position information in topographic coordinates. The simulation begins by sending a fire PDU or HLA fire interaction, followed by updating the entity's position by sending DIS entity state PDUs or HLA attribute updates.

The main loop of the simulation runs for 10 seconds, with the following steps:

1. Set VR-Link time to the current simulation time.
2. Process any incoming messages using drainInput().
3. Update the entity's position information using setLocation() and setVelocity().
4. Call tick() to update any data that needs to be sent.

The code includes several code examples, including:

* Creating a connection to an exercise or federation execution
* Registering a callback for handling incoming interactions
* Creating a reflected entity list to track entities found on the network
* Managing time using the simulation clock
* Listening to the network using drainInput()

Here is the full code example:
```
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>
#include <vl/fireInteraction.h>
#include <vl/iffPublisher.h>
#include <vlpi/EntityTypes.h>
#include <vlutil/vlProcessControl.h>
#include <iostream>

int main(int argc, char** argv)
{
    try
    {
        // Create a connection to the exercise or federation execution.
        DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");

        // Change some defaults
        #if DtDIS
            appInit.setUseAsynchIO(true);
        #endif

        appInit.parseCmdLine();

        DtExerciseConn exConn(appInit);

        DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
                              DtUnitedStates, DtFighter, DtF18, 0, 0);

        // Create an entity publisher for the entity we are simulating.
        DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
                                    DtForceFriendly, DtEntityPublisher::guiseSameAsType());

        // Hold on to the entity's state repository, where we can set data.
        DtEntityStateRepository *esr = entityPub.entityStateRep();

        // Create a topographic view on the state repository, so we 
        // can set position information in topographic coordinates.
        double refLatitude  = DtDeg2Rad( 35.699760);
        double refLongitude = DtDeg2Rad(-121.326577);
        DtTopoView topoView(esr, refLatitude, refLongitude);

        // We can use the ESR to set state.
        esr->setMarkingText("VR-Link");
        topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));

        // Initialize VR-Link time.
        DtClock* clock = exConn.clock();

        DtVector position(0, 0, -100);
        DtVector velocity(20, 0, 0);

        // Send a Fire Interaction.
        DtFireInteraction fire;
        fire.setAttackerId(entityPub.globalId());
        exConn.sendStamped(fire);

        // Main loop
        DtTime dt = 0.05;
        DtTime simTime = 0;
        while (simTime <= 10.0)
        {
            // Tell VR-Link the current value of simulation time.
            clock->setSimTime(simTime);

            // Process any incoming messages.
            exConn.drainInput();

            // Set the current position information.
            topoView.setLocation(position);
            topoView.setVelocity(velocity);

            // Call tick, which insures that any data that needs to be 
            // updated is sent.
            entityPub.tick();

            // Set up for next iteration.
        }
    }
    catch (...)
    {
        std::cerr << "Error: " << strerror(errno) << std::endl;
        return 1;
    }

    return 0;
}
```
I hope this summary helps! Let me know if you have any further questions.
The provided data describes two basic VR-Link examples: a listen-only example and a send-only example.

**Listen-Only Example**

This program creates a connection to an exercise or federation execution using `DtVrlApplicationInitializer`. It then registers a callback to handle fire interactions and creates an object to manage entities heard on the network. The program initializes VR-Link time using `DtClock` and enters a loop where it checks for user input and updates simulation time.

**Send-Only Example**

This program also creates a connection to an exercise or federation execution using `DtVrlApplicationInitializer`. It defines an entity type (F18) and sets up an entity publisher to manage state values. The program then sends interactions using the `sendStamped` function and updates the F18's positional data in its entity state repository. The main loop executes twenty times per second for ten seconds, updating simulation time and sending state messages.

**Code Examples**

The provided code examples include:

1. Listen-Only Example (lines 11-52)
2. Send-Only Example (lines 17-90)

Note that the `#if` statement in line 27 is protocol-specific, indicating whether to use asynchronous I/O for DIS or not.
The provided code is a C++ program that demonstrates how to connect to an exercise using VR-Link (Virtual Reality Link) and simulate the flight of an F18 aircraft. The program consists of two main functions: `main()` and `keybrdTick()`.

**Main Function (`main()`)**
1. Creates a connection to the exercise or federation execution using `DtVrlApplicationInitializer` and `DtExerciseConn`.
2. Sets some default values for asynchronous I/O and parses command-line arguments.
3. Registers a callback function (`fireCb`) with the `DtFireInteraction` class to handle incoming interactions such as fire, detonations, and collisions.
4. Creates a reflected entity list to track entities found on the network.
5. Obtains a pointer to the simulation clock from the exercise connection.
6. Sets VR-Link simulation time and processes any messages arriving through the exercise connection using `drainInput()`.
7. Finds the first entity in the entity list, retrieves its state repository, and creates a topographic view of it.
8. Prints the position of the first entity.

**KeybrdTick Function (`keybrdTick()`)**
1. Polls for blocking input line using `DtPollBlockingInputLine`.
2. Checks if the input is 'q' or 'Q', and returns -1 if so to exit the program.

The code provides a basic framework for simulating an F18 aircraft using VR-Link, including connecting to an exercise, tracking entities, managing time, listening to the network, and handling incoming interactions.
This C++ program demonstrates how to connect to an exercise, manage entities, send interactions, and send state messages using the VR-Link utility classes.

The program starts by creating a `DtExerciseConn` object (lines 17-27) to provide an interface to the RTI or DIS network. It then defines an entity type for the F18 (line 29) and creates a `DtEntityPublisher` object (line 33) to manage the generation of messages for this entity.

The program sets up a pointer to the entity state repository (line 37) and creates a topographic view on it (lines 41-43). It then sends an interaction using the exercise connection's `sendStamped()` function (lines 56-58).

The main loop executes twenty times per second for ten seconds, updating the F18's positional data in its entity state repository (lines 72-73) and ticking the entity publisher to send the updated data onto the network (line 77). The program also processes incoming messages using the `drainInput()` function (line 69).

The code examples provided include:

* Initialization of a `DtVector` object with three components (e.g., line 52)
* Creation of a topographic view on an entity state repository (lines 41-43)
* Setting state values in the entity state repository (line 46)
* Sending an interaction using the exercise connection's `sendStamped()` function (lines 56-58)
* Main loop execution, including updating positional data and ticking the entity publisher (lines 72-77)

The program uses various VR-Link utility classes, including the `DtVector` class for representing vectors in three-dimensional space.
**DtVector Class**

* The copy constructor, assignment operator, equivalence, and subscripting operators are defined.
* You can create a DtVector object using the following syntax: `DtVector vec(10.0, 20.0, 30.0);`
* You can also use the copy constructor or assignment operator to create new objects: `DtVector vec2(vec);` or `DtVector vec3 = vec;`
* Subscripting operators allow you to access individual elements of the vector: `double x = vec[0];` or `vec[0] = x;`
* The `string()` member function returns a text representation of the contents of the vector: `{          10.000,          20.000,          30.000}`

**DtDcm Class**

* A DtDcm (Direction Cosine Matrix) represents a 3x3 matrix.
* You can create a DtDcm object using the following syntax: `DtDcm mat(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);` or from three component vectors.
* The copy constructor and assignment operators are defined.
* Subscripting operators allow you to access individual elements of the matrix: `DtVector firstRow = mat[0];`
* Static member functions provide commonly used matrices: `zero()` and `identity()`

**Semantics**

* DtVectors and DtDcms are usually passed by reference or const reference to VR-Link functions.
* The following typedefs are used to make this explicit:
	+ `DtVectorRef` is equivalent to `DtVector&`
	+ `DtDcmRef` is equivalent to `DtDcm&`
	+ `DtConstVector` is equivalent to `const DtVector&`
	+ `DtConstDcm` is equivalent to `const DtDcm&`

**Manipulation Functions**

* LibMatrix.h contains C-style functions that operate on DtVector and DtDcm, including:
	+ Addition
	+ Subtraction
	+ Multiplication
	+ Scaling
	+ Dot products
	+ Cross products
	+ Negation
	+ Normalization
	+ Determinant calculation
	+ Transpose
	+ Inverse

**DtTaitBryan Class**

* Represents a set of Euler angles (psi, theta, phi) using the Tait-Bryan sequence.
* Used to convert between Euler angles and matrix representation.
**Euler Angles**

* `DtTaitBryan` class represents Euler angles with three component angles (psi, theta, phi) specified in radians.
* Inspectors and mutators: `psi()`, `setPsi()`, `theta()`, `setTheta()`, `phi()`, `setPhi()`.
* Assignment operator, equality operators, and copy constructor are implemented for `DtTaitBryan`.

**Converting Between Euler Angles and Matrix Representation**

* `Euler.h` contains functions that convert between Euler angles and rotation matrices (or `DtDcm`).
	+ `DtEuler_to_BodyToRef()` produces a rotation matrix to rotate from body coordinates to reference coordinates.
	+ `DtEuler_to_RefToBody()` produces its inverse, a matrix to rotate from reference to body coordinates.
	+ `DtBodyToRef_to_Euler()` and `DtRefToBody_to_Euler()` produce Euler angles from the matrix representation.

**Coordinate Conversions**

* VR-Link supports several coordinate systems:
	+ Geocentric Coordinates: right-hand geocentric Cartesian coordinate system with origin at the center of the earth.
	+ Geodetic Coordinates: latitude, longitude, and altitude in radians and meters above a reference ellipsoid (e.g., WGS84).
	+ Topographic Coordinates: not specified in detail.
	+ UTM Coordinates: not specified in detail.

**Geocentric Coordinates**

* `DtVector` class represents locations and vectors in geocentric coordinates.
* `DtTaitBryan` or `DtDcm` is used to represent orientation.

**Geodetic Coordinates**

* `DtGeodeticCoord` class represents geodetic coordinates (latitude, longitude, altitude) with inspectors and mutators:
	+ `lat()`, `setLat()`
	+ `lon()`, `setLon()`
	+ `alt()`, `setAlt()`.
* Conversion functions: `geocentric()` returns the geocentric equivalent of a geodetic coordinate; `getGeocentric()` sets the value of an existing `DtVector`; and `setGeocentric()` sets the value of a `DtGeodeticCoord` to the latitude/longitude/altitude equivalent of a given geocentric coordinate.

**Reference Ellipsoid**

* Default reference ellipsoid used for geocentric to geodetic conversions is WGS84, but this is configurable through `DtUseMapDatum()`.
* `DtMapDatum` is defined as a structure containing a `DtSpheroid` and an array of shifts.
**Topographic Coordinates**

VR-Link defines a topographic coordinate system as a right-handed Cartesian coordinate system with the origin tangent to the earth's surface. A DtVector is used to represent a topographic coordinate.

**DtCoordTransform**

A DtCoordTransform object can be used to convert between geocentric and topographic coordinates. VR-Link provides the function `DtGeocToTopoTransform()` to initialize a DtCoordTransform for geocentric to topographic conversion.

Example:
```c
DtCoordTransform geocToTopo;
DtGeocToTopoTransform(DtDeg2Rad(30.0), DtDeg2Rad(100.0), &geocToTopo);
```
The resulting transform can be used to convert between geocentric and topographic coordinates using the `coordTrans()` function.

**Heading, Pitch, and Roll**

Using a DtCoordTransform that converts from geocentric to topographic coordinates, Euler angles can be converted to heading, pitch, and roll. For example:
```c
DtTaitBryan topoEuler;
geocToTopo.eulerTrans(esr->orientation, &topoEuler);
double heading = topoEuler.psi();
double pitch = topoEuler.theta();
double roll = topoEuler.phi();
```
**UTM Coordinates**

Locations can be specified using a UTM coordinate system, which consists of easting and northing from an origin or reference location, and an altitude above a reference ellipsoid, all in meters. VR-Link allows defining an "offset UTM" coordinate system by passing any arbitrary reference point to the function `DtUtmInit()`.

Example:
```c
DtUtmInit(DtDegMinSec(30.0, 100.0), ...);
```
Note that only one UTM reference point can be used at a time, and `DtUtmInit()` must be called before using any of the UTM coordinate conversion functions.
The document describes the UTM (Universal Transverse Mercator) coordinate system used by VR-Link. It explains how to initialize the UTM conversion routines with a reference point and defines the structure `DtDegMinSec` to represent latitude and longitude.

A `DtUtmCoord` object is constructed by passing its three components (east, north, up) in meters to the constructor. The class has inspectors and mutators to access these components and member functions to convert between UTM coordinates and geocentric or geodetic coordinates.

There are also C-style functions that can be used for coordinate conversions, but they are discouraged in favor of the member functions.

The document explains the differences between UTM and topographic coordinates. In a UTM system, Z represents altitude above the earth's surface, while in a topographic frame, -Z represents height above a plane tangent to the earth's surface. The X, Y, and Z components of UTM coordinates correspond to east, north, and up, while in a topographic frame they correspond to north, east, and down.

The document also describes lower-level coordinate conversion functions that can be used if a greater level of control is needed. These include functions for obtaining rotation matrices between geocentric and topographic frames and functions for multiplying vectors by these rotation matrices.

Here are the code examples in full:

```
DtDegMinSec latRef = {35.0, 0.0, 0.0, DtNorth};
DtDegMinSec lonRef = {122.0, 0.0, 0.0, DtWest};
DtUtmInit(latRef, lonRef, 0);

DtUtmCoord utmLoc(50.0, 100.0, 70.0);
DtGeodeticCoord geod = utm.geodetic();

DtGeodeticCoord myOriginInGeod(35.0, -122.0, 0.0);
DtDcm geoc2Topo;
DtLatLon_to_GeocToTopo(myOriginInGeod, geoc2Topo);

DtEntityStateRepository* esr = ...;
DtVector topoVel;
DtDcmVecMul(geoc2Topo, topoVel);
```
**DtDcmVecMul**

* Used to multiply a vector by a rotation matrix.
* Example: `DtDcmVecMul(geoc2Topo, esr->velocity(), topoVel);`

**Rotation Matrix**

* Used to rotate a set of Euler angles from one coordinate system to another using the function `DtEulerToEuler()`.
* Example: `DtTaitBryan topoOrient; DtEulerToEuler(esr->orientation(), geoc2Topo, topoOrient);`

**Entity Orientation**

* To obtain an entity's orientation as topographic Euler angles (heading, pitch, and roll), use:
	+ `esr->bodyToGeoc()` instead of `orientation`.
	+ Multiply the result by a geocentric to topographic rotation matrix obtained using `DtLatLon_to_GeocToTopo()`.
	+ Convert the result to Euler angles using `DtBodyToRef_to_Euler()`.

**Coordinate Transformations**

* To transform from one cartesian system to another, subtract the origin of the second system from the point being transformed and perform the rotation.
* Example: transforming a location from geocentric to topographic coordinates:
```c
DtVector myOriginInGeoc = myOriginInGeod.geocentric();
DtVector tmp;
DtVecSub(esr->location(), myOriginInGeoc, tmp);
DtVector topoLoc;
DtDcmVecMul(geoc2Topo, tmp, topoLoc);
```

**Linked Lists (DtList)**

* A DtList is a general linked-list capability in VR-Link.
* Use `std::list<>` instead of `DtList` for new code.
* Example:
```c
class A {
public:
    A(int num) { a = num; }
    int a;
};

DtList list;
A* a1 = new A(1);
A* a2 = new A(2);
A* a3 = new A(3);
list.add(a1);
list.add(a2);
list.add(a3);

for (DtListItem* item = list.first(); item; item = item->next()) {
    A* current = (A*) item->data();
    printf("%d\n", current->a);
}
```

**Diagnostic Utilities**

* The global variable `DtNotifyLevel` controls the amount of diagnostic information printed by VR-Link.
* Example values: `DtNlFatal`, `DtNlWarn`, `DtNlInfo`, `DtNlVerbose`.
* You can use `DtOutputStream` for printing and print diagnostic messages in Windows.
**DtNlDebug**: The maximum amount of information is printed. The default setting is DtNlInfo.

**Printing Functions**: VR-Link provides printing functions to control messages generated by an application. These functions are declared in vlPrint.h and have the same prototype as printf(). They include:

* `DtFatalPerror()`: prints perror information and calls `DtAbort()` after printing
* `DtFatalError()`: prints a fatal error message and calls `DtAbort()` after printing
* `DtWarnPerror()`: prints a warning with perror information and calls `DtAbort()` after printing
* `DtInfo()`, `DtVerbose()`, `DtDebug()`, and `DtWarn()`: print messages without calling `DtAbort()`

**DtOutputStream**: A buffer-based class for sending debug and informational messages. It can be used like a standard C++ output stream.

Example:
```c
DtInfo << "something bad just happened, the error is " << error << "\n";
```
**DtPrinters**: VR-Link includes several DtPrinter subclasses that print to different output devices:

* `DtFilePrinter`: prints to a specified file
* `DtStdoutPrinter`: prints to stdout
* `DtStderrPrinter`: prints to stderr
* `DtWindowsConsolePrinter` (Windows only): prints to a Windows console

By default, `DtStdoutPrinter` is attached to `DtInfo`, `DtWarn`, `DtDebug`, `DtVerbose`, and `DtFatal`. You can add other printers or your own subclass to these streams.

Example:
```c
DtFilePrinter info_log("myInfo.log");
DtInfo.attachPrinter(&info_log);
```
**Printing Diagnostic Messages in Windows**: In non-console-based Windows applications, you need to set up a console window and use VR-Link's printing functions to avoid issues. Use `setFileOutput()` (defined in vlPrint.h) to enable writing to a console window or file.

**DtException Class**: The VR-Link exception class for handling errors and unexpected input. Member functions may throw exceptions, which can be caught and printed using the `<<` operator.

Example:
```c
try {
    region = new DtDDMRegion(spaceName, dimensionVector);
} catch (const DtException& regionException) {
    DtWarn << "Caught exception: " << regionException << std::endl;
}
```
**Functions for Manipulating IP Addresses**: The `vlutil.h` header file provides functions for obtaining and manipulating IP addresses:

* `DtStringToInetAddr()`: constructs a `DtInetAddr` from a string
* `DtInetAddrString()`: returns a string representation of a `DtInetAddr`
* `DtInetAddrOfDevice()`: returns the IP address of a device by its name
* `DtNetMaskOfDevice()`: returns the netmask of a device
* `DtInetBroadcastOfDevice()`: computes and returns the broadcast address of a device

**Miscellaneous Global Functions**: Additional miscellaneous global functions include:

* `DtSleep()`: provides a machine-independent way to halt program execution for some period of time
* `DtSelect()`: provides a machine-independent interface to the UNIX select system call
The article discusses two functions: `DtSelect()` and `DtAbort()`.

`DtSelect()` takes four arguments:
- A number of file descriptors
- Three arrays of file descriptors to monitor for:
	+ Presence of data to read
	+ Availability for writing
	+ Pending exceptional conditions
- A timeout in seconds

On Windows, `DtSelect()` interprets a file descriptor of 0 as stdin.

For more information on `DtSelect()`, please see `vlutil.h`.

`DtAbort()` is called whenever VR-Link generates a fatal error and makes the abort system call. It can be modified by writing your own definition for `DtAbort()`. The default definition for `DtAbort()` resides in its own object file, so your definition will supersede ours with no other effects.

If you link your application through a library rather than an object file, make sure that your library appears before `vlutil` on your link line.

For more information on `DtAbort()`, please see `vlPrint.h`.
