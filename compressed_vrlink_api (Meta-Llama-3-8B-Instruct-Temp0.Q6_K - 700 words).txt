The VR-Link toolkit is an object-oriented library that simplifies the development of networked simulators and virtual reality applications. It provides a protocol-independent API for creating HLA (High-Level Architecture) and DIS (Distributed Interactive Simulation) applications.

Key features of VR-Link include:

* Exercise Connection: allows exchange of simulation information with other applications
* Object Tracking: tracks remote participants in the virtual world and provides their state
* Object Publishing: sends updates to remote applications about the state of simulated objects
* Interaction Classes: provides a protocol-independent interface for sending and receiving interaction messages
* FOM-Agility: allows mapping of VR-Link's API to another FOM (Federation Object Model)
* User Extensibility: allows overriding default functionality through subclassing
* Low-Level Details: provides access to HLA RTI and DIS network configuration
* Utility Functions: includes vector and matrix manipulation, system clock interface, and coordinate conversion utilities

VR-Link also comes with a set of utility programs, including:

* netdump: prints data received from remote simulations in an easy-to-read format
* f18: a simple networked simulator for debugging purposes
* Talk and Listen: sample applications that demonstrate the use of VR-Link's functionality

The toolkit includes header files, libraries, executables, and source code for the utility programs. The "test" applications provide examples of how to extend VR-Link's features by creating custom PDUs (Protocol Data Units), interactions, encoders, and decoders.

Overall, VR-Link provides a powerful and flexible framework for developing networked simulators and virtual reality applications, with a range of features and utilities that simplify the development process.

**Simulation Standards Supported**

VR-Link supports HLA (High Level Architecture) and DIS (Distributed Interactive Simulation) standards.

**HLA RTI 1.3 and RTI 1516 Specifications**

* VR-Link supports HLA 1.3 specification, HLA 1516 specification (SISO DLC HLA API), and HLA Evolved (IEEE 1516-2010) specification.
* The protocol-independent interface allows for creating applications that can be used with any version of HLA without significant changes.

**HLA FOM Support**

* VR-Link provides built-in support for the Real-Time Platform Reference FOM (RPR FOM).
* RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group.
* The goal of the RPR FOM is to facilitate interoperability among HLA simulations that choose to use it.

**RPR FOM Versions Supported**

* VR-Link 5.4.1 has built-in support for:
	+ RPR FOM 0.5, 0.7, 0.8, 1.0
	+ RPR FOM 2.0, drafts 6, 14, 17, and 20
* By default, all VR-Link examples use RPR FOM 2.0.

**Code Examples**

* Example of interoperability between HLA 1.3 and IEEE 1516 federates: `listen example with the 1516 API` and `talk example with the 1.3 API`.
* Example of using a different version of the RPR FOM: pass the version number to the `DtRprFomMapper` constructor and pass the resulting object to the `DtExerciseConn` constructor.

Note that this summary focuses on the main points and code examples, while omitting some details and technical information.

**Federation Execution Name and FED File**

When using VR-Link, ensure you use a federation execution name that corresponds to the right FED file. For example: `DtExerciseConn conn("MAK-RPR20017-1-1.fed", "MyApp", new DtRprFomMapper(2.0017-1));`

**VR-Link's Support for FOM Agility**

VR-Link can work with other FOMs by using its FOM Mapper to define mappings between VR-Link's protocol-independent interface and the objects, interactions, parameters, and attributes defined in your FOM.

**VR-Link Concepts**

* VR-Link is a multi-layered toolkit that provides classes, functions, and utilities for writing simulation applications.
* It has multiple layers of access:
	+ Work through the protocol-independent interface to create applications that work with both HLA and DIS.
	+ Go below the protocol-independent interface to tailor your application to HLA or DIS.
	+ Extend VR-Link by creating new classes for HLA objects and interactions or DIS PDUs.

**HLA, DIS, and Protocol Independence**

* HLA is required by the Department of Defense for use in all DoD simulations.
* The Federation Object Model (FOM) defines the data model for a federation execution.
* Every federation execution requires a FOM, which can be developed by members or used from an existing reference FOM.

**VR-Link's Built-in Support**

* VR-Link has extensive built-in support for the Real Time Platform Reference FOM (RPR FOM).
* The RPR FOM is implemented through a Federation Execution Data (FED) file, which contains a subset of the FOM required by the RTI.
* VR-Link supports the FOM defined within the FED file called `VR-Link.fed`, which represents the RPR FOM plus extra classes added by VR-Link.

The RPR FOM (Reference Physics Reference Federation Object Model) aims to facilitate interoperability among HLA simulations that use it. Using the RPR FOM ensures compatibility with other simulations that also use this model. VR-Link supports the RPR FOM and has features for working with new or modified FOMs, known as FOM-agility.

The Run-Time Infrastructure (RTI) is an implementation of the HLA interface specification, providing services through its API. Applications can call RTI functions directly or through VR-Link. The HLA rules require federates to use the RTI for exchanging simulation data.

The DIS protocol governs how participating applications share information about a virtual world. It specifies packets (Protocol Data Units) that communicate this information and when they are sent. The table lists DIS version numbers and their corresponding formal specifications.

VR-Link's Protocol-Independent API allows creating applications that work in both DIS and HLA without significant modification. This is achieved by writing one application and compiling it for each protocol at compile time, using #ifdef(s) where necessary.

For further information about HLA and DIS, refer to the IEEE 1516 specifications, SISO DLC HLA API 1516, and general DIS information on the Simulation Interoperability Standards Organization (SISO) website.

VR-Link provides classes that facilitate tasks such as connecting to an exercise, managing state information, and interacting with objects. These classes can be categorized into protocol-independent classes and protocol-specific classes.

Protocol-independent classes include:

* Exercise Connection: A class that serves as the application's interface to the RTI or DIS network.
* Object Management Classes: Classes that maintain state information of local and remote objects, and handle sending and receiving of state updates.
* Interaction Classes: Classes that provide a protocol-independent API to HLA interactions or DIS PDUs that represent events.

VR-Link also provides conversion routines, mathematical functions, and other useful functions to make the job of writing an application easier.

The structure of a typical VR-Link application is shown in a figure, which illustrates how classes interact with each other. The application code can interact with classes at any level, but for most applications, it's easier to use protocol-independent classes.

Protocol-independent object management classes include:

* Object Publisher Class: Manages sending updates for locally simulated objects to the exercise.
* Reflected Object Class: Represents a remote object and maintains its current state based on updates received from the exercise.
* Reflected Object List Class: Keeps track of remote objects and creates and destroys reflected objects based on information received from the exercise.

The application connects to an exercise through an exercise connection, which is implemented through the class DtExerciseConn. The member functions of DtExerciseConn allow the application to send interactions to the exercise, read input from the network, generate event IDs, register callback functions, and manage the simulation clock.

Managing state information involves maintaining information about locally simulated entities and communicating this information to other participants in an exercise. This is done through the use of object publishers, reflected objects, and reflected object lists. The figure illustrates how a VR-Link application manages state information.

The text also discusses managing locally simulated entities and remote entities, as well as the importance of minimizing unnecessary network traffic in HLA exercises.

**HLA Federation Execution**

In an HLA federation execution, state updates are sent only when update conditions (specified by the FOM) have been met and a federate has subscribed to the entity attribute that changed.

**Managing Remote Entities**

VR-Link applications receive information about remote entities through the exercise connection. The `DtExerciseConn::drainInput()` function reads and processes input, maintaining a list of remote entities in a `DtReflectedEntityList`. Each entity is represented by a `DtReflectedEntity` that maintains its state in a `DtEntityStateRepository`.

**Managing Interactions**

VR-Link manages interactions (e.g., firing of a munition) through classes derived from `DtInteraction`. Locally-defined interactions are created, set, and sent through the exercise connection. Remote interactions are received through the exercise connection and processed using callback functions.

**Other Simulation Concepts**

The section describes various simulation concepts implemented by VR-Link:

* Time: The toolkit maintains a concept of VR-Link simulation time for dead-reckoning and thresholding.
* Object identification
* Callbacks
* Coordinate systems
* Dead-reckoning and smoothing
* Timestamps

**Code Examples**

No specific code examples are provided in the text. However, it mentions classes such as `DtClock`, `DtReflectedEntityList`, `DtReflectedEntity`, `DtInteraction`, and functions like `DtExerciseConn::drainInput()` and `setSimTime()`.

**Managing Simulation Time**

In a fixed frame rate application, VR-Link simulation time can be managed using a `DtTime` variable (`dt`) and a `simTime` variable that represents the current time. The `setSimTime()` function is used to tell VR-Link the current value of simulation time, and then `simTime` is advanced by `dt`. The application then sleeps until the next multiple of `dt`.

In a floating frame rate application, the current time can be passed to `setSimTime()` each frame.

**Identifying Objects**

HLA and DIS handle object identification differently. In DIS, entities are identified by a triplet (site, application, entity), while in HLA, objects have several identifiers including Object Handle and Object Name.

**Using Callbacks**

Callback functions are used to respond to events in VR-Link. They can be registered using the `addCallback()` static member function of an interaction class or PDU class. The callback function is called when a specified event occurs, such as processing incoming interactions or DIS PDUs.

Other types of callbacks include:

* Entity addition or removal callbacks
* Post-drain callbacks (general-purpose callbacks)

Callback functions must be regular function pointers and cannot be non-static member functions of a class. They can be global functions or static class members. The `usr` argument is used to pass an arbitrary pointer to the callback function, which can be cast back to the object's type within the callback.

**Example Code**

Here is an example of a callback function:
```c
class MyObj {
public:
    void myCallback(void* usr) {
        // Cast usr back to MyObj*
        MyObj* obj = static_cast<MyObj*>(usr);
        // Call a member function on obj
        obj->doSomething();
    }
};
```
Note that this summary focuses on the core information and code examples, while omitting some of the surrounding text.

1. **Callback function**: A static member function `theCallback` is registered with the `DtFireInteraction` class to handle interactions between entities. When called, it takes a pointer to an object as an argument and calls a method on that object.

Example code:
```c
void someFunc();
static void theCallback(DtFireInteraction* inter, void* usr) {
    MyObjType* obj = static_cast<MyObjType *>(usr);
    obj->someFunc();
}
```

2. **Passing multiple objects**: To pass more than one object to a callback function, create a structure containing pointers to the objects and pass a pointer to that structure as `usr`.

3. **Coordinate systems**: VR-Link supports various coordinate systems, including geocentric, UTM, Cartesian, and topographic coordinates. It also provides conversion routines for converting between these systems.

4. **Dead-reckoning and smoothing**: VR-Link uses dead-reckoning to estimate the location of entities between state updates and smoothing to ensure a smooth transition when updated location information arrives.

5. **Timestamps**: When sending interactions or object state updates, VR-Link includes a timestamp with the message. The timestamp indicates the time at which the data is supposed to be valid, but it does not specify the particular hour. The `guessTimeValid()` function can be used to make an educated guess about the full time.

6. **Big and little endian wire formats**: In rare cases, simulations may need to communicate with applications that use little endian wire formats. VR-Link provides functions for setting and inspecting the current wire format at runtime.

The main code example provided is:
```c
int main() {
    DtExerciseConn exConn(...);
    ...
    MyObj obj;
    // Register our callback function, passing a pointer to obj as usr.
    DtFireInteraction::addCallback(&exConn, MyObj::theCallback, &obj);
    ...
}
```

Overall, the text provides an overview of various features and mechanisms used in VR-Link for distributed simulation.

To use little-endian byte ordering in VR-Link, call `DtSetNetworkByteOrdering(DtLittleEndian)`. To change it back to the default (big-endian), call `DtSetNetworkByteOrdering(DtBigEndian)`.

The text then describes two basic VR-Link examples: a listen-only application and a send-only application. The listen-only example is an application that listens to the network without simulating any entities. It includes code snippets from the source file, which can be compiled for either DIS or HLA.

The main function of the listen-only example initializes a connection to an exercise or federation execution using `DtVrlApplicationInitializer`. It then registers a callback to handle fire interactions and creates an object to manage entities heard on the network. The code processes incoming messages, finds the first entity in the reflected entity list, and prints its updated position.

The text also provides examples of connecting to an exercise and managing state and interaction information using callbacks. For example, a callback named `fireCb` is registered with the `DtFireInteraction` class to handle fire interactions and print a message containing the attacker ID.

Overall, this summary preserves the core information and code examples from the original text while condensing it into a more concise format.

**Tracking Entities**

The program creates a reflected entity list to track entities found on the network (line 40). This list tracks arrival and departure of entities, performs dead reckoning, manages time outs, and performs other entity-tracking tasks.

**Managing Time**

The program obtains a pointer to the simulation clock from the exercise connection (line 43).

**Listening to the Network**

At each iteration, the program sets VR-Link simulation time (line 53) and reads and processes any messages arriving through the exercise connection using drainInput() (line 56). The program then retrieves the entity's state repository (line 64), creates a topographic view of it (lines 69-70), and obtains and prints the dead-reckoned entity location (line 76).

**Send-Only Example**

The Send-Only application simulates the flight of an F18 aircraft. The program sends a fire PDU or HLA fire interaction, then updates its position by sending DIS entity state PDUs or HLA attribute updates.

**Code Examples**

Here is the code:
```c
#include <vl/exerciseConn.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>

int main(int argc, char** argv) {
    // Create a connection to the exercise or federation execution.
    DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");

    // ...

    DtExerciseConn exConn(appInit);
    DtEntityType f18Type(DtPlatform, DtPlatformDomainAir, ...);

    // Create an entity publisher for the entity we are simulating.
    DtEntityPublisher entityPub(f18Type, &exConn, ...);

    // Hold on to the entity's state repository, where we can set data.
    DtEntityStateRepository *esr = entityPub.entityStateRep();

    // ...

    while (simTime <= 10.0) {
        // Tell VR-Link the current value of simulation time.
        clock->setSimTime(simTime);

        // Process any incoming messages.
        exConn.drainInput();

        // Set the current position information.
        topoView.setLocation(position);
        topoView.setVelocity(velocity);

        // Call tick, which insures that any data that needs to be updated is sent.
        entityPub.tick();
    }
}
```
**Connecting to an Exercise**

The program creates a `DtExerciseConn` to provide an interface to the RTI or DIS network (lines 17-27).

**Managing Entities**

The program defines the entity type the F18 will use (line 29) and creates a `DtEntityPublisher` to manage the generation of messages for this particular entity (line 33). The entity publisher provides an entity state repository where you can set state values, and a `tick()` function that causes state information to be sent to the network if necessary.

**Sending Interactions**

The program sends an interaction using the exercise connection's `sendStamped()` function (lines 56-58).

Here's a summary of the key points:

* Sending State Updates: The `sendStamped()` function can be used to send state updates, but it is recommended to use the entity publisher to send updates from the entity state repository.
* Compiling for HLA:
	+ Use the `-I` flag to specify the VR-Link header files and RTI include directory.
	+ Define the `DtHLA` macro for conditional compilation.
	+ Link with the `vl`, `matrix`, `mtl`, `vlutil`, `xml2`, and `RTI-NG` libraries.
* Compiling for DIS:
	+ Use the `-I` flag to specify the VR-Link header files.
	+ Define the `DtDIS` macro for conditional compilation.
	+ Link with the `vl`, `mtl`, `matrix`, `vlutil`, and `xml2` libraries.
* Third-Party Libraries: The `libXml2`, `boost`, and `iconv` libraries are required for building VR-Link applications.

The text also provides information on compiling for different protocol versions under Windows, including HLA 1.3, HLA 1516, and HLA Evolved, as well as DIS.

Code examples are not provided in the text, but it does provide detailed instructions on how to compile and link VR-Link applications using various compilers and libraries.

**Compiling for HLA**

* Set `DtHLA=1`, `DtHLA_1516=1`, and `RTI_USES_STD_FSTREAM=1` in the preprocessor definitions.
* Add VR-Link include path and RTI include directory to the additional include libraries.
* In the Linker -> Input section, add the following library files: `libRTI-NG.lib`, `vlHLA13.lib`, `netapi32.lib`, etc.

**Compiling for DIS**

* Set VR-Link include path in the additional include libraries.
* Add the following library files to the Linker -> Input section: `vlutil.lib`, `mtl.lib`, `matrix.lib`, etc.

**Using VR-Link from C**

* To call C++ code from C, create a C++ file with functions that interact with VR-Link code and compile it as a C++ file.
* Use the `extern "C"` keyword to declare functions that can be called from C.
* In the C file, use the `#ifdef __cplusplus` directive to include the declarations of these functions.

**Delivering VR-Link Applications to Users**

* A VR-Link developer's license allows you to compile and run one application using the VR-Link libraries.
* To deliver an application to a user, ensure that they have a VR-Link run-time license.

The customer only needs the VR-Link application, libraries, license management files, and run-time licenses for each instance of the application. They do not need the entire toolkit or developer's license unless they need to recompile the application.

The protocol-independent interface (PII) is a set of classes that allows developers to create applications that work with both DIS and HLA without significant modification. The PII shields developers from the intricacies of the underlying protocol-specific classes and functions, but still provides access to them if needed.

To connect to an exercise using VR-Link, developers can use the DtExerciseConn class, which is a simulation application's interface to an exercise. There are HLA and DIS versions of DtExerciseConn, which exchange data with other applications through different means (RTI for HLA and sockets-related system calls for DIS).

Here is an example of how to create a DtExerciseConn in HLA:
```
DtExerciseConn* conn = new DtExerciseConn("Federation Execution Name", "Federate Name");
```
Alternatively, developers can specify the name of the FED file that they want to use when creating the DtExerciseConn. If no FED file is specified, VR-Link assumes a default file with the same name as the federation execution but with a .fed extension.

The text also provides information on how to initialize applications, send and receive data, and handle post-drain callbacks using the DtExerciseConn class.

**Federation Execution and Federate Names**

* The federation execution name (e.g., VR-Link) determines the FED file to use.
* All applications in the same HLA world must use the same federation execution name and FED file.
* The federate name is a name given to an application, used for RTI diagnostics.

**Creating an Exercise Connection**

* For HLA: specify UDP port number, exercise ID number, site number, and application number.
* For DIS: specify UDP port number, exercise ID number, site number, and application number.
* All applications in the same DIS exercise must use the same UDP port number and exercise ID number.

**Initializing Applications**

* Use `DtExerciseConnInitializer` to specify default initialization values.
* Enable parsing of command line input or loading XML/MTL files using `DtVrlApplicationInitializer`.
* Save state of `DtVrlApplicationInitializer` class to an XML file.

**Command Line Options**

* Protocol-independent options:
	+ Notification level
	+ Log file to use
	+ Notify level in log file to use
	+ Ignore rest of labeled arguments
	+ Display version information and exit
	+ Display usage information and exit
* HLA-specific options:
	+ Execution name
	+ Federate name
	+ FED file name
	+ FOM Mapper library name
	+ FOM Mapper initialization data
	+ RPR FOM revision
	+ RPR FOM version
	+ Disable RTI Compiler version check
	+ Ignore advisories
	+ Federate type
	+ HLA Evolved MIM Module
	+ Add FOM modules

**Example Code**

* Create a connection to the exercise or federation execution:
```c
DtVrlApplicationInitializer appInit(argc, argv, "VR-Link application");
appInit.parseCmdLine();
DtExerciseConn exConn(appInit);
```
Note that this summary focuses on the core information and code examples, while omitting some of the details and nuances mentioned in the original text.

**HLA Evolved Command Line Options**

* `-fomModules <string>`: specifies the FOM modules
* `(-S | --localSettingsDesignator) <string>`: specifies the local settings designator

**Default DIS Command Line Options**

* `(-P | --disPort) port`: sets the DIS port (default: 3000)
* `(-x | --exerciseId) ID`: sets the exercise ID (default: 1)
* `(-a | --appNumber) number`: sets the application number (default: 2)
* `--siteId ID`: sets the site ID (default: 1)
* `(-A | --destAddrString) address`: sets the destination address
* `--deviceAddress address`: sets the device address
* `--sendBufferSize size`: sets the send buffer size (default: -1, use system default)
* `--recvBufferSize size`: sets the receive buffer size (default: -1, use system default)
* `--mcastTtl ttl`: sets the multicast TTL (default: -1, use system default)
* `--mcastAddresses addresses`: sets the multicast addresses
* `--suppressSelfReflect`: suppresses self-reflection (default: false)
* `--useIpv6`: uses IPv6 (default: false)
* `--disVersion <version>`: sets the DIS version

**DtExerciseConn Member Functions**

* `addPostDrainCallback()`: registers a function to be called after drainInput()
* `removePostDrainCallback()`: unregisters a function
* `drainInput()`: reads and processes input from the exercise
* `nextEventID()`: generates consecutive event IDs
* `send()` and `sendStamped()`: sends interaction messages, object updates, and DIS PDUs to the exercise
* `setTimeStampType()`: sets the time stamp type
* `timeStampType()`: returns the time stamp type
* `vrlinkVersion()`: returns the version of VR-Link

**Sending Data to the Exercise**

* Use `send()` and `sendStamped()` to send interactions to the exercise
* Typically, object state information is handled using higher-level object-management classes

**Receiving Data from the Exercise**

* Call `drainInput()` periodically to receive and process information from the RTI or DIS network
* `drainInput()` executes callbacks registered on DtInteractions, DtPdus, and RTI services

**Post-Drain Callbacks**

* Register a callback function using `addPostDrainCallback()`
* Unregister a callback function using `removePostDrainCallback()`
* Post-drain callbacks are called after all interaction, PDU, and RTI service callbacks have been made

The text discusses various aspects of VR-Link, a simulation technology used in exercises. It highlights the following key points:

1. **Post-drain callback**: You can register a response-sending post-drain callback that is executed after all RTI service callbacks have been invoked, when it is safe to send interactions.
2. **Time Stamp Type**: The `setTimeStampType()` function allows you to set the time stamp type of your application to either `DtTimeStampAbsolute` or `DtTimeStampRelative`. This affects how time stamps are used in dead-reckoning calculations.
3. **Initialization Status**: If VR-Link fails during initialization, the default behavior is to abort. You can use the `status` argument in the constructor to store the result of initialization and inspect it later.
4. **Interactions**: Interactions refer to data exchanged among simulation applications to describe events, such as firing a munition or collision of entities. Each type of interaction has its own class, derived from `DtInteraction`.
5. **Sending Interactions**: To send interactions, create an instance of the appropriate interaction class, set values for parameters using mutator functions, and send it using `DtExerciseConn's` `sendStamped()` function.

The code example provided shows how to create and send a fire interaction:
```cpp
// Create an instance of the fire interaction class
DtFireInteraction* fireInteraction = new DtFireInteraction();

// Set values for parameters
fireInteraction->setSenderId(myId);
fireInteraction->setTargetId(targetId);
fireInteraction->setMissileId(missileId);

// Send the interaction using sendStamped()
exerciseConn.sendStamped(fireInteraction);
```
Note that this code assumes `myId`, `targetId`, and `missileId` are existing objects.

**Sending Interactions**

* Use `sendStamped()` to send interactions with a timestamp.
* The timestamp can be obtained using `currentTimeForStamping()` function.
* For DIS, `sendStamped()` also includes the exercise ID in the header.

**Receiving Interactions**

* Incoming interactions are handled through interaction callbacks.
* Register callback functions for a particular interaction type using `addCallback()`.
* Callback functions receive an instance of the interaction class and can process it as needed.
* Example: registering a callback function for `DtFireInteraction`:
```cpp
void myFireCallback(DtFireInteraction* inter, void* usr) {
    // Process the fire interaction
}
DtFireInteraction::addCallback(exerciseConn, myFireCallback, NULL);
```
**Note**

* Interaction callbacks are called in the opposite order from which they were registered.
* Do not attempt to delete or save a pointer to the `DtInteraction` passed to your callback function.

**Making RTI Calls in Response to Interactions**

* In HLA applications, interaction callbacks are called from within `RTI::tick()`.
* Some RTIs do not allow calls to RTI services from within other RTI service calls.
* Use `addPostDrainCallback()` to register a function that will be executed right before `drainInput()` returns, allowing safe RTI calls.

**Example**

```cpp
void sendFire(void *usr) {
    // Create and send a DtFireInteraction
    DtFireInteraction fireInter;
    ...
    exConn->sendStamped(fireInter);
}

void fireCb(DtFireInteraction* inter, void *usr) {
    // Register the sendFire function as a postDrainCallback
    exConn->addPostDrainCallback(sendFire, exConn);
}
```
**Main Function**

```cpp
int main() {
    DtExerciseConn exerciseConn(...);
    ...
    // Register fireCb as a fireInteraction callback
    DtFireInteraction::addCallback(&exerciseConn, fireCb, &exerciseConn);
    ...
}
```

The chapter discusses how to manage entities in VR-Link using publishers, reflected object lists, reflected objects, and state repositories. Entities are objects that have a position in space, such as vehicles or life forms.

To inform other simulation applications about the state of locally-simulated entities, you must create a `DtEntityPublisher` for each entity, update its current state through its `DtEntityStateRepository`, and call the `tick()` function to send updates to the exercise connection.

The chapter provides examples of creating a `DtEntityPublisher` using different constructors. The protocol-independent constructor takes a `DtExerciseConn` and `DtEntityType` as arguments, while the second constructor takes three attributes of an entity that are not likely to change during a simulation: dead-reckoning algorithm, guise (alternate entity type), and force ID.

The chapter also discusses choosing entity identifiers, which is handled differently in DIS and HLA. In HLA, you can choose an object name, while in DIS, the RTI chooses one for you. The chapter provides examples of creating a `DtEntityPublisher` with optional arguments to specify the entity identifier.

Code examples:

* Creating a `DtEntityPublisher`: `DtExerciseConn exConn(...); DtEntityType tankType(1, 1, 225, 1, 1, 0, 0); DtEntityPublisher tankPub(tankType, &exConn);`
* Second constructor: `DtEntityPublisher entityPub(algorithm, guise, forceId);`

Overall, the chapter provides a comprehensive guide to managing entities in VR-Link using publishers, reflected object lists, reflected objects, and state repositories.

To reserve a name for an object, call `rtiAmb()->reserveObjectInstanceName(theName)` and tick the RTI. VR-Link keeps a list of reserved names and checks it when creating a publisher. You can set the number of tries and duration of ticks using static methods in `DtHlaObjectManager`.

You can also make RTI calls to reserve names before creating publishers, which can improve performance. If you omit the identifier argument for `DtEntityPublisher`, VR-Link will choose one for you.

To set an entity's state, use its `DtEntityStateRepository` and update it in each iteration of your simulation. You can get a pointer to the repository using `entityStateRep()` or `esr()`. The repository has mutator functions to set various components of an entity's state, such as location, velocity, acceleration, orientation, and damage state.

Positions, velocities, and accelerations must be set in geocentric coordinates, which are specified in meters. Orientation is specified as a `DtTaitBryan` object, which represents three angles needed to transform from the geocentric coordinate system to the entity coordinate system.

The code examples provided include:

* Reserving an object name: `rtiAmb()->reserveObjectInstanceName(theName)`
* Creating a publisher with an identifier: `DtEntityPublisher tankPub(tankType, &exConn, id);`
* Setting an entity's state: `tankPub.entityStateRep()->setLocation(time, x, y, z);`
* Specifying coordinates and orientation: `DtVector location(1.0, 2.0, 3.0); DtTaitBryan orientation(0.5, 0.6, 0.7);`

The Entity Coordinate System section provides information about converting between rotation matrices and Euler angles, as well as converting among different coordinate systems supported by VR-Link.

A DtEntityStateRepository is used to set the current state of an entity. The following code sample demonstrates how to use the mutator functions to set the location, velocity, acceleration, orientation, and angular velocity of an entity:

```c
DtEntityPublisher tankPub(...);
...
// Grab a pointer to our entity publisher's ESR
DtEntityStateRepository *esr = tankPub.entityStateRep();
// Set location to somewhere near Ft. Hunter Liggett, CA, 
// in geocentric coordinates.
esr->setLocation(DtVector(-2696545.0, -4430407.0, 3701906.0));
// Velocity and acceleration are also in geocentric 
// coordinates
esr->setVelocity(DtVector(100.0, 100.0, 100.0));
esr->setAcceleration(DtVector(0.0, 0.0, 0.0));
// Set orientation as three Euler angles in radians
esr->setOrientation(DtTaitBryan(-2.11, 0.948, 2.469);
// Set angular velocity vector in body coordinates
esr->setRotationalVelocity(DtVector(0.0, 0.10, -0.125);
// Indicate that the entity is on fire
esr->setFlamesPresent(true);
// Indicate that the entity is slightly damaged
// The DtDamageState enumeration is in disEnums.h
esr->setDamageState(DtDamageSlight);
...
```

The `DtEntityPublisher::tick()` function is used to send data to other exercise participants. It decides what data needs to be sent and formats and sends that data through the exercise connection.

Position and orientation thresholds are used to determine when position and orientation data needs to be sent to other exercise participants. The `DtThresholder` class holds threshold values, which can be changed using its mutator functions.

Finally, deleting a `DtEntityPublisher` removes an entity from the exercise. In HLA, the destructor calls the deleteObjectInstance RTI service, while in DIS, it sends a final Entity State PDU with the FinalPdu appearance bit set.

**Working with Remote Entities**

The `DtReflectedEntityList` class maintains the current state of entities learned about through updates received from other participants in an exercise. Each entity is represented by an instance of `DtReflectedEntity`. The list provides member functions to look up entities by local or global ID, iterate through all entities, and more.

**Creating Reflected Entity Lists**

A `DtReflectedEntityList` is created on an exercise connection using the following code:
```c
DtExerciseConn exConn(...);
...
DtReflectedEntityList(&exConn);
```
The list automatically creates a new `DtReflectedEntity` for each new entity and updates existing entities with state updates.

**Iterating Through a DtReflectedEntityList**

To iterate through the list, use the following code:
```c
for (DtReflectedEntity* ent = rel.first();
    ent;
    ent = ent->next())
{
    ...
}
```
You can also use `wrapNext()` and `wrapPrev()` to loop back to the first or last entity in the list.

**Looking Up Entities**

Use the `lookup()` member function to look up a `DtReflectedEntity` by its ID, which can be either global or local:
```c
DtGlobalObjectDesignator id = fireInteraction.targetId();
DtReflectedEntity* ent = reflectedEntityList.lookup(id);
```
**Delayed Discovery of Reflected Objects**

You can delay the discovery of reflected objects until a user-defined condition is met using the `setDiscoveryCondition()` function. This is useful in HLA applications when an object is discovered before attribute information arrives.

Overall, this text provides guidance on working with remote entities in VR-Link, including creating and iterating through reflected entity lists, looking up entities by ID, and delaying discovery of reflected objects until a condition is met.

**Waiting for Entity Type**

To wait until an entity type is known before discovering entities, you can create a function that checks if the entity type matches a specific value and returns `true` or `false`. Then, pass this function to the `setDiscoveryCondition()` method of the `DtReflectedEntityList`.

Example:
```c
bool criteria(DtReflectedObject* obj, void* usr)
{
   DtReflectedEntity* ent = (DtReflectedEntity*) obj;
   if (ent->esr()->entityType() == DtEntityType(0,0,0,0,0,0,0))
   {
      return false;
   }
   return true;
}

DtReflectedEntityList rel(&exConn);
rel.setDiscoveryCondition(criteria, NULL);
```
**Inspecting Entity State**

The `DtReflectedEntity` class uses a `DtEntityStateRepository` to store the current state of an entity. You can inspect individual state data items using inspector functions such as `location()`, `velocity()`, `acceleration()`, and `orientation()`.

Example:
```c
void printStateOfFirstEnt(DtReflectedEntityList *rel)
{
   DtReflectedEntity *firstEnt = rel->first();
   if(!firstEnt) return;
   DtEntityStateRepository *esr = firstEnt->entityStateRep();
   cout << "ID: " << firstEnt->globalId().string() << '\n'
        << "Loc: " << esr->location().string() << '\n'
        << "Vel: " << esr->velocity().string() << '\n'
        << "Accel: " << esr->acceleration().string() << '\n'
        << "Orient: " << esr->orientation().string() << '\n'
        << "AngVel: " << esr->rotationalVelocity().string() << endl;
   if (esr->flamesPresent()) cout << "Flaming!\n";
   if (esr->damageState() == DtDamageDestroyed) cout << "Destroyed!\n";
}
```
**Dead-Reckoning**

By default, the position, velocity, and orientation returned by `DtEntityStateRepository` are dead-reckoned values. This means they may not be the latest values received from the exercise, but rather extrapolated forward based on acceleration, velocity, and angular velocity.

To resolve this issue, you can use the `discoverOnlyWhenEntityTypeKnown()` method to wait until the entity type is known before discovering entities.

**Dead-Reckoning**

* The current value of VR-Link simulation time is the last value passed to `setSimTime()`, which should be called once per frame by an application.
* Dead-reckoning is used to extrapolate position and orientation of entities based on their rates of movement and time since last update.
* There is no performance penalty for calling inspectors more than once during a frame, as long as the value of VR-Link simulation time has not changed.

**Customizing Dead-Reckoning**

* Create a subclass of `DtDeadReckoner` to override `deadReckonPosition()` and `deadReckonOrientation()`.
* Use `useDeadReckoner()` function to set the dead-reckoner for a `DtEntityStateRepository`.

**Dead-Reckoning Algorithms**

* The enums for dead-reckoning algorithms are:
	+ `DtDrDrmRvw` - Rotational, constant acceleration
	+ `DtDrDrmRpw` - Rotational, constant velocity
	+ `DtDrDrmFvw` - Fixed, constant acceleration
	+ `DtDrDrmFpw` - Fixed, constant velocity
	+ `DtDrOther` - No dead reckoning is calculated
	+ `DtDrStatic` - No dead reckoning is calculated

**Smoothing**

* VR-Link can smooth out jumps in entity position using the `DtSmoother` class.
* A `DtSmoother` can be used by a reflected entity's `DtEntityStateRepository` as its `DtDeadReckoner`.
* The values returned by `location()`, `velocity()`, `orientation()` and `bodyToGeoc()` are smoothed values.

**Learning when Entities Join or Leave an Exercise**

* An application can be notified when an entity joins or leaves the exercise.

To receive notifications about entities joining or leaving an exercise in VR-Link, you can register entity-addition and entity-removal callbacks with a `DtReflectedEntityList`. These callbacks are called by VR-Link when an entity is added to or removed from the list.

The callback functions must have the following signature: `void func(DtReflectedEntity* ent, void* userData);`

Here's an example of registering and unregistering callbacks:
```c
void printHello(DtReflectedEntity* ent, void* userData)
{
   assert(ent);
   cout << "HELLO " << ent->id().string() << endl;
}
void printGoodbye(DtReflectedEntity *ent, void *userData)
{
   assert(ent);
   cout << "GOODBYE " << ent->id().string() << endl;
}

int main()
{
   ...
   rel->addEntityAdditionCallback(printHello, 0);
   rel->addEntityRemovalCallback(printGoodbye, 0);
   ...
}
```
Alternatively, you can subclass `DtReflectedEntityList` and override the virtual functions `entityAdded()` and `removeAndDelete()`. The `entityAdded()` function is called just after an entity is added to the list, while `removeAndDelete()` is called before an entity is removed.

When overriding these functions, be aware that they are called from within RTI callbacks, so you should not make any RTI calls or call any functions that make RTI calls from within them.

Additionally, you can register post-update callbacks with a `DtReflectedEntity` to receive notifications when new state data is received. These callbacks must have the same signature as entity-addition and entity-removal callbacks.

Here's an example of registering a post-update callback:
```c
void myPostUpdateCb(DtReflectedEntity* ent, void* userData)
{
   assert(ent);
   // Check for entity type information in the ESR
}

int main()
{
   ...
   rel->addPostUpdateCallback(myPostUpdateCb, 0);
   ...
}
```
Note that post-update callbacks are called immediately after a state update message has been decoded into the reflected entity's `DtEntityStateRepository`, so you can access the updated data within your callback function.

**Post-Update Callback**

The post-update callback mechanism allows you to perform actions after an entity's state has been updated. You can register a callback function using `ent->addPostUpdateCb(myPostUpdateCb, usr)`. The callback function will be called with the updated entity and user data as arguments.

```c
void myPostUpdateCb(DtReflectedEntity* ent, void* usr)
{
    // ...
}
```

**Timing Out Entities**

`DtReflectedEntityList` can time out entities that have not been updated within a certain period of time. This is on by default in DIS, where entities must send periodic heartbeats (usually every 5 seconds). If no heartbeat is received within 12 seconds, the entity can be safely assumed to have left the exercise.

In HLA, there is no heartbeat rule, and timeouts are off by default. You can control timeout processing for individual reflected entity lists using `DtReflectedEntityList::setTimeoutProcessing()`.

**Subclassing `DtReflectedEntity`**

You can subclass `DtReflectedEntity` to associate additional data or functionality with an entity. To do this, you need to subclass `DtReflectedEntityList` as well, overriding the `newReflectedEntity()` function to create instances of your derived `DtReflectedEntity`.

Here is an example:

```c
class myReflectedEntity : public DtReflectedEntity
{
    // ...
};

class myREL : public DtReflectedEntityList
{
    // ...

    virtual DtReflectedEntity* newReflectedEntity(DtHlaObject* obj) const
    {
        return new myReflectedEntity(obj, exerciseConn());
    }
};
```

**Identifying Objects**

HLA and DIS identify objects differently. In DIS, entities are identified by a triplet (site:application:entity) known as an entity identifier, which can be represented using the `DtEntityIdentifier` class.

I hope this summary helps! Let me know if you have any further questions.

In High-Level Architecture (HLA), objects can be identified in several ways:

1. Object handle: an integer or variable-length data that uniquely identifies an object within a federation execution.
2. Object name: a character string that can be used to identify an object, which is known to the RTI and can be chosen by applications or assigned by the RTI.

VR-Link provides two types of identifiers:

1. DtObjectId (local ID): a wrapper around an RTI::ObjectHandle that identifies an object within an application.
2. DtGlobalObjectDesignator (global ID): a wrapper around char* or DtString that can be used to identify an entity in inter-application communication.

Code examples:

* Using a DtObjectId: `DtObjectId objectId = myEntityPub.getObjectId();`
* Using a DtGlobalObjectDesignator: `fireInter.setAttackerId(entityPub.globalId());`

In HLA, objects can also be identified using other attributes defined by the Federation Object Model (FOM), such as EntityID in the RPR FOM.

When constructing an HLA publisher, you can choose a name for your object or pass a NULL name and let the RTI choose one. To reserve a name, call `myExconn->rtiAmb()->reserveObjectInstanceName();`.

The text also discusses managing other types of objects, such as emitters, using subclasses of DtObjectPublisher, DtReflectedObjectList, DtReflectedObject, and DtStateRepository.

Overall, the text provides an overview of how objects are identified in HLA and VR-Link, including code examples for working with object handles, names, and identifiers.

Here is a summary of the key points:

* To manage an entity, read the description and substitute the appropriate object class.
* Emitters are managed using DtEmitterSystemPublisher, DtReflectedEmitterSystemList, and DtReflectedEmitterBeam classes.
* When publishing an emitter system, create the DtEmitterSystemPublisher, obtain a pointer to its DtEmitterSystemRepository, add beams using the addBeam() function, set the beam's parent system ID, and remove beams using the removeBeam() function.
* On the receiving side, create an instance of DtReflectedEmitterSystemList, iterate through or look up systems, and inspect the state of a system's beams using the beamList() member.

The text also provides examples of code snippets for managing emitters, including creating a system publisher, adding a beam, setting the beam's parent system ID, and ticking the system publisher. Additionally, it explains how to look up a DtEmitterBeamRepository on the receiving side and inspect the state of a system's beams.

Finally, the text mentions that VR-Link obtains HLA updates for a beam without having first discovered its parent system by creating a phantom system with the object name indicated by the beam's emittingSystemId attribute.

To create a view, you need to pass the corresponding constructor a pointer to the `DtEntityStateRepository` that you want to access, as well as additional parameters depending on the type of view. For example, `DtTopoView` takes a latitude and longitude (in radians) that define the particular topographic coordinate system.

The views provide inspectors and mutators for accessing and modifying data in the desired coordinate system. The inspectors return values in the specified coordinate system, while the mutators allow you to set new values in the same coordinate system.

Here are some examples of using the views:

**Topographic Coordinate View**

```c
DtEntityPublisher entPub(...);
DtEntityStateRepository* esr = entPub.entityStateRep();
DtTopoView topoView(esr, DtDeg2Rad(36.0), DtDeg2Rad(-121.0));

// Set positions and orientations in topographic coordinates
topoView.setLocation(DtVector(100.0, 100.0, 0.0));
topoView.setVelocity(DtVector(10.0, 10.0, 0.0));
topoView.setAcceleration(DtVector(1.0, 1.0, 0.0));

// Get positions and orientations in topographic coordinates
DtVector topoLoc = topoView.location();
DtVector topoVel = topoView.velocity();
DtVector topoAccel = topoView.acceleration();
```

**UTM Coordinate View**

```c
DtReflectedEntityList rel(...);
...
DtReflectedEntity* ent = rel.first();
DtEntityStateRepository* esr = ent->entityStateRep();
DtUtmView utmView(esr);

// Set positions and orientations in UTM coordinates
utmView.setLocation(DtUtmCoords(100.0, 100.0));
utmView.setVelocity(DtVector(10.0, 10.0, 0.0));

// Get positions and orientations in UTM coordinates
DtUtmCoords utmLoc = utmView.location();
```

**Cartesian Coordinate View**

```c
DtEntityPublisher entPub(...);
DtEntityStateRepository* esr = entPub.entityStateRep();
DtCartesianView cartesianView(esr, DtVector(0.0, 0.0, 0.0), DtDcm());

// Set positions and orientations in Cartesian coordinates
cartesianView.setLocation(DtVector(100.0, 100.0, 0.0));
cartesianView.setVelocity(DtVector(10.0, 10.0, 0.0));

// Get positions and orientations in Cartesian coordinates
DtVector cartesianLoc = cartesianView.location();
```

Note that the `rotationalVelocity()` function is always specified in body rather than geocentric coordinates, so it does not require any conversion when using a view.

**Inspecting Articulated Parts Data**

* The `DtArticulatedPartCollection` class has various inspector functions for examining the state of an entity's articulated parts.
* Use `partCount()` to get the number of articulated parts, and `totalParameterCount()` to get the number of articulation parameters.
* Iterate through the collection using `begin()` and `end()` member functions, which return iterators that can be used to access each `DtArticulatedPart` object.
* Get a list of parameters set for a `DtArticulatedPart` using `getParameterMetrics()`.
* Retrieve the value of a particular parameter using `isParameterSet()` and `getParameterValue()`, or use `getParameter()` to get the non-dead-reckoned value.

**Example Code**

```c
DtReflectedEntityList rel(...);
...
DtReflectedEntity* firstEnt = rel.first();
DtEntityStateRepository* esr = firstEnt->entityStateRep();
DtArticulatedPartCollection* artParts = esr->artPartList();
DtArticulatedPart* turret = artParts->findPart(DtPrimaryTurret1);
float turAz = 0.0;
if (turret)
{
   if (turret->isParameterSet(DtApAzimuth))
   {
      turAz = turret->getParameterValue(DtApAzimuth);
   }
   else
   {
      printf("Entity has no turret azimuth.\n");
   }
}
else
{
   printf("Entity has no turret.\n");
}
```

**The `DtArticulatedPart` Class**

* Get a pointer to a particular `DtArticulatedPart` using `findPart()` or create a new part with `getPart()`.
* Iterate through the collection using a loop:
```c
for (DtArticulatedPartCollection::iterator artPartIter = parts->begin();
     artPartIter != parts->end();
     ++artPartIter)
{
   int currentPartType = artPartIter->first;
   DtArticulatedPart* currentPart = artPartIter->second;
}
```
**Setting Articulated Parts Data**

* An articulated parts collection is empty when it is first created.
* Create articulated or attached parts using `getPart()` member function.

Note that this summary focuses on the key points and code examples, while omitting some of the detailed explanations and technical terms.

**Attaching Parts**

To attach parts in an articulated part collection, call `attachPart()` and pass in pointers to the child and parent parts. By default, parts are attached to the base.

Example:
```c
DtArticulatedPartCollection* artPartCollection = myESR->artPartList();
DtArticulatedPart& turret = artPartCollection->getPart(DtPrimaryTurret1);
DtArticulatedPart& gun = artPartCollection->getPart(DtPrimaryGun1);
artPartCollection->attachPart(&gun, &turret);
```
**Setting Parameters**

To specify parameter values for an articulated part, call `setParameter()` on the part.

Example:
```c
artPartCollection->getPart(DtPrimaryTurret1).setParameter(DtApAzimuth, DtDeg2Rad(myTurretAz));
artPartCollection->getPart(DtPrimaryTurret1).setParameter(
DtApAzimuthRate, DtDeg2Rad(myTurretAzRate));
artPartCollection->getPart(DtPrimaryGun1).setParameter(DtApElevation, DtDeg2Rad(myGunElev));
```
**Attached Parts**

An attached part is an entity that is attached to another entity. `DtEntityStateRepository::attPartList()` returns a pointer to a protocol-independent `DtAttachedPartCollection`.

Example:
```c
// Create the publisher and get its ESR's attached parts list
DtEntityPublisher pub(...);
DtEntityStateRepository* esr = pub.esr();
DtAttachedPartList* attList = esr->attPartList();
// Add a single attached part, a sidewinder missile attached to station number 15
DtAttachedPart& newPart = attList->getPart(15);
newPart.setEntityType(DtEntityType(2, 1, 225, 1, 1, 0, 0));
```
**Using Independent VR-Link Objects in Multiple Threads**

When using VR-Link in multi-threaded applications, be aware of the following:

* Static variables used for initialization should be treated with care if their values might be modified concurrently by multiple threads.
* License management communication with the license server can become confused if two objects try to check out licenses at the same time.

To avoid conflicts, stagger the creation of conflicting objects or use `DtSleep()`.

**Using Independent VR-Link Objects in Multiple Threads (continued)**

When using independent VR-Link objects in multiple threads, you are no longer restricted to using only one map datum or UTM reference point at a time. You can use global functions like `DtSetMapDatum()`, `DtCurrentMapDatum()`, and `DtUtmInit()` without conflicts.

Example:
```c
DtDegMinSec latRef = {35.0, 0.0, 0.0, DtNorth};
DtDegMinSec lonRef = {122.0, 0.0, 0.0, DtWest};
DtUseMapDatum(DtWGS84);
DtUtmInit(latRef, lonRef, 1);  // this will use the global map datum
```
**Controlling MAK Products Remotely**

MAK Data Logger, VR-Vantage, and VR-Forces have remote control APIs that allow you to control them from other applications. The preferred method for controlling these products is to link against the libraries provided with the version of the application that you want to control.

Note: The Stealth Control Toolkit is obsolete and should not be used.

**HLA-Specific Interface**

The HLA-specific interface provides classes and features that are specific to High-Level Architecture (HLA) applications. This chapter describes how to use these classes and features.

**Interacting Directly with the RTI**

Some applications may need to interact directly with the Runtime Infrastructure (RTI) for flexibility or performance reasons. The RTI's API contains two main classes: RTIambassador and FederateAmbassador. When a DtExerciseConn is constructed, it creates instances of both classes.

**Building Applications for Use with the RTI 1516 Specification**

The RTI 1516 API has some differences from the 1.3 version, such as namespace changes and the elimination of AttributeHandleValuePairSet. VR-Link provides wrappers to preserve source compatibility.

**Federate-Initiated Services**

Federate-initiated services can be invoked by making calls to the RTI ambassador's member functions. For example:
```c
DtExerciseConn exConn(...);
...
DtVrlRtiAmbassador* rtiAmb = exConn.rtiAmb();
rtiAmb.queryAttributeTransportationType(...);
```
**RTI-Initiated Services**

RTI-initiated services are invoked when the RTI calls virtual member functions of RTI::FederateAmbassador(). Federates can derive their own class from RTI::FederateAmbassador and provide definitions for these pure virtual functions.

**Subclassing DtVrlFederateAmbassador**

For direct access to data provided by RTI-initiated services, you can derive your own class from DtVrlFederateAmbassador and implement new definitions for the virtual functions in your subclass.

**5.2.3.2 Telling DtExerciseConn About Your Derived Class**

To use a custom subclass of `DtVrlFederateAmbassador`, you need to tell `DtExerciseConn` about it using the `setFedAmbCreator()` function. This function expects a `DtFedAmbCreator()` function that returns an instance of your subclass.

Example:
```c
class MyFedAmb : public DtVrlFederateAmbassador {
    // ...
};

DtVrlFederateAmbassador* MyFedAmbCreator() {
    return new MyFedAmb();
}

DtExerciseConn::setFedAmbCreator(MyFedAmbCreator);
```
**5.3 - Getting Information About the FOM**

When an HLA `DtExerciseConn` is constructed, VR-Link reads the FED file and builds a database of information about the FOM. You can obtain a pointer to the FOM using the `fom()` member function.

Example:
```c
DtFom* fom = conn.fom();
```
The FOM contains a list of object class and interaction class descriptors, which you can query using various member functions such as `interClassByName()`, `objClassByName()`, etc.

**5.4 - Publishing and Subscribing to FOM Classes and Attributes**

Before sending data, HLA federates must publish the set of FOM classes and attributes they are capable of sending. This is done using the `publish()` function.

Example:
```c
conn.publish(objClassDesc);
```
You can also subscribe to classes and attributes using the `subscribe()` function.

Example:
```c
conn.subscribe(interClassDesc, attrHandle);
```
Note that these examples are for HLA 1.3. The code may vary depending on the specific version of RTI you are using.

HLA federates must indicate to the RTI (Run-Time Infrastructure) which FOM (Federate Object Model) classes and attributes they are interested in receiving data from other federates. This initialization activity is called "subscribing". VR-Link applications do not need to do anything special for publishing and subscribing, but if needed, it can be done through VR-Link.

**Publishing Classes and Attributes**

* When creating an object publisher, VR-Link determines which FOM class to use based on the class handle passed to the constructor or by asking the FOM Mapper.
* By default, the full set of valid attributes is published. To publish only a subset of an object class's attributes, explicitly publish the object class with the desired attribute set using `DtObjClassDesc::publish()`.
* Do not publish directly through RTI services as VR-Link cannot know that you have done so and will perform the default publish with all attributes included.

Example:
```c
#include <vlutil/vlStringUtil.h> // For DtToWString

// ...

DtExerciseConn  exConn(...);
...
#if DtHLA
   DtObjClassDesc *desc = exConn.fom()->objClassByName(
      "BaseEntity.PhysicalEntity.Platform.GroundVehicle");
   assert(desc);
   RTI::ObjectClassHandle classHand = desc->handle();
   RTI::AttributeHandleSet hSet;
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(classHand, L"EntityType"));
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(DtToWString("Position")));
   desc->publish(hSet);
#endif
```
**Publishing Interactions**

* Publishing interactions works differently from publishing objects. You cannot publish only a subset of the parameters of an interaction.
* When sending an interaction using `DtExerciseConn::send()` or `DtExerciseConn::sendStamped()`, VR-Link publishes the interaction class if it is not currently published by the federate.

**Subscribing to Classes and Attributes**

* A reflected object list's constructor typically subscribes to object classes. The list determines which FOM classes it is interested in, usually by using the class handles passed to the constructor or by asking the FOM Mapper.
* By default, when VR-Link subscribes to an object class, it subscribes to all attributes of the class.

Example:
```c
// ...

DtList handleList;
handleList.add(new RTI::ObjectClassHandle(
    exConn.rtiAmb()->getObjectClassHandle(L"BaseEntity.PhysicalEntity.Platform.GroundVehicle")));
handleList.add(new RTI::ObjectClassHandle(
    exConn.rtiAmb()->getObjectClassHandle(L"BaseEntity.PhysicalEntity.Platform.Munition")));

// Create the Reflected Entity List
DtReflectedEntityList(&exConn, &handleList);
```
Note that in HLA 1.3, `handleList` is a `DtList` of `RTI::ObjectClassHandles`, cast to `void*`. In HLA 1516, it is a list of pointers to valid `RTI::ObjectClassHandles`.

To subscribe to only a subset of an object class's attributes, use `DtObjClassDesc::subscribe()` instead of `publish()`. Note that direct RTI service subscription is not recommended as it will result in default subscription with all attributes included.

Subscription to interaction classes typically occurs when registering a callback function with a VR-Link interaction class. The RTI API does not allow subscribing to a subset of an interaction's parameters.

The `DtHlaObject` class represents both local and reflected HLA objects. Most entity management functionality is available through VR-Link's protocol-independent layer, but applications may need to interact with `DtHlaObjects` in certain situations.

The `DtHlaObjectManager` class maintains a list of all reflected and locally simulated HLA objects, which can be accessed using the `allHlaObjects()` function. This list is automatically updated whenever an object is discovered or removed by an RTI-initiated service invocation.

Here is an example code snippet that prints the IDs of all objects currently being simulated:
```c
#include <vl/rtiCompatibility.h>
DtExerciseConn exConn(...);
...
// Subscribe to various object classes, process discoverObjects and reflectAttributeValues calls. ...
DtHlaObjectManager* objMgr = exConn.hlaObjectManager();
const DtList& allObjects = objMgr->allHlaObjects();
for (DtListItem* item = allObjects.first(); item; 
   item = item->next())
{
   // Cast the generic void* to a DtHlaObject*
   DtHlaObject* obj = (DtHlaObject*) item->data();
   std::cout << "id: " << obj->objectId() << std::endl;
}
```
The `DtHlaObject` class also provides additional member functions that allow you to obtain more specialized information about an HLA object, such as the set of attributes subscribed to by remote federates and the time of last attribute update received.

The text describes several methods for intercepting events related to HLA (High-Level Architecture) objects in VR-Link. These methods include:

1. Registering "objectAddition" and "objectRemoval" callbacks with a DtReflectedObjectList or deriving from a subclass of DtReflectedObjectList.
2. Using the addDiscoverObjectCallback() function to register a callback for discovering new HLA objects, regardless of class.
3. Using the addRemoveObjectCb() function to register a removal callback directly with a DtHlaObject.

The text also describes an alternate mechanism that works at the level of DtHlaObjects, which allows you to be notified when any object is discovered or removed, regardless of class.

Additionally, the text discusses how to intercept reflected attribute values by registering a postUpdate() callback with a DtReflectedObject or using the addPostReflectCb() function with a DtHlaObject. This allows you to process attribute updates as they arrive.

Finally, the text mentions that when calling DtObjectPublisher::tick(), it calls down to its DtHlaObject's update() function, which decides which attributes need to be sent and then sends them.

Here are some code examples:

* Registering a discoverObject callback:
```
void myDiscoverObjectCb(DtHlaObject* obj, void* usr);
addDiscoverObjectCallback(RTI::ObjectClassHandle(0));
```

* Registering a removal callback:
```
void myRemoveObjectCb(DtHlaObject* obj, void* usr);
addRemoveObjectCallback(objectId);
```

* Intercepting reflected attribute values:
```
void postReflectCb(const DtStateMsg& msg, DtHlaObject* obj, void* usr);
addPostReflectCb();
```

Note that these code examples are just snippets and may require additional context or implementation to work correctly.

1. **Eligible Attributes**: Only published attributes that are subscribed to by remote federates and whose update conditions have been met, or explicitly requested by a remote federate, are eligible to be sent.
2. **ForceUpdate()**: To send updates for eligible attributes even if their update conditions haven't been met, use the `forceUpdate()` function with an attribute set argument. Omitting this argument sends updates for all eligible attributes.
3. **Reflecting Locally-Generated Updates**: VR-Link allows reflecting locally-generated data by calling `setReflecting()` on the `DtExerciseConn` object. This makes objects published and updated locally appear in reflected object lists, with the publisher and reflected object sharing a state repository.

Ownership Management:

1. **HLA Ownership Management Services**: VR-Link supports HLA ownership management services, which allow transferring responsibility for sending updates from one federate to another.
2. **DtHlaObject**: The `DtHlaObject` class encapsulates HLA details and is used by both `DtObjectPublishers` and `DtReflectedObjects`.
3. **Ownership Management Examples**:
	* Acquiring objects
	* Divesting attributes
	* Giving up attributes if requested
	* Acquiring attributes if offered

Code examples are not provided in the text, but the concepts and functions mentioned can be used to implement ownership management and reflecting locally-generated updates in a VR-Link-based HLA environment.

When using VR-Link, there are scenarios where multiple federates can send attribute updates for an object, and some updates might come from the local federate. When a publisher's destructor is called, VR-Link will delete the corresponding HLA object if the local federate owns the `privilegeToDelete` attribute. However, this behavior can be changed using `setDeleteObjInDtorFlag()`.

If an HLA object is deleted by a remote federate, the publisher's `DtHlaObject` pointer will be set to NULL, and subsequent ticks will be no-ops. To be notified when an HLA object is deleted, you can register a `removeObject()` callback using `addRemoveObjectCb()` or an `objectRemoval()` callback for the corresponding `DtReflectedObject`.

Ownership management is recommended when using VR-Link. You can use `setReflecting()` to enable ownership management and ensure that reflected objects contain the complete current state of the object.

The `DtHlaObject` class has member functions that wrap RTI's federate-initiated ownership management services, including `acquireObject()`, `divestObject()`, `unconditionalDivest()`, `negotiatedDivest()`, `acquireAttributes()`, and `cancelNegotiatedDivest()`.

It is recommended to use VR-Link's ownership-related functions instead of calling RTI's functions directly. The `DtOwnershipHandler` class allows you to receive ownership-related callbacks, such as notification when an acquisition or divestiture occurs.

There are three types of `DtOwnershipHandler` classes: `DtDefaultOwnershipHandler`, `DtPartialOwnershipHandler`, and `DtRprOwnershipHandler`. You can use these classes or write your own custom handler.

**Ownership Management**

There are two ways to register ownership handlers: globally using `setDefaultOwnershipHandler` or individually using `setOwnershipHandler()` on `DtHlaObject`.

**Acquiring Objects**

* Create a publisher for an object
* Call `acquireObject()` on the `DtHlaObject`
* Attach a `DtOwnershipHandler` to the object to receive notifications when acquisition succeeds

Example:
```cpp
void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}

// Create the reflected entity list
DtReflectedEntityList rel(...);
...
// Find the entity you are interested in, and grab its DtHlaObject
DtReflectedEntity* ent = rel.lookup(...);
DtHlaObjectWithStateRep* obj = ent->hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
// Create a publisher for the object
DtEntityPublisher pub(obj, obj->exerciseConn());
// Initiate the acquisition. obj->acquireObject();
```

**Divesting Attributes**

* Register an object using a publisher
* Call `unconditionalDivest()` or `negotiatedDivest()` on the `DtHlaObject` to initiate divestiture
* Attach a `DtOwnershipHandler` to the object to receive notifications when another federate assumes ownership

Example:
```cpp
void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}

// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
// Initiate the divest
RTI::AttributeHandleSet* hSet = RTI::AttributeHandleSetFactory::create(3);
hSet->add(1);
hSet->add(2);
hSet->add(3);
obj->negotiatedDivest(*hSet);
delete hSet;
```

**Giving Up Attributes if Requested**

* Create a publisher
* Attach a `DtOwnershipHandler` to the object that accepts all divestiture actions

Example:
```cpp
void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}

// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
```

**Acquiring Attributes if Offered**

* Create a default ownership handler and assign it to the exercise connection
* Set the default acquisition action to always accept all acquisitions
* Add a callback informing you when an acquisition is successful

Example:
```cpp
void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}

DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
myExerciseConnection->setOwnershipHandler(&defaultHandler);
```

**Using DDM**

There are two ways to use Data Distribution Management (DDM) with VR-Link:

* Use the DDM scheme implemented by VR-Link's publishers
* Pass in your own DDM region and manipulate it manually

**Geographic DDM**

* The default VR-Link DDM scheme uses a space named BenchmarkGeographicSpace with two dimensions (X and Y) corresponding to longitude and latitude.
* To enable geographic DDM in the DtExerciseConn, set `exConn.setUseGeographicDdm(true);`.
* The exercise connection has a "playbox" that defines the minimum and maximum values of latitude and longitude for DDM normalization. Default values cover the entire Earth.

**Publishing with Geographic DDM**

* To publish with a geographic region, set `exConn.setUseGeographicDDM(true)` and create an entity or aggregate publisher.
* The publishing region can be accessed and passed to other publishers using `entityPub.publishingRegion()`.

**Reflecting with Geographic DDM**

* Create a geographic region using `DtGeodeticRegion` and pass it into a reflected list using `reflEntList(&exConn, region)`.
* To subscribe to multiple regions, create an STL vector of `DtGeodeticRegionSPs` and pass it into the reflected list constructor.

**Interactions with Regions**

* VR-Link allows sending and receiving interactions in regions.
* The add callback member function of each interaction can take a region shared pointer, and `DtExerciseConn` has a member function to send interactions with regions using `exConn.sendStampedWithRegion(fireInteraction, region)`.

**Using DDM without Geographic Implementation**

* You can create any type of region using the `DtDDMRegion` class.
* Each publisher, reflected list, and interaction can take a `DtDDMRegion`, and will publish or subscribe with whatever `DtDDMRegion` you pass in.

**Using the DtInteraction Class**

* The HLA version of the `DtInteraction` class is defined in `interactionHLA.h`.
* You can use `setExConn()` to set the associated `DtExerciseConn` and `DtInterClassDesc` for a particular instance.

The `setExConn()` function in the `DtInteraction` class allows setting an exercise connection for sending or receiving interactions. If no class descriptor argument is provided, the subclass will choose a default interaction class to publish. VR-Link typically calls `setExConn()` automatically when sending or receiving interactions.

To print a `DtInteraction`, you can use the `print()`, `printHeader()`, and `printParams()` functions. These functions require a valid current exercise connection and class descriptor. You can also use the `setFromPhvps()` or `setFromPhvm()` function to assign a `DtInteraction` from an RTI representation.

The text also discusses generic attributes and parameters, which allow accessing extended information in your FOM that is not normally supported. There are two ways to enable generics: by setting `genericAttributes` to true in the initializer or by enabling unknown parameters for specific classes.

Here is a code example:

```c
DtExerciseConn exConn(...);
...
DtFireInteraction inter;
inter.setAttacker(...);
...
inter.setExConn(&exConn);
inter.print();
```

This code sets an exercise connection and prints a `DtFireInteraction` object.

**5.10 - General HLA Issues**

This section discusses general issues related to High-Level Architecture (HLA) in VR-Link.

**5.10.1 Time Stamps**

* Set and inspect time stamps using `setTimeStamp()` and `timeStamp()` functions.
* Consistent with RPR FOM convention, VR-Link's sending functions encode the time in the "tag" string argument to RTI's sendInteraction() and updateAttributeValue() calls.

**5.10.2 Registering and Responding to Synchronization Points**

* Register synchronization points using `registerSynchronizationPoint()` function.
* Register user-defined callbacks for synchronization points using member functions such as `addSynchPointRegistrationSucceededCb()` and `removeSynchPointRegistrationFailedCb()`.
* Example code:
```c
#include <vl/exerciseConn.h>

void fedsSynched(const char* label, void* /*usr*/)
{
    std::cout << "Federates synched at: " << label << std::endl;
}

int main(int argc, char** argv)
{
    DtExerciseConn exConn(...);
    ...
    // Register callback for federation synchronization
    exConn.addFederationSynchedCb(fedsSynched, NULL);
    ...
}
```
**5.10.2.1 Responding to Synchronization Points Automatically**

* VR-Link applications automatically respond to announced synchronization points by default.
* Disable automatic response using `setReplyingToSynchronizationPoints(false)` function.

**5.10.3 Time Management**

* VR-Link supports HLA Time Management, which allows federates to synchronize and order events with a timeline maintained by the RTI.
* Federation Time (FedTime) is the managed simulation time for an exercise.
* Example calls:
```c
DtExerciseConn exConn(...);
...
// Make time requests and receive time grants from the RTI
exConn.makeTimeRequest();
exConn.getTimeGrant();
...
```
Note that this summary focuses on the core information and code examples, while omitting some details and explanations.

**Time Regulation and Constrained Sending**

* Enable time regulation using `exConn.rtiAmb()->enableTimeRegulation(mySuggestedFedTime, myLookAhead);`
* Enable constrained sending using `exConn.rtiAmb()->enableTimeConstrained();`
* Disable constrained sending using `exConn.rtiAmb()->disableTimeConstrained();`
* Request a time advance using `exConn.rtiAmb()->timeAdvanceRequest(RequestedFedTime);`
* Disable time regulation using `exConn.rtiAmb()->disableTimeRegulation();`

**Sending Time Stamp Order (TSO) Messages**

* Set the flag to attach FedTime to outgoing messages using `exConn.setSendFedTime(true);`
* Use `ExConn.clock()->simTime()` to get the current simulation time
* Maintain simTime as FedTime + LookAhead for message delivery

**Receiving TSO Messages**

* VR-Link handles incoming TSO messages transparently
* The RTI ensures messages are delivered at the correct FedTime

**Using Callbacks**

* Register callbacks using `exConn.fedAmb()->addTimeAdvanceGrantCb(timeAdvanceRequestCb, 0);`
* Handle time advance grant requests using `timeAdvanceRequestCb(const RTI::FedTime &theFedTime, void *userData)`
* Handle time constrained enabled events using `timeConstrainedEnabledCb(const RTI::FedTime &theFedTime, void *userData)`

**Converting FedTime to DtTime**

* Use `DtExerciseConn::setFedTimeToVrlTimeConverter(DtFedTimeToVrlTimeConverter func)` and `DtExerciseConn::setVrlTimeToFedTimeConverter(DtVrlTimeToFedTimeConverter func)`
* Convert between RTI::FedTime and DtTime using `DtExerciseConn::fedTimeToVrlTimeConverter()` and `DtExerciseConn::vrlTimeToFedTimeConverter()`

**VR-Link Calls to RTI Services**

* The following services are called by VR-Link:
	+ createFederationExecution
	+ destroyFederationExecution
	+ joinFederationExecution
	+ resignFederationExecution
	+ publishInteractionClass
	+ publishObjectClass
	+ subscribeInteractionClass
	+ subscribeObjectClassAttributes
	+ unsubscribeInteractionClass
	+ unsubscribeObjectClass

The text describes various services provided by the RTI (Run-Time Infrastructure) in a High-Level Architecture (HLA) system. These services are invoked at different points during the execution of the system.

1. **RTI Services**: The RTI provides several services that can be called by federates, including:
	* `deleteObjectInstance`: Invoked from an object publisher's destructor.
	* `registerObjectInstance`: Invoked from an object publisher's constructor.
	* `requestClassAttributeValue-Update`: Invoked from a reflected object list's constructor.
	* `requestObjectAttributeValue-Update`: Invoked shortly after each reflected object is discovered and created.
	* `sendInteraction`: Invoked from within `DtExerciseConn::send()` or `sendStamped()`.
	* `updateAttributeValues`: Invoked from an object publisher's tick() function.

2. **RTI-initiated Services with Non-NULL Definitions**: The RTI also provides services that are initiated by the RTI itself, including:
	* `startRegistrationForObjectClass`, `stopRegistrationForObjectClass`, `turnInteractionsOff`, and `turnInteractionsOn`: These services are used to manage object classes and interactions.
	* `discoverObjectInstance`, `provideAttributeValueUpdate`, `receiveInteraction`, `reflectAttributeValues`, and `removeObjectInstance`: These services are used to manage reflected objects.

3. **Ancillary Services**: The RTI also provides ancillary services that can be called by federates, including:
	* `getAttributeHandle`, `getAttributeName`, `getInteractionClassHandle`, `getObjectClassHandle`, `getObjectInstanceName`, and `getParameterHandle`/`getParameterName`.

4. **Interoperability between HLA 1.3 and IEEE 1516 Federates**: The MAK RTI supports run-time interoperability between HLA 1.3 federates and IEEE 1516 federates. However, there are some restrictions and requirements to ensure interoperability, including:
	* MOM (Message Ownership Management) must be disabled.
	* Object names must allow conversion from wide char representation to narrow character representation.
	* User-supplied tags must use the 1.3 string format.
	* FOM (Federation Object Model) format must be consistent.

Overall, the text provides a comprehensive overview of the services provided by the RTI in an HLA system and the requirements for interoperability between different versions of the HLA standard.

The architecture for FOM agility consists of two main layers: the top-level FOM-independent API and the FOM Mapping layer. The top-level API provides a way to set and inspect the state of local and remote objects, without regard to how the data is represented in a FOM. The FOM Mapping layer converts data between the FOM-independent API and the specific FOM representation being used.

There are two categories of FOM modifications that developers might implement:

1. FOMs that contain only concepts already present in VR-Link's top-level API, but which may represent them differently.
2. FOMs that include concepts not present in VR-Link's API.

For the first category, developers can switch between FOMs by modifying the FOM Mapping layer without affecting the top-level API. This means that application code written to the top-level API does not need to change when switching between FOMs.

For the second category, developers must extend the top-level API by deriving new classes from VR-Link's base state repository, publisher, reflected object, or reflected object list classes to include their new concepts. Then, they must create mappings from arbitrary FOM representations of these concepts to their new API extensions.

The text also provides examples and documentation on how to implement FOM agility in VR-Link, including the use of a FOM Mapper and the creation of instances of DtInteraction.

Here is an example code snippet that demonstrates how to set up a FOM Mapper's class mappings:
```
// Create a new FOM Mapper
DtFomMapper* mapper = new DtFomMapper();

// Set up the class mappings for the FOM
mapper->addClassMapping("MyObject", "MyFom::MyObject");

// Register the FOM Mapper with VR-Link
VRLink::registerFomMapper(mapper);
```
This code creates a new FOM Mapper and sets up the class mappings for the FOM. It then registers the FOM Mapper with VR-Link, allowing it to be used for FOM agility.

The FOM ( Federated Object Model) Mapping Information Required By VR-Link's API includes:

1. Class mappings: Publishers need to know which FOM object class to choose for locally simulated objects, and which types of objects should be managed by reflected object lists.
2. Attribute and parameter encoding and decoding: Publishers need to decide whether each attribute needs to be sent during a call to tick(), and how to encode values from its state repository into outgoing attribute updates.

To obtain FOM mapping information, top-level API classes use a central repository called a DtFomMapper. The FOM Mapper is obtained from the DtExerciseConn through DtExerciseConn::fomMapper(). 

The DtFomMapper contains class mapping information as well as attribute and parameter encoding and decoding information. It provides functions to obtain FOM mapping information, such as chooseObjectClass().

To set up a FOM Mapper's class mappings:

1. Choose an object class to publish: A DtObjectPublisher asks the FOM Mapper for the name of the FOM object class to use to represent its locally simulated object by calling chooseObjectClass(). 
2. Map a single FOM class to a publisher: Use DtFomMapper::setObjectClassToChoose() to associate a single FOM class with a particular kind of publisher.
3. Map multiple FOM classes to a publisher: Use DtFomMapper::setObjectClassChooser() to associate a class choosing function with the name of a VR-Link class.

Example code:

fomMapper->setObjectClassToChoose("DtAggregatePublisher", "BaseEntity.AggregateEntity");

This sets up a mapping between a particular subclass of DtObjectPublisher and a particular FOM object class.

**Choosing Object Classes**

* A class choosing function looks like this: `char* myClassChooser(const char* vrlinkClassName, DtExerciseConn* conn, void* usr);`
* Associate a class choosing function with a VR-Link publisher class name using `fomMapper->setObjectClassChooser("DtEntityPublisher", myClassChooser);`

**Subscribing to Object Classes**

* A `DtReflectedObjectList` asks the FOM Mapper for the names of the FOM classes to subscribe to and manage, by calling `objectClassNames()`.
* Specify which FOM classes `objectClassNames()` returns using `setObjectClass()` or `setObjectClasses()`.

**Choosing Interaction Classes**

* Choosing an interaction class works similarly to choosing an object class.
* Associate a class choosing function with the VR-Link class name using `fomMapper->setInteractionClassChooser("DtFireInteraction", myChooser);`

**Subscribing to Interaction Classes**

* When you call `addCallback()` on a particular `DtInteraction` subclass, you are saying that you are interested in interactions of that type.
* The `DtInteraction` subclass maps that request to subscriptions to FOM classes using its `interactionClasses()` member function.

**Creating Instances of DtInteraction**

* The final class mapping component is the mapping between FOM classes and functions that create instances of the appropriate `DtInteraction` subclasses.
* Use a `DtInteractionFactory` (defined in `interactionFactory.h`) to manage this kind of mapping.
* Add or change an interaction factory's mappings using its `addCreator()` member function.

Note: I removed some redundant information and reorganized the text to make it easier to read. Let me know if you have any further requests!

**Attribute and Parameter Encoding and Decoding**

A DtFomMapper contains information about how to encode and decode individual attributes and parameters, which are used to convert between RTI messages in FOM representation and VR-Link's DtStateRepositories and DtInteractions.

**Encoders and Decoders**

The core of VR-Link's FOM Mapping functionality is the encoder and decoder classes:

* `DtHlaStateEncoder` (hlaStateEncoder.h)
* `DtHlaStateDecoder` (hlaStateDecoder.h)
* `DtInteractionEncoder` (interactionEncoder.h)
* `DtInteractionDecoder` (interactionDecoder.h)

These classes implement a table-driven approach to attribute encoding and decoding. You can subclass them and override the `encode()` and `decode()` functions, but this is rarely necessary.

**Functions for Encoding and Decoding**

A decoder is implemented as a table of decoding functions, one per FOM attribute or parameter. Each function decodes the attribute or parameter it has been associated with. Similarly, an encoder contains a table of encoding functions.

Encoders and decoders have `addEncoder()`, `addDecoder()`, and `addChecker()` member functions that allow you to register your own encoding, decoding, and checking functions for a particular attribute or parameter.

**Encoder and Decoder Factories**

The encoder and decoder factories are tables of encoders and decoders, one table for each object or interaction class. A DtFomMapper has an encoder factory and a decoder factory for both objects and interactions.

You can add new FOM classes by creating new encoders and decoders and adding them to the factories' tables.

The text describes the form and function of encoding, decoding, and checking functions in VR-Link.

**Decoding Interactions**

* The `DtInteractionDecoder::decode()` function takes an RTI representation of an interaction message (PHVPS) and a pointer to a `DtInteraction` object.
* It goes through each parameter in the PHVPS and calls the associated parameter decoding function.
* Example: Decoding the "RateOfFire" attribute of the RPR FOM class WeaponFire into a `DtFireInteraction`.

**Decoding Object State Updates**

* The `DtHlaStateDecoder::decode()` function takes a `DtStateMsg` (wrapper around AHVPS) and a pointer to a `DtStateRepository`.
* It walks the list of attributes in the message and calls the associated attribute decoding function.
* Example: Decoding the Position attribute of the RPR FOM object class BaseEntity into a `DtEntityStateRepository`.

**Encoding Interactions**

* The `DtInteractionEncoder::encode()` function takes a `DtInteraction` instance containing interaction data and a PHVPS to fill out with the FOM representation of this data.
* It calls the encoding function that has been registered for each parameter in the `DtInteraction`.
* Example: Encoding the "RateOfFire" attribute of the RPR FOM class WeaponFire into a PHVPS.

**Encoding Objects**

* The `DtHlaStateEncoder` contains tables of encoding functions and checking functions.
* It determines which attributes need to be sent by comparing the current state of the object with its previous update.
* Example: Encoding objects using a `DtHlaStateEncoder`.

The text provides code examples for each function, including decoding and encoding interactions and object state updates.

The article discusses the encoding and decoding of data in the HLA (High-Level Architecture) framework. It provides an overview of the encoder and decoder factories used by the FOM ( Federation Object Model) Mapper to perform these tasks.

The `encodePosition` function is provided as an example of how to encode a position attribute into an AHVPS (Attribute Handle Value Pair Set). This function takes three arguments: the state repository containing the current state, the AHVPS to encode into, and the attribute handle of the attribute to be encoded.

Checking functions are also discussed, which take two state repositories as arguments: one holding the current state of the object and one holding the state of the object as it would be seen by remote federates. An example of a checker function is provided for the `DamageState` attribute of the `PhysicalEntity` RPR FOM class.

The article then discusses the encoder and decoder factories used by the FOM Mapper to perform encoding and decoding tasks. These factories include:

* `DtStateDecoderFactory`
* `DtStateEncoderFactory`
* `DtInteractionDecoderFactory`
* `DtInteractionEncoderFactory`

These factories have member functions such as `addEncoder()` and `addDecoder()` that allow you to associate a properly configured instance of an encoder or decoder with each FOM object or interaction class. The article also provides examples of how to use these factories to register encoding, decoding, and checking functions for specific FOM classes.

Finally, the article discusses how to replace any of the factories used by a FOM Mapper using the `factory_typesetFactory()` functions. It also provides an example of how to create a subclass of `DtHlaStateEncoderFactory` and use it with a FOM Mapper.

When constructing a `DtExerciseConn`, you need to choose a FOM Mapper for it to use. There are several ways to do this:

1. **Passing a DtFomMapper instance**: You can pass an instance of a `DtFomMapper` subclass to the `DtExerciseConn` constructor.
```c
MyFomMapper mapper();
DtExerciseConn("VR-Link", "MyAppName", &mapper);
```
2. **Passing the name of a shared library**: You can pass the name of a shared library (DSO or DLL) that contains definitions for the `DtCreateFomMapper` and `DtDeleteFomMapper` functions.
```c
DtExerciseConn(const char* execName, const char* federateName,
               const char* dsoName, const char* fedFileName = NULL,
               void* fomMapInitData = NULL);
```
The shared library should contain the following functions:
```c
extern "C"
{
   DtFomMapper* DtCreateFomMapper(void* usr)
   {
      return new MyFomMapper();
   }
   void DtDeleteFomMapper(DtFomMapper* mapper)
   {
      delete mapper;
   }
}
```
3. **Setting the fallback FOM Mapper creation function**: You can set a fallback FOM Mapper creation function using `DtExerciseConn`'s static `setFomMapperCreator()` member function.
```c
DtExerciseConn::setFomMapperCreator(DtCreateFomMapper* creator);
```
The default fallback function is `DtEmptyFomMapper::create()`, which creates an instance of `DtEmptyFomMapper`.

Note that regardless of how you choose a FOM Mapper, you can always modify or reconfigure it after the `DtExerciseConn` constructor returns.

**DtEmptyFomMapper**: A clean slate FOM Mapper that contains no mappings between VR-Link classes and FOM classes.

**Configuring a FOM Mapper**: After constructing a `DtExerciseConn`, you can configure a `DtFomMapper` using its mutator functions. You can add extra mappings to a FOM Mapper or start with the default `DtEmptyFomMapper`.

**Using Different RPR FOM Versions**: VR-Link supports different versions of the RPR FOM through the `DtRprFomMapper` class, which self-registers mappings for RPR FOM classes, attributes, and parameters. You can specify a version argument when constructing the `DtRprFomMapper`.

**Example Code**:
```c
DtExerciseConn conn("VR-Link", "MyAppName", new DtRprFomMapper(2.0017));
```
**DtSimpleRprFomMapper**: An alternate FOM Mapper that has mappings for a subset of the RPR FOM, which can reduce executable size.

**Deriving Your Own DtFomMapper**: You can create a subclass of `DtFomMapper` to self-register desired mapping information and use it with `DtExerciseConn`. This is how VR-Link uses the `DtRprFomMapper` class for the RPR FOM.

**Example Code**:
```c
class MyFomMapper : public DtEmptyFomMapper {
    virtual void init(DtExerciseConn* conn) {
        // Add mappings and initialization code here
        DtEmptyFomMapper::init(conn);
    }
};
```
**VR-Link FOM Mapping and Extension Examples**: VR-Link includes examples of creating FOM Mappers and extending the top-level API to work with new FOM concepts. The `myFomMap` example shows how to create a FOM Mapper for a new FOM, while the `addAttr` example demonstrates how to extend the RPR FOM by adding new attributes or parameters.

**Extending VR-Link with New Interactions or Objects**

The `testInter` and `testObj` examples demonstrate how to add new interactions or object classes to your FOM, including extending VR-Link's API. The `testSimpInter` example shows a simpler method of working with new interaction classes without using VR-Link's encoder and decoder classes.

**VR-Link Code Generator**

The VR-Link Code Generator is a tool that helps extend VR-Link to handle HLA objects and interactions not part of its internal object model. It generates C++ code based on a FOM definition file (OMT or XML) and produces a project file or Makefile. The generated classes know which object or interaction they correspond to, eliminating the need for separate FOM Mappers.

**Code Generator Limitations**

The Code Generator may not be able to fully generate code for complex FOMs, requiring minor hand editing in some cases. However, MAK is committed to improving the Code Generator and provides standard support for resolving issues with FOMs.

**Installing the VR-Link Code Generator**

The VR-Link Code Generator is installed as part of the VR-Link package in `./bin`.

Note that this summary does not include the detailed instructions on using the VR-Link Code Generator, which are provided in sections 7.2 to 7.5 of the original text.

**Starting the VR-Link Code Generator**

The VR-Link Code Generator can be started from the command line, script, batch file, or Windows Start menu. The command-line syntax is:
```
./bin/vrlcodegenerator [-p <string>] [-I <string>] [-P <string>] [-F <string>] [-O <string>] [-A] [-G] [--] [-v] [-h]
```
**The VR-Link Code Generator Window**

The window has two panes: the left pane lists objects and interactions from the FOM definition file, while the right pane lists the selected objects and interactions for which code will be generated.

**Code Generator Projects**

Projects are used to work with the Code Generator. You can create a new project by choosing "File -> New Project" or clicking the "New Project" button. To load a project, choose "File -> Load Project" or click the "Load Project" button. To save a project, choose "File -> Save Project" or click the "Save Project" button.

**Using the Code Generator**

To use the Code Generator:

1. **Loading a FOM Definition File**: Choose "File -> Import FOM" to load a FOM definition file in XML or OMT format.
2. **Selecting Objects and Interactions to Generate**: Select objects and interactions from the tree view using various methods (e.g., clicking, shift-clicking, control-clicking).
3. **Removing Classes from the Objects to Generate List**: Remove classes by selecting them and clicking the left-pointing arrow.
4. **Customizing Encoders and Decoders**: Customize encoders and decoders for object attributes and interaction parameters before generating code.

Note that some sections (e.g., 7.3 - Code Generator Projects) are not included in this summary as they do not provide new information about the code generator itself, but rather explain how to work with projects.

To customize an object or interaction class's encoders and decoders:

1. Double-click on the class in the Objects/Interactions to Generate pane or right-click and select Customize.
2. The Customize Encoders and Decoders window opens, listing the attributes for the object or interaction.
3. Select the attribute you want to edit and edit the function body as desired (only the function body is editable).
4. Click Save Changes.

Note: When editing an encoder, it's recommended to make corresponding changes to the decoder (and vice versa).

Code Generation Preferences:

1. Namespace: Specify a namespace to avoid name conflicts within VR-Link or application code.
2. Create Include Directory: Place header files in a specified directory relative to the output directory.
3. Prefix Classnames: Add a prefix to class names to prevent conflicts with existing VR-Link classes.
4. 64-bit Linux Makefile: Generate a makefile for building generated code on Linux for 64-bit computers.
5. Generate Examples: Create simple talk and listen examples that demonstrate how an object or interaction is used.
6. Map RTIObjectId to DtGlobalObjectDesignator: Map the RTIObjectId structure to VR-Link's internal DtGlobalObjectDesignator.
7. Generate #error for undecodable attributes: Insert #error statements into output code if it cannot figure out how to generate correct code.
8. Include HLA Standard MIM: Include Management Information Model (MIM) FOM elements that are part of the HLA Evolved standard even if they are not found in the loaded FOM.
9. Generate DIS PDUs: Produce custom DIS PDUs and a protocol-independent API (experimental feature).
10. Save Parse Tree: Save the parse tree for future reference.

These preferences can be set in the ./data/config/codeGenConfig.xml configuration file, the GUI, or both.

**Code Generation Preferences**

* To configure preferences, go to Configuration > Preferences
* Specify namespace, output directory, and other options as needed

**Choosing an Output Directory**

* Go to Configuration > Choose Output Directory
* Select the desired output directory and click OK

**Generating Objects and Interactions**

* Go to Build > Generate or click the Generate button
* The code generator will produce files containing enumerations, data types, net types, and classes for publishing and subscribing objects and interactions

**Generated Code**

* Enumerations: generated as FomNameEnum.h with size determined by definition file type (XML or OMT)
* Data Types: generated as FomNameTypes.h/.cxx and FomNameNetTypes.h/.cxx
* Objects and Interactions: each object generates DtStateRepository, DtObjectPublisher, etc. and each interaction generates DtInteraction, DtInteractionEncoder, etc.
* Project Files and Makefiles: generated for Windows and UNIX platforms to build a dynamic library

**Attributes and Types that Cannot be Decoded and Generated**

* If complex data type contains more than one component of dynamic cardinality, code generator cannot generate decoding
* If attribute or complex data type contains variable size data, code generator cannot generate encoding/decoding
* If complex data type contains variant record, code generator will try to write encoding/decoding code, but it should be considered a guideline and surrounded by #if 0

Note: I removed some redundant information and reorganized the text to make it easier to read. Let me know if you have any further requests!

The DIS Specific Interface section of VR-Link's protocol-independent interface provides functionality for simulations to interact with a DIS exercise. This section describes how to work with Protocol Data Units (PDUs), which are used to send data between applications.

**Sending PDUs**

To send a PDU, use the `DtExerciseConn::send()` or `DtExerciseConn::sendStamped()` functions. The `sendStamped()` function sets the exercise ID and timestamp fields in the PDU header, while `send()` leaves them unmodified. Here is an example of creating and sending a Transmitter PDU:

```c
DtExerciseConn exchange(...);
...
// Create a DtTransmitterPdu
DtTransmitterPdu pdu;
// Fill the PDU with data
pdu.setEntityId(DtEntityIdentifier(1,2,3));
pdu.setRadioId(4);
pdu.setTransmitState(DtOn);
...
// Send to the exercise
exConn.sendStamped(pdu);
```

**Receiving PDUs**

Applications handle incoming PDUs through callbacks. The process is similar to receiving interactions, with additional DIS-specific information. To receive a PDU, register a callback using a PDU class's static `addCallback()` function and use the PDU class's inspector functions to examine the fields of the PDU.

**More Control Over Receiving PDUs**

To give more flexibility and control over reading PDUs from the network, `DtExerciseConn` provides access to the functions used by `drainInput()`. The `drainInput()` function works by repeatedly calling `readAndProcess()`.

Note: The DIS version of `DtExerciseConn` has callback registration and unregistration functions called `addPduCallback()` and `removePduCallback()`, but these should not be used directly by application code.

The `readAndProcess()` function reads a single PDU from the network using `netRead()` and passes it to `processPdu()` for processing. Application code can use these functions instead of calling `drainInput()`.

`netRead()` tries to read a packet from the network, constructs an instance of a PDU class, and returns it. However, successive calls to `netRead()` return PDUs that use the same buffer, so applications must delete each PDU before making another call to `netRead()`. Using `readAndProcess()` or `drainInput()` ensures that each PDU is deleted.

The `netRead()` function has an optional return code argument that indicates the results of the operation. The `readUntil()` function repeatedly reads and processes PDUs until a predicate function returns true or a timeout occurs.

The `DtPdu` class has functions to inspect and set data in a DIS PDU's header, as well as member functions for accessing other fields of various PDUs. The following code examples demonstrate how to use these functions:

* Using `netRead()`:
```c
int retCode;
while (1)
{
   DtPdu* pdu = exConn.netRead(&retCode);
   if (retCode == DtNET_READ_SUCCESS)
   {
      // do something with the PDU
      ...
      delete pdu;
   }
}
```
* Using `readUntil()`:
```c
DtPduKind readUntil(DtPredicate predicate, void* arg, 
                     DtTime timeout, DtTime sleepTime);
```
Code examples for inspecting and setting data in a PDU header are also provided.

The `DtPdu` class has two constructors: a blank PDU constructor and a from-network-representation constructor.

**Blank PDU Constructor**

* Creates a minimal, blank PDU with default values for header information.
* The protocol version is set to `DtProtocolVersionToSend`.
* The PDU kind and protocol family depend on the derived PDU class.
* The length is the PDU's minimal length.
* The exerciseId and time stamp are zero.

**From-Network-Representation Constructor**

* Takes a pointer to a network representation of a PDU as an argument.
* Constructs a `DtPdu` object representing this PDU.
* Rarely used by applications, but commonly used by `DtPduFactory` after receiving a packet from the network.

**Important Notes**

* The `packet()` method returns a pointer to a buffer containing the network representation of the PDU.
* Modifying this buffer is not recommended, as it may lead to inconsistent data and invalid PDUs.
* Use member functions to set values for particular fields instead.
* If you need to directly change the data that will go out to the network, ensure that the buffer represents a valid PDU.

**Code Examples**

* `DtFirePdu pdu();` or `DtFirePdu pdu;`
* `status()` member function can be used to determine whether a `DtPdu` represents valid data after construction.

The `DtPdu` constructors do not verify the status of the PDU, so a status of `DtSTATUS_OK` does not necessarily mean that the PDU is valid. To construct a `DtPdu` object from a network representation of a PDU whose type you don't know, use the `createPdu()` function in `pduFactory.h`.

The `DtPduFactory` class implements "virtual construction" by maintaining a table of associations between PDU kinds and functions that create corresponding PDU class objects. The `createPdu()` function checks the PDU kind in the packet, then passes it to the right creator function from the table.

To get a pointer to the PDU factory used by a `DtExerciseConn`, use `pduFactory()`. To construct a PDU class object using this factory, cast the buffer containing the network representation of the PDU to a `DtNetPacket*` and pass it to `createPdu()`:

```c
DtExerciseConn exConn(...);
...
char *buffer = ...;
DtPduFactory* fact = exConn.pduFactory();
DtPdu* pdu = fact->createPdu((DtNetPacket*) buffer);
```

The `createPdu()` function rejects packets with protocol versions less than `DtProtocolVersionToRecvMin` or greater than `DtProtocolVersionToRecvMax`.

Each PDU class has a static member function called `create()`, which can serve as that PDU's creator function. To register a creator function for a PDU kind, use the `addCreator()` method:

```c
exConn.pduFactory()->addCreator(DtPduKind(10), DtEntityStatePdu::create);
```

A NULL creator function can be added to indicate that there is no PDU class for that kind and `DtUnknownPdu` should be used instead.

Each `DtPdu` object stores a network representation of the PDU it represents. The memory used for this network representation is normally allocated internally by the PDU class constructor and deleted by the destructor. However, in some cases, you might want to use a specific area of memory for storage of its network representation. You can pass a `DtBufferPtr` as an optional buffer argument to the PDU class constructor:

```c
char buffer[144];
DtEntityStatePdu pdu(DtBufferPtr(buffer));
```

This is useful when constructing a `DtPdu` from a network representation of a PDU, and you want to avoid copying the data into a buffer internal to the `DtPdu`.

**Passing External Memory to DtPdu Constructor**

When passing a pointer to external memory to the blank DtPdu constructor, ensure that:

* The buffer is large enough to accommodate the largest network representation.
* The lifetime of the buffer extends for the lifetime of the DtPdu object.
* Modifying the buffer will result in undefined behavior when using mutator or inspector functions.

**Copying PDUs**

DtPdu has a copy constructor and assignment operator overloaded. You can copy data as follows:

```cpp
DtPdu pdu1, pdu2;
pdu1 = pdu2; // pdu1 now contains the same data as pdu2
```

To ensure correct copying of data from one PDU to another, use the network representation of the PDU:

```cpp
DtFirePdu pdu1;
DtFirePdu pdu2((const DtNetFirePdu*)pdu1.netRep());
```

**Getting an Object ID**

The `nextId()` function in `DtExerciseConn` obtains an ID for simulating objects. You can choose your own entity IDs or use this function.

**Working with Non-Standard PDUs**

To work with user-defined PDUs, you can:

* Use `DtUnknownPdu` to represent a PDU (easier for simple PDUs).
* Derive a class from `DtPdu` (more complex but easier to use in your application).

**Using DtUnknownPdu**

Fill a buffer with the exact bytes you want to send on the network and pass it to the `DtUnknownPdu` constructor:

```cpp
char* bfr = new char[sz];
DtFirePdu pdu2((const DtNetFirePdu*)pdu1.netRep(), (DtBufferPtr)bfr);
```

Send the PDU using `DtExerciseConn::sendStamped()`.

**Creating and Sending User-Defined PDUs**

To create and send user-defined PDUs, you can define a structure for your PDU and fill in its fields. Then, create an instance of `DtUnknownPdu` from this network representation and send it using the `exConn.sendStamped()` function.

On the receiving side, you can register callbacks with the `DtExerciseConn` on a particular PDU kind using `addPduCallback()`. When a packet of that kind is received, it creates a `DtUnknownPdu` and passes it to your callback function. You can cast the `DtPdu*` to a `DtUnknownPdu*` within your callback if needed.

**Deriving Classes from DtPdu**

You can derive classes from `DtPdu` to send user-defined PDUs using `exConn.send()` or `exConn.sendStamped()`. When `DtExerciseConn` receives a packet, it creates an object of the appropriate derived class based on the PDU type in the packet.

**Configuring Your Connection to the DIS Network**

The `DtExerciseConn` class has several constructors that create a `DtInetSocket` based on their arguments or take an existing one. The exercise ID is copied into the header of outgoing PDUs and used for filtering incoming PDUs.

You can configure your connection by setting the exercise ID, using asynchronous IO, subscribing to multicast addresses, filtering PDUs, bundling and unbundling PDU packets, sending packets using `DtInetSocket`, and receiving packets using `DtInetSocket`.

The code examples provided demonstrate how to create a user-defined PDU, send it, and receive it on the other side.

The `DtExerciseConn` class receives unicast or broadcast packets destined for the computer on a specified port and sends packets to the broadcast address of the primary network interface by default.

There are three constructors for `DtExerciseConn`:

1. The first constructor takes four arguments: port number, exercise ID, site ID, and application number.
2. The second constructor takes five arguments: port number, exercise ID, site ID, application number, and a destination address (which can be unicast, multicast, or broadcast).
3. The third constructor takes a pointer to a `DtInetSocket` object, giving full control over how the socket is created.

The `DtDisSocket` class is a subclass of `DtInetSocket` that helps send and receive DIS PDU's. It has several optional parameters:

* Local port number
* Interface to use
* Socket flags (which can be bitwise OR'd with options defined in `vlInetSocket.h`)
* Flag to open the socket immediately
* Flag to filter out PDU's sent by itself

To create a `DtDisSocket`, you need to pass in a `DtInetEndpoint` object, which describes the destination address and port of DIS PDU's. You can also specify additional parameters such as local port number, interface, and socket flags.

The `DtExerciseConn` class supports asynchronous IO for DIS using the `useAsynchIO()` member function. This creates two threads that read and write to the network: one thread reads packets from the network and places them on a queue, while another thread sends packets to the network as soon as possible.

Here are some code examples:

* Creating a `DtExerciseConn` object with a destination address:
```c
DtExerciseConn(3000, DtInetAddr("207.86.232.1"));
```
* Creating a `DtDisSocket` object with optional parameters:
```c
DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"), 3300);
DtInetDevice deviceToUse(DtInetAddr("192.168.0.1"));
DtDisSocket* sock = new DtDisSocket(endpoint, 0, deviceToUse); 
```
* Creating a `DtExerciseConn` object with asynchronous IO enabled:
```c
DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"), 3300);
DtDisSocket *netSocket = new DtDisSocket(endpoint, 0, 0, (DtDefaultSockOpts | DtAsyncReadWrite));
DtExerciseConn  *exConn = new DtExerciseConn(netSocket, exerciseId, siteId, applicationNum );
```
Note that the `useAsynchIO()` member function can also be set to true when creating a `DtExerciseConn` object.

**Asynchronous IO**

* Asynchronous IO is not faster, but it can help reduce dropped packets if your simulation has well-separated spikes of network traffic.
* To enable asynchronous IO, use `appInit.setUseAsynchIO(true)`.

**Multicast Addresses**

* `DtExerciseConn` allows subscription to one or more multicast addresses between 224.0.0.0 and 239.255.255.255 (excluding 224.0.0.x).
* Use `addInterestInMcastAddr()` to indicate interest in a particular multicast address, and `subtractInterestInMcastAddr()` to stop receiving packets on that address.
* Different code modules can add or subtract interest independently.

**Filtering PDUs**

* A `DtExerciseConn` can filter out PDUs based on certain criteria using `disableFiltering()` and `enableFiltering()`.
* By default, packets with unexpected protocol versions and exercise IDs are filtered out.
* Use `addInterestInPduKind()` to add interest in a specific PDU kind, and `subtractInterestInPduKind()` to remove it.

**Bundling and Unbundling**

* Bundling is off by default, but can be turned on using `setBundling()`.
* Pass the desired maximum size for a packet as the second parameter.
* When bundling is on, a sequence of packets are concatenated together until the bundle size exceeds the maximum size.
* Use `flush()` to send the current bundle and ensure that all packets generated during a frame get sent before the next frame begins.

**Code Examples**

* To turn on bundling with a max size of 1464 bytes: `disSocket.setBundling(1464, true, 0, 0, 0, 0);`
* To turn off bundling: `disSocket.setBundling(0, false, 0, 0, 0, 0);`

**Unbundling and Receiving Packets**

When unbundling is enabled, successive calls to the receive function return successive PDUs from a packet. If unbundling is disabled, but a bundled packet is received, all but the first PDU in the packet is ignored.

**Sending Packets**

To send packets with any DtInetSocket class, use either the `send()` or `sendTo()` member function of the DtInetSocket. The socket's `send()` member function returns the number of bytes sent, or -1 if the packets cannot be sent.

**Receiving Packets**

To receive packets with any DtInetSocket class, use the `recv()` member function to read the next packet available. The return status can be checked to determine the status of any of the receive calls.

**Intercepting Incoming Entity State PDUs**

There are two ways to intercept incoming entity state PDUs:

1. Register a callback on entity state PDUs.
2. Override `DtReflectedEntity::processEntityState()` and dispatch it to a callback registered with the `DtExerciseConn`.

**Setting Different Heartbeats in DIS 7**

To set the heartbeat of an object based on its entity type, class type, or whether or not it is moving:

* Use `setStationaryDfltTimeThreshold()` for non-moving entities.
* Use `setEntityTypeDfltTimeThreshold()` to set the heartbeat by entity type.
* Use `setClassDfltTimeThreshold()` to set the heartbeat by class type.

Example code:
```c
DtEntityPublisher::setStationaryDfltTimeThreshold(20.0);
DtEntityPublisher::setEntityTypeDfltTimeThreshold(DtPlatform, DtPlatformDomainAir, 1.0);
DtIffPublisher::setClassDfltTimeThreshold(10.0);
```
Note that you can still set a single heartbeat value for every DIS object using `setDfltTimeThreshold()`.

**9 - Writing Applications Using the C# API**

The chapter explains how to develop applications using the VR-Link C# library. It references the F-18 example to illustrate concepts and includes example code.

**9.1 - Introduction to the C# API**

* The C# API is built with Microsoft Visual Studio, using both 32-bit and 64-bit compilers.
* It is built against the VR-Link version and uses the 32-bit and 64-bit libraries.
* It is also built on the .NET Framework.

**9.2 - Adding the VR-Link for C#.dll to Your Project**

* Add vrLinkSharp.dll reference to your project by right-clicking on your project, selecting "Add Reference", and navigating to the ./bin directory inside the root VR-Link install folder.
* Use the following using statement to access the C# library: `using makVrl;`

**9.3 - Initializing an Exercise Connection**

* Create an exercise connection initializer by specifying the connection type (e.g., DIS, HLA13, HLA1516).
* The `ExerciseConnectionInitializer` class contains one member, the connection type.
* Example code:
```csharp
enum ConnectionType { DIS, HLA13, HLA1516, HLA1516E, WEBLVC };
DisExerciseConnectionInitializer initializer = new DisExerciseConnectionInitializer();
ExerciseConnection exConn = new ExerciseConnection(initializer);
```

**9.4 - Using the Application Initializer Class**

* Use the `ApplicationInitializer` class to handle initialization and command line arguments.
* Example code:
```csharp
Talk-Sharp.exe -C HLA13
```
* The `ApplicationInitializer` can be extended, as shown in the f18Init.cs file.

**9.5 - Publishing Objects**

* VR-Link for C# supplies publishers for objects that it defines.
* Define and initialize a publisher of the right type (e.g., `EntityPublisher`).
* Example code:
```csharp
myEntityPub = new EntityPublisher(myExConn);
```
* Modify the values sent by the publisher using the `EntityStateRepository`.
* Example code:
```csharp
myESR = myEntityPub.esr;
```
* Handle modifying ESR information in a tick() function, which is called every time a threshold is reached.

**Simulation Tick**

The `simTick` method updates the position of an entity by adding its velocity and acceleration multiplied by the time step (`dt`). The updated position is then converted to the correct format using the `coordTrans` function. Finally, the `EntityPublisher.tick()` function is called.

**Reflected Objects**

A reflected object list keeps track of multiple reflected objects and handles callbacks for discovering, updating, and deleting objects. When an object is published from a source that the VR-Link application can receive information from, the reflected object list is notified and updates or deletes the corresponding object accordingly.

**Callbacks and Interactions**

Interactions are handled differently than objects. They are denoted as messages in VR-Link for C#. To send an interaction (e.g., `FireMessage`), create it and send it with the exercise connection using `sendMessage()`. To receive a message, register a callback function using `addMessageHandler()`.

**Plug-ins**

VR-Link programmers can extend the C# API by creating plug-ins. Plug-ins are developed using the C++ SDK and require knowledge of distributed networking concepts and VR-Link (the C++ API). The example Laser Designator plug-in is included with the SDK to demonstrate how to extend VR-Link C#.

The ManagedInterfaceCS library provides C# bindings for the VR-Link and ManagedInterface libraries, allowing C# applications to access their power directly from C#. It communicates with the underlying C++ libraries through a message-passing API.

ManagedInterfaceCS has several key features:

* It receives messages from VR-Link and stores current state in reflected objects.
* It updates objects using VR-Link dead-reckoning and smoothing algorithms.
* Users can extend the built-in message handler to fit their simulation design needs.
* It provides a "Publish" component for passing current state across the language boundary to VR-Link.
* It provides a C# API for filling out and sending messages for events/interactions.

The ManagedInterface class is a singleton that provides a centralized location for registering message decoders, strategies, and resources. It loads plug-ins automatically during startup.

To load a VR-Link C# plug-in, the DLL must be in the plug-ins directory with the distributed VR-Link C# DLLs and export a function with the following name and signature:

```c
extern "C" {
   DLL_EXPORT bool initManagedInterfaceModule( DtManagedInterface* gl);
}
```

VR-Link C# is protocol-agile, allowing for protocol-specific strategies to be loaded at runtime. It uses a connection initialization procedure to load strategies based on user requests.

The ManagedInterface library has several concepts:

* Strategies: modular components that process object state updates and interactions from VR-Link.
* Resources: shared data structures and classes between strategies, managed by the resource manager.
* Delegates: not mentioned in this text.

Strategies are given CPU time every frame during a tick() function to update internal work. The initialization strategy is responsible for creating other strategies when a network connection is requested.

Resources are generic pointers to objects wrapped in Handles, which can be accessed through the ManagedInterface class. There are several default names used for commonly used objects defined in ManagedInterface/utility.h:

```c
MANAGEDINTERFACE_DLL extern const char* EXERCISE_CONNECTION_NAME;
MANAGEDINTERFACE_DLL extern const char* CLOCK_NAME;
MANAGEDINTERFACE_DLL extern const char* REFLECTED_ENTITY_LIST_NAME;
MANAGEDINTERFACE_DLL extern const char* ENTITY_PUBLISHER_LIST_NAME;
```

These defined names provide a uniform way to access commonly used objects, such as the VR-Link DtExerciseConnection or the DtClock.

The provided text discusses various utility functions for accessing commonly used objects in ManagedInterface, as well as delegates, messages, and code generation.

**Utility Functions**

The following utility functions are available:
```c
MANAGEDINTERFACE_DLL DtExerciseConn* findExConnResource();
MANAGEDINTERFACE_DLL void setExConnResource(DtExerciseConn* conn);
MANAGEDINTERFACE_DLL DtReflectedEntity* findReflectedEntityResource(std::string id);
MANAGEDINTERFACE_DLL void setReflectedEntityResource(std::string id, DtReflectedEntity* ent);
MANAGEDINTERFACE_DLL DtEntityPublisher* findEntityPublisherResource(std::string id);
MANAGEDINTERFACE_DLL void setEntityPublisherResource(std::string id, DtEntityPublisher* pub);
MANAGEDINTERFACE_DLL DtClock* findClockResource();
MANAGEDINTERFACE_DLL void setClockResource(DtClock* clock);
MANAGEDINTERFACE_DLL DtReflectedEntityList* findReflectedEntityListResource();
MANAGEDINTERFACE_DLL void setReflectedEntityListResource(DtReflectedEntityList* rel);
```
**Delegates**

Delegates are C++ classes that wrap a function to callback at a later time. They are used for message handlers registered with ManagedInterface.

**Messages**

VR-Link communicates with VR-Link C# through messages, which are serialized into a byte buffer and sent to VR-Link C# through a simple API. Messages can serialize and deserialize themselves. Adding new messages requires creating a C# implementation and a C++ implementation using code generators and a message definition language.

**Message Definition Language**

The message definition language is written in Lua and uses the "MESSAGE" keyword followed by the message layout and configuration in a key:value pair table.
```lua
MESSAGE{
   fileName="transmitterState";  
   className="TransmitterState";
   includes={};
   dllExport="MANAGEDINTERFACE_DLL";   
   enums={
      TransmitState=[[OFF, RADIO_ON_NOT_TRANSMITTING, ON]];
      InputSource=[[OTHER, PILOT, COPILOT, FIRST_OFFICER, DRIVER, LOADER, GUNNER, COMMANDER, DIGITAL_DATA_DEVICE, INTERCOM]];
      ...
   };
   structs={
      ModulationType={
         {type="enum", name="major", enum="ModulationMajorType"};
         {type="UInt16", name="detail"}; 
         {type="enum", name="system", enum="ModulationSystemType"};
      };
      ...
   };
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="radioId"};
      {type="EntityEnum", name="radioEntityType", new=true};
      ...
   }
}
```
**Message Enums**

Message Enumerations are defined in the enums table. Enumerations are given a name and then a list of enumerated values within double brackets [[ ]].

**Message Structures**

Some messages need to package up several data fields into a single structure. These structures can be defined in the structs table.

**Message Attributes**

Message attributes define the message layout. Attributes can be simple data types, enums, structures, or lists of any of these types.

**Code Generator**

Once the message definition is written, the included code generators generate C++ and C# source code to encode and decode the message data.

The text then describes an example project that demonstrates how to add support for Laser Designators in DIS and HLA using the VR-Link toolkit and library. The project consists of five projects: one for protocol-independent message representations, four for protocol-specific plug-ins, and a strategy project.

The Laser Designator plugin loads messages into the message factory, while the protocol-specific plug-ins load their respective strategies into the strategy factory. The Laser Designator Strategy initializes itself by registering interest in laser object messages with ManagedInterface and creating reflected designator lists to listen for laser designators from the network.

Here is a summary of the code examples provided:

* C++ code generator command-line parameters:
	+ `-i` input file path
	+ `-h` header output directory
	+ `-s` source output directory
* C# code generator command-line parameter:
	+ `-i` input file path
	+ `-o` output directory
* Laser Designator plugin initialization function (`initManagedInterfaceModule`):
```c
bool initManagedInterfaceModule(DtManagedInterface* gl)
{
    // Register message types with the factory
    gl->messageFactory().registerCreator(LaserDesignatorDiscoveryMessage::theMessageName(), LaserDesignatorDiscoveryMessage::decode);
    gl->messageFactory().registerCreator(LaserDesignatorRemovedMessage::theMessageName(), LaserDesignatorRemovedMessage::decode);
    gl->messageFactory().registerCreator(LaserDesignatorStateMessage::theMessageName(), LaserDesignatorStateMessage::decode);
    return true;
}
```
* Protocol-specific plug-in initialization function (`initManagedInterfaceModule`):
```c
bool initManagedInterfaceModule(DtManagedInterface* gl)
{
    // Register strategy with the factory
    gl->addStrategyCreator(DtLaserDesignatorStrategy::theName(), DtLaserDesignatorStrategy::create);
    
    // Add strategy to initialization strategy
    DtInitStrategy* initStr = dynamic_cast<DtInitStrategy*>(gl->findStrategy(DtInitStrategy::theName()));
    if (initStr != NULL)
    {
        initStr->addInitChild(DtLaserDesignatorStrategy::theName());
    }
    else
    {
        DtWarn << "Unable to register Laser strategy with the Initialization strategy for DIS protocol" << std::endl;
    }
    return true;
}
```
* Laser Designator Strategy initialization function (`init`):
```c
bool DtLaserDesignatorStrategy::init()
{
    // Find exercise connection shared resource
    myExconn = findExConnResource();
    
    // Create reflected designator list and install callbacks
    myRelDx = new DtReflectedDesignatorList(myExconn);
    myRelDx->addDesignatorAdditionCallback(&DtLaserDesignatorStrategy::vrlDesignatorDiscovered, this);
    myRelDx->addDesignatorRemovalCallback(&DtLaserDesignatorStrategy::vrlDesignatorRemoved, this);
    
    // Create publisher list and set resources
    myDxPubs = new DtPublisherList<DtDesignatorPublisher>();
    myManagedInterface->setResource("DESIGNATOR_PUBLISHER_LIST", myDxPubs);
    
    myInitalized = true;
    DtDebug << "Laser Designator strategy initialized" << std::endl;
    return myInitalized;
}
```
* Laser Designator Strategy tick function:
```c
void DtLaserDesignatorStrategy::tick()
{
    // Update laser designator publishers to mirror VR-Link C# laser designators
    // ...
}
```

1. `myDxPubs->tick();`: This line of code is used to tick the strategy.
2. Callbacks: Several callbacks are registered with VR-Link and ManagedInterface to handle discovery, removal, and state updates of laser designators from both DIS/HLA network and within VR-Link C#.
3. Message definition: A `.lua` file defines three messages: `laserDesignatorDiscovery`, `laserDesignatorRemoved`, and `laserDesignatorState`. These messages are used to output C# files defining the messages.
4. State repository class: The `laserDesignatorStateRepository` class is derived from the VR-Link C# library class `StateRepository`. It contains a map of class members to their names, allowing for flexible use.
5. Reflected object class: The `ReflectedLaserDesignator` class contains the state repository and provides wrappers around some of its functions.
6. Reflected object list: The `ReflectedLaserDesignatorList` class is used to receive incoming laser designators. It constructs a reflected object list, which registers callbacks for discovery, update, and removal.

The code examples provided include:

* Defining the messages in the `.lua` file
* Creating the state repository class (`laserDesignatorStateRepository`)
* Creating the reflected object class (`ReflectedLaserDesignator`)
* Creating the reflected object list (`ReflectedLaserDesignatorList`)
* Registering callbacks with the exercise connection

The text also mentions delegates for handling specific events, such as `LaserDesignatorDiscoveredCallback`, `LaserDesignatorRemovedCallback`, and `DiscoveryCondition`.

**C# Code**

Two methods are defined to handle messages related to laser designators:

1. `handleLaserDesignatorDiscoveredMessage(Message m)`: Creates a new `ReflectedLaserDesignator` object for the discovered laser designator and adds it to a dictionary.
2. `handleLaserDesignatorUpdatedMessage(Message m)`: Updates an existing `ReflectedLaserDesignator` object or creates a new one if necessary, and then calls the `discoverLasers` method.

A `laserDesignatorPublisher` class is defined to publish laser designators to VR-Link. It has a constructor that takes an `ExerciseConnection` object and a `laserDesignatorStateRepository`. The `tick` method creates a state message from the repository and sends it using the exercise connection. The `dispose` method creates a removed message and sends it when the entity is destroyed.

**Java API**

The Java API chapter explains how to develop applications using VR-Link for Java. It covers topics such as:

1. Running examples
2. Setting up a project with bundled or external native libraries
3. Exercise connections, including initializing an exercise connection and using the `ExerciseInitializer` class
4. Threading
5. Publishing objects
6. Reflected objects
7. Callbacks and interactions

The chapter assumes that the reader has knowledge of the Java language and provides examples from the `./java/examples` directory to illustrate the concepts introduced.

**Key Takeaways**

* In C#, handle laser designator messages by creating a new object or updating an existing one, and then publishing it using an exercise connection.
* In Java, use the VR-Link for Java library to develop applications, which includes both Java code and native platform-specific code.

**Loading Native Libraries**

To load native libraries with the F18 example application:
```
java -cp f18.jar;vrlj.jar com.mak.vrlj.example.f18.F18 --loadPath c:\mak\vrlink5.2\bin
```
For relative classpath, run from VR-Link /bin or /lib directory:
```
java -cp ..\java\listen.jar;..\java\vrlj.jar com.mak.vrlj.example.listen.Listen
```
**Setting up a Project**

Use a javac compiler that supports Java 8. Add the correct jar file to your Java classpath. The basic vrlj.jar file contains no native libraries, so you need to provide the location of the native libraries.

**Bundled Native Libraries**

If using a jar containing native library code, add it to your Java classpath. At runtime, the native code will be loaded from the jar.

**External Native Libraries**

If vrlj.jar is included in the classpath, it contains no native code. Specify the path to shared libraries by calling `setLoadPath()` or using the command line option `-loadPath`.

**Eclipse Setup**

Add vrlj_Xxx.jar (platform-specific with bundled native libraries) or vrlj.jar to your Eclipse project's build path.

To load native libraries:

* Modify Run Configurations to include the required native libraries.
* Call `setLoadPath()` or use `-loadPath` as described above.
* Copy native libraries into your working directory.

**Exercise Connections**

VR-Link applications connect to an exercise through an ExerciseConnection. The interface allows you to send interactions, read input from the network, generate event IDs, register callback functions, and manage the simulation clock.

**Initializing an Exercise Connection**

Create an ExerciseConnection using the `ExerciseConnectionFactory` class. An ExerciseConnection takes responsibility for resources such as network sockets and managed memory.

**ExerciseConnection**

* Implements AutoCloseable interface to simplify use
* Example: `try (ExerciseConnection exConn = ExerciseConnectionFactory.createDefault(initializer)) { ... } catch (Exception e) { ... }`

**ExerciseInitializer**

* Contains information necessary to initialize an ExerciseConnection or use default values
* May contain additional information for user application
* Example: `parseCmdLine(String[] args)` method simplifies parsing command line arguments

**jcommander @Parameter annotation**

* Used to map command line parameters to member variables
* Example: `@Parameter(names = { "--f18Markings" }, description = "hull markings") private final String markings;`

**Threading**

* VR-Link for Java shares a single thread with the application
* Each ExerciseConnection has a `drainInput()` method that performs background processing and must be called periodically
* Note: `drainInput()` MUST be called even if all input is ignored

**Publishing Objects**

* To publish an object to the network, start with a PublisherFactory obtained from an exercise connection
* Example: `PublisherFactory pubFactory = exConn.getPublisherFactory(); ObjectPublisher myEntity = pubFactory.createEntity("myEntityName");`
* Update and publish objects using `tick()` method

**Time-Stepped Loop**

* A common way to write simulation code is to use a time-stepped loop
* Example: `while (simTime <= 10.0) { ... }`

**Reflected Objects**

* A reflected object is a class used to store information about an object that has been discovered, updated, and deleted by the exercise connection
* Each exercise connection tracks all reflected objects in a ReflectedObjectCollection
* Example: `ReflectedObjectCollection collection = exConn.getReflectedCollection();`

Note: I removed some of the text that was not essential to understanding the core concepts and code examples. Let me know if you have any further questions!

**Selection Criteria and Reflected Maps**

* A selection criteria defines a test for inclusion: when applied to an object, it passes (returns true) and is included in the ReflectedMap, or else it fails and is removed.
* Once a collection is created with a specified criteria, the criteria may not be changed. Instead, create a new collection with a different criteria.

**Example Code**

* Print out all reflected Entity objects:
```java
ReflectedEntityMap rem = new ReflectedEntityMap(exConn);
Iterator<Entity> iter = rem.values().iterator();
while (iter.hasNext()) {
    Entity first = iter.next();
    System.out.println(iter.toString());
}
```
* Iterate through all objects and check which are Entity objects:
```java
Iterator<BaseObject<? extends ObjectIdentifier>> objIter = exConn.getReflectedCollection().values().iterator();
while(objIter.hasNext()) {
    BaseObject<? extends ObjectIdentifier> obj = objIter.next();
    if(obj instanceof Entity) {
        Entity e = (Entity) obj;
        System.out.println(e.toString());
    }
}
```

**Callbacks and Interactions**

* Interactions are handled differently than objects. Typically, interactions are created and sent one time, then received and reacted to appropriately.
* An example of such interaction is the FireInteraction.
* Sending an interaction:
```java
FireInteraction fire = new FireInteraction();
fire.setFiringId(myId);
... set other interaction fields as required ...
exConn.send(fire);
```
* Receiving an interaction:
```java
FireInteraction.addListener(exConn, fire -> {
    System.out.print("Fire Interaction from ");
    System.out.println(fire.getFiringId());
});
```

**Example and Utility Applications**

* VR-Link includes a set of supporting applications that can help you develop and troubleshoot your own applications.
* The f18 program simulates a simple HLA or DIS vehicle. It generates predictable HLA entity update messages (or DIS entity state PDUs), so it is a useful tool for debugging applications that receive and interpret these messages.

**f18 Program**

* Command-line options:
```bash
f18 -h

f18 [options...]

Option	Description
-a ID	For DIS, sets the second component of the entity ID to ID.
-d seconds	Set the delay (in seconds) between the time f18 receives a detonation interaction (or PDU), and the time it broadcasts its final message and exits.
-D algorithm	Specifes the dead reckoning algorithm.
-h	Displays a summary of command-line options, then exits.
```

The text describes various command-line options and parameters that can be used to configure the f18 program. These options include:

* -H: specifies the initial heading of the f18 in degrees
* -l: loads a specified MTL configuration file
* -L: specifies the initial position of the f18 in topographic coordinates
* -M: specifies the markings for the f18
* -n: specifies the notification level for warnings
* -O: specifies the reference latitude and longitude for the topographic coordinate system
* -r: specifies the turn radius of the f18 in meters
* -s: specifies the initial speed of the f18 in meters per second
* -T: specifies the entity type as a string

The text also describes HLA-only options, including:

* -f: specifies a FOM Mapper library name
* –fomMapperInitData: specifies FOM Mapper initialization data
* –rprFomVersion: specifies the RPR FOM version

DIS-only options include:

* -A: specifies the default destination IP address for outgoing PDUs
* -I: uses asynchronous IO
* -P: specifies the UDP port
* –recvBufferSize: specifies the receive buffer size
* –sendBufferSize: specifies the send buffer size
* –siteId: specifies the site ID
* -S: subscribes to specified multicast addresses
* –mcastTtl: specifies the multicast time to live
* -V: specifies the DIS protocol version contained in outgoing PDUs
* -x: specifies the exercise ID for DIS

The text also describes how to use a configuration file, including the default f18.mtl file. It explains how to override parameters using command-line options and how to specify a different configuration file.

Additionally, the text discusses various features of the f18 program, including:

* Firing munitions: pressing Enter or Return causes the f18 to fire at another entity
* Reactions to detonate messages: the f18 reacts to detonation PDUs or RPR FOM detonation interactions and can be destroyed if a detonation occurs within a certain range
* Absolute timestamping: the value of the timeStampType flag determines whether absolute or relative timestamps are used in outgoing state update messages
* Using a modified FOM: the config.cxx file shows how to configure VR-Link to use a modified FOM

Overall, the text provides detailed information on configuring and using the f18 program.

The text describes various tools and examples for using VR-Link from different languages and platforms.

* The simpleC example demonstrates how to use VR-Link from within a C language application.
* The launcher example shows how to use articulated and attached parts in VR-Link for both DIS and HLA.
* netdumpDIS is a DIS debugging tool that displays the contents of arriving DIS PDUs in an easy-to-read format. It has several command-line options, including -c (clears the screen), -errorChecking (ignores PDUs with incorrect sizes), -h (displays help), -P (specifies the UDP port), and -v (displays version information).
* netdumpHLA is an HLA debugging tool that listens to an HLA federation execution, subscribes to all object and interaction classes in the FOM, and prints out data whenever it receives an attribute update or interaction. It has several command-line options, including -c (clears the screen), -F (specifies the FED file), -f (specifies a FOM Mapper library name), -h (displays help), -m (subscribes to MOM classes), and -v (displays version information).

The code examples provided are:

* netdumpDIS: `netdumpDIS [-c -errorChecking -h -v -r –verbose -A address -P port -S address –ignore_rest]`
* netdumpHLA: `{netdumpHLA13 | netdumpHLA1516 | netdumpHLA15161e} [– -c -F -f libname –fomMapperInitData data –rprFomVersion version_number -h -M -m -n -r -R -v -x exec-name –ignore_rest]`

Note that the code examples are provided in a format that is easy to read and understand, with clear descriptions of each option and its purpose.

The listen-only example is provided in code form, which includes:

* Includes various VR-Link headers
* Defines a callback function to process fire interactions
* Creates a connection to the exercise or federation execution using `DtVrlApplicationInitializer`
* Registers a callback to handle fire interactions using `DtFireInteraction::addCallback`
* Creates an object to manage entities that are heard about on the network using `DtReflectedEntityList`
* Initializes VR-Link time using `DtClock`
* Processes incoming messages and prints entity positions in topographic coordinates

The code is written for protocol-independence, meaning it can be compiled for either DIS or HLA. The only protocol-specific code is contained in a conditional statement starting at line 27.

The text also describes the process of connecting to an exercise using `DtExerciseConn`, which serves as the program's interface to an exercise.

The code initializes the exercise connection with default protocol-specific values, which can be overridden if needed. It then sets up callbacks for incoming interactions such as fire, detonations, and collisions.

The application also tracks entities found on the network using a reflected entity list, manages time using the simulation clock, and listens to the network by calling `drainInput()` to process any incoming messages.

In the main loop, the code updates the position of an F18 aircraft by sending DIS entity state PDUs or HLA attribute updates. It also sends a fire PDU or HLA fire interaction at the beginning of the simulation.

The code includes several include statements for various VR-Link libraries and defines several constants and variables to control the simulation.

Here is the summarized code:

```c
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>
#include <vl/fireInteraction.h>
#include <vl/iffPublisher.h>
#include <vlpi/EntityTypes.h>
#include <vlutil/vlProcessControl.h>
#include <iostream>

int main(int argc, char** argv) {
    // Create a connection to the exercise or federation execution
    DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");
    
    // Initialize VR-Link time
    DtClock* clock = exConn.clock();
    
    // Main loop
    while (simTime <= 10.0) {
        // Tell VR-Link the current value of simulation time
        clock->setSimTime(simTime);
        
        // Process any incoming messages
        exConn.drainInput();
        
        // Set the current position information
        topoView.setLocation(position);
        topoView.setVelocity(velocity);
        
        // Call tick, which insures that any data that needs to be 
        // updated is sent.
        entityPub.tick();
    }
}
```

Note: The provided code snippet is a part of a larger program and may not be complete or compilable on its own.

**Listen-Only Example**

This program creates a connection to an exercise or federation execution, registers a callback to handle fire interactions, and manages entities that are heard about on the network. The main loop iterates 20 times per second for 10 seconds, updating simulation time, processing incoming data, and printing entity positions.

**Send-Only Example**

This program creates a connection to an exercise or federation execution, defines an entity type (F18), and manages entities using a DtEntityPublisher. The main loop updates the F18's positional data in its entity state repository, ticks the entity publisher to send updated data onto the network, and sleeps until it is time to begin the next iteration.

**Code Examples**

The listen-only example code is provided below:
```c
#include <vl/exerciseConn.h>
#include <vl/exerciseConnInitializer.h>
#include <vl/topoView.h>
#include <vl/entityPublisher.h>
#include <vl/entityStateRepository.h>
#include <vl/fireInteraction.h>
#include <vl/iffPublisher.h>
#include <vlpi/EntityTypes.h>
#include <vlutil/vlProcessControl.h>
#include <iostream>

int main(int argc, char** argv)
{
   try
   {
      // Create a connection to the exercise or federation execution.
      DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");

      // Change some defaults
      #if DtDIS
      appInit.setUseAsynchIO(true);
      #endif

      appInit.parseCmdLine();

      DtExerciseConn exConn(appInit);

      DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
         DtUnitedStates, DtFighter, DtF18, 0, 0);

      // Create an entity publisher for the entity we are simulating.
      DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
         DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 

      // Hold on to the entity's state repository, where we can set data.
      DtEntityStateRepository *esr = entityPub.entityStateRep();

      // Create a topographic view on the state repository, so we 
      // can set position information in topographic coordinates.
      double refLatitude  = DtDeg2Rad(  35.699760);
      double refLongitude = DtDeg2Rad(-121.326577);
      DtTopoView topoView(esr, refLatitude, refLongitude);
   
      // We can use the ESR to set state.
      esr->setMarkingText("VR-Link");
      topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));
 
      // Initialize VR-Link time.
      DtClock* clock = exConn.clock();
   
      DtVector position(0, 0, -100);
      DtVector velocity(20, 0, 0);
 
      // Send a Fire Interaction.
      DtFireInteraction fire;
      fire.setAttackerId(entityPub.globalId());
      exConn.sendStamped(fire);
   
      // Main loop
      DtTime dt = 0.05;
      DtTime simTime = 0;
      while (simTime <= 10.0)
      {
         // Tell VR-Link the current value of simulation time.
         clock->setSimTime(simTime);
 
         // Process any incoming messages.
         exConn.drainInput();
 
         // Set the current position information.
         topoView.setLocation(position);
         topoView.setVelocity(velocity);
 
         // Call tick, which insures that any data that needs to be 
         // updated is sent.
         entityPub.tick();
      
         // Set up for next iteration.
         position[0] += velocity[0] * dt;
         simTime     += dt;
      
         // Wait till real time equals simulation time of next step
         DtSleep(simTime - clock->elapsedRealTime()); 
      }
   
   }
   DtCATCH_AND_WARN(std::cout);
   return 0;
}
```

The send-only example code is not provided in the original text, but it can be inferred from the description.

Here's a summary of the code:

1. Lines 22-25: Create a DtExerciseConn object with a DtVrlApplicationInitializer.
2. Lines 29-31: Define an F18 aircraft type using DtEntityType.
3. Line 32: Create a DtEntityPublisher for the F18 entity.
4. Line 36: Register a fire interaction callback function (fireCb) to handle incoming interactions such as fire, detonations, and collisions.

The main loop iterates over the following steps:

1. Lines 53-54: Set VR-Link simulation time using the elapsed real-time clock.
2. Line 56: Process any incoming messages using drainInput().
3. Line 59: Find the first entity in the reflected entity list.
4. Lines 64-76: Retrieve the entity's state repository, create a topographic view, and print the position of the entity.

The code also includes a keybrdTick function that checks for keyboard input and returns -1 if the user presses 'q' or 'Q'.

Note that some parts of the code are protocol-specific (e.g., DtHLA and DtDIS) and may require modifications depending on the specific use case.

The program creates a connection to an exercise and simulates an F18 entity using the RTI or DIS network. It uses a DtEntityPublisher to manage the generation of messages for this entity.

The main loop executes 20 times per second for 10 seconds, updating the F18's positional data in its entity state repository and sending it onto the network. The program also processes incoming messages with `drainInput()`.

Key code examples:

* Creating a topographic view on the state repository: `DtTopoView topoView(esr, refLatitude, refLongitude);`
* Setting position information using topographic coordinates: `topoView.setLocation(position);`
* Sending an interaction: `exConn.sendStamped(fire);`
* Main loop:
	+ Updating simulation time: `clock->setSimTime(simTime);`
	+ Processing incoming messages: `exConn.drainInput();`
	+ Setting current position information: `topoView.setLocation(position);`
	+ Calling tick to send updated data onto the network: `entityPub.tick();`

The program also uses various utility classes from VR-Link, including vector and matrix classes, coordinate conversion routines, and time-related functions.

Note that this summary focuses on the core code examples and does not include all the details provided in the original text.

**DtVector Class**

* The `DtVector` class represents 3D vectors and has constructors for initializing with values or copying from another vector.
* It also has an assignment operator, equivalence operator, and subscripting operators for accessing individual components.
* A string representation of the vector can be obtained using the `string()` member function.
* Static member functions include `zero()`, `i()`, `j()`, `k()`, and `ones()` to create common vectors.

**DtDcm Class**

* The `DtDcm` class represents 3x3 matrices, also known as direction cosine matrices (DCMs).
* It has constructors for initializing with values or copying from another matrix.
* It also has an assignment operator, equivalence operator, and subscripting operators for accessing individual components.
* A string representation of the matrix can be obtained using the `string()` member function.
* Static member functions include `zero()` and `identity()` to create common matrices.

**Using DtVector and DtDcm**

* These classes are used in VR-Link functions that operate on vectors and matrices.
* They are usually passed by reference or const reference, rather than by pointer.
* The `LibMatrix.h` file contains C-style functions for operating on `DtVector` and `DtDcm`, including addition, subtraction, multiplication, scaling, dot products, cross products, negation, normalization, determinant calculation, transpose, and inverse.

**Orientation and Euler Angles**

* The `DtTaitBryan` class represents a set of three Euler angles (psi, theta, phi) used to represent orientation in VR-Link.
* These angles are used in DIS and HLA RPR FOM to represent the orientation of an entity with respect to the geocentric coordinate axes.

Note that this summary focuses on the core information and code examples provided in the text.

The text discusses the classes and functions used for converting between different coordinate systems in VR-Link. The main classes mentioned are:

* `DtTaitBryan`: represents orientation using three component angles (psi, theta, phi) in radians.
* `DtGeodeticCoord`: represents geodetic coordinates (latitude, longitude, altitude) with inspectors and mutators for getting and setting values.

The text also discusses the following functions:

* `DtEuler_to_BodyToRef()`: converts Euler angles to a rotation matrix (or `DtDcm`) that can rotate from body coordinates to reference coordinates.
* `DtBodyToRef_to_Euler()`: produces Euler angles from the matrix representation.
* `geod.geocentric()`: returns the geocentric equivalent of a geodetic coordinate.
* `getGeocentric()`: sets the value of an existing `DtVector` with the geocentric coordinate.
* `setGeocentric()`: sets the value of a `DtGeodeticCoord` to the latitude/longitude/altitude equivalent of a given geocentric coordinate.

The text also mentions the following concepts:

* Geocentric coordinates: a right-hand Cartesian coordinate system with its origin at the center of the earth.
* Geodetic coordinates: consist of latitude and longitude in radians, and altitude in meters above a reference ellipsoid (default is WGS84).
* Coordinate conversions: can be performed using various functions and classes.

The code examples provided include:

* `DtTaitBryan angles(3.14, 0.0, 1.57);`
* `DtGeodeticCoord myLoc(DtDeg2Rad(45.0), DtDeg2Rad(30.0), 1000.0);`
* `geod.geocentric();`
* `geod.getGeocentric(geoc);`
* `geod.setGeocentric(geoc);`

Overall, the text provides an overview of the classes and functions used for coordinate conversions in VR-Link, along with code examples to illustrate their usage.

**Topographic Coordinates**

VR-Link defines a topographic coordinate system as a right-handed Cartesian coordinate system with X-Y plane tangent to the earth's surface at the origin. A `DtVector` is used to represent a topographic coordinate.

To convert between geocentric and topographic coordinates, use a `DtCoordTransform` object. VR-Link provides the function `DtGeocToTopoTransform()` to initialize a `DtCoordTransform` for you.

Example:
```c
DtCoordTransform geocToTopo;
DtGeocToTopoTransform(DtDeg2Rad(30.0), DtDeg2Rad(100.0), &geocToTopo);
```
This transform can be used to convert from geocentric to topographic coordinates.

**UTM Coordinates**

Locations in the world can be specified using a UTM coordinate system, which is mapped to a reference ellipsoid approximating the surface of the earth using a Universal Transverse Mercator projection. The coordinates consist of easting and northing from an origin or reference location, and an altitude above a reference ellipsoid, all in meters.

To use UTM coordinates, call `DtUtmInit()` with the latitude and longitude of the reference point as arguments.

Example:
```c
DtUtmInit(DtDegMinSec(30.0, 1.0, 0.0), DtDegMinSec(100.0, 0.0, 0.0));
```
This sets up the world location of the origin of your UTM attribute system.

**Heading, Pitch, and Roll**

Converting Euler angles from geocentric to topographic coordinates (or vice versa) is often useful, because topographic-referenced Euler angles correspond to heading, pitch, and roll. Using a `DtCoordTransform` that can convert from geocentric to topographic coordinates, you can obtain an entity's heading, pitch, and roll as follows:

Example:
```c
DtTaitBryan topoEuler;
geocToTopo.eulerTrans(esr->orientation, &topoEuler);
double heading = topoEuler.psi();
double pitch = topoEuler.theta();
double roll = topoEuler.phi();
```
This code converts the entity's orientation from geocentric to topographic coordinates and extracts the heading, pitch, and roll values.

The text describes the `DtDegMinSec` structure and its use in initializing VR-Link's UTM conversion routines. The `DtUtmInit` function takes three arguments: the reference latitude and longitude, and an optional third argument that specifies a convention for eliminating negative numbers in UTM coordinates.

The `DtUtmCoord` class represents a UTM coordinate and has inspectors and mutators to access its components (east, north, up). It also has member functions to convert to and from geocentric or geodetic coordinates. The text provides examples of using these functions, including converting a `DtUtmCoord` object to a `DtGeodeticCoord` object.

The text also highlights the differences between UTM and topographic coordinate systems, noting that while they share the same origin, their Z values represent different things (altitude vs. height above a plane tangent to the earth's surface). It provides diagrams illustrating these differences.

Finally, the text describes lower-level coordinate conversion functions, including `DtDcmVecMul` for multiplying a rotation matrix by a vector, and `DtLatLon_to_GeocToTopo` and `DtLatLon_to_TopoToGeoc` for obtaining rotation matrices to convert between geocentric and topographic frames. An example is provided of using these functions to rotate a velocity vector.

Overall, the text provides a comprehensive overview of VR-Link's UTM conversion routines and coordinate systems, including examples of how to use them in code.

**Coordinate Transformations**

* Use `DtDcmVecMul` to multiply a vector by a rotation matrix.
* Convert Euler angles from one coordinate system to another using `DtEulerToEuler`.
* Obtain an entity's orientation as topographic Euler angles using `esr->bodyToGeoc()` and then converting the result to Euler angles using `DtBodyToRef_to_Euler`.

**Coordinate Locations**

* Transform a location from geocentric to topographic coordinates by subtracting the origin of the second system, performing the rotation, and then adding back the origin.

**Linked Lists (DtList)**

* Use `std::list<>` instead of `DtList`, but `DtList` will continue to be supported for backwards compatibility.
* Create a `DtList` using `DtList list;`.
* Add elements to a `DtList` using `addToStart()`, `addToEnd()`, `addBefore()`, `addAfter()`, or `add()`.
* Iterate through a `DtList` using `first()` and `next()` functions.

**Diagnostic Utilities**

* Use `DtOutputStream` for printing.
* Print diagnostic messages in Windows by setting the global variable `DtNotifyLevel`.
* Set `DtNotifyLevel` to one of the following values: `DtNlFatal`, `DtNlWarn`, `DtNlInfo`, or `DtNlVerbose`.

**DtNlDebug and Printing**

* `DtNlDebug` prints maximum information by default.
* Use `notify level` to control messages generated by your own application.
* VR-Link provides printing functions (`DtFatalPerror()`, `DtWarnPerror()`, etc.) with the same prototype as `printf()`.

**DtOutputStream for Printing**

* `DtOutputStream` is a buffer-based class that allows redirecting messages.
* It works like any standard C++ output stream, e.g., `DtInfo << "something bad just happened..."`.
* Attach `DtOutputStream` to one or more `DtPrinters`, such as `DtFilePrinter`, `DtStdoutPrinter`, etc.

**Printing Diagnostic Messages in Windows**

* In non-console-based Windows applications, use `setFileOutput()` to enable writing to a console window or file.
* Use VR-Link's printing functions (`DtWarn()`, `DtInfo()`, etc.) to ensure diagnostic output is printed.

**DtException Class**

* `DtException` is the VR-Link exception class.
* Member functions may throw exceptions, and the `<<` operator can be used to print exceptions.
* Example: catching an exception with a try-catch block.

**Functions for Manipulating IP Addresses**

* The `vlutil.h` header file provides functions for obtaining and manipulating IP addresses.
* Functions include `DtStringToInetAddr()`, `DtInetAddrString()`, `DtInetAddrOfDevice()`, etc.
* Example: constructing a `DtInetAddr` from a string.

**Miscellaneous Global Functions**

* The following table lists additional miscellaneous global functions:
	+ `DtSleep()` provides a machine-independent way to halt program execution for some period of time.
	+ `DtSelect()` provides a machine-independent interface to the UNIX select system call.

The `DtSelect()` function takes five arguments: 

* A number of file descriptors
* Three arrays of file descriptors to monitor for:
	+ Presence of data to read
	+ Availability for writing
	+ Pending exceptional conditions
* A timeout in seconds

On Windows, a file descriptor of 0 is interpreted as stdin.

The `DtAbort()` function is called when VR-Link generates a fatal error and makes the abort system call. If needed, you can write your own definition for `DtAbort()` to modify its behavior. Note that if your definition is linked into an application through a library, it should appear before `vlutil` on the link line.

No code examples are provided in this text, but I did not lose any core information as per your request.

