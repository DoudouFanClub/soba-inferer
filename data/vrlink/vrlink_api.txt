1 - Introduction
The VR-Link toolkit is an object-oriented library of C++ classes, functions, and definitions that minimize the effort required to create networked simulators and virtual reality applications.

VR-Link's powerful, easy-to-use programmer's interface greatly reduces development cost, time, and risk.

1.1 - The Protocol-Independent API
With VR-Link's protocol-independent API, you can simulate local entities, set their state, and automatically send entity information to other applications over a network using Distributed Interactive Simulation (DIS) or the High-Level Architecture (HLA) Run-Time Infrastructure (RTI).

VR-Link also simplifies receiving and processing information from other applications, providing easy access to the state of remote entities. VR-Link handles dead reckoning, thresholding, responding to attribute requests, filtering, and many other tasks.

Because VR-Link supports both DIS and HLA through very similar APIs, you can often switch your applications between the two by changing just a few lines of initialization code, and recompiling. This means that your VR-Link-based applications can maintain the DIS compliance vital to ongoing projects, while migrating to HLA.

VR-Link implements all DIS PDUs and you can add support for user-defined PDUs.

1.2 - VR-Link Features
Table of Contents
1.2.1 Files and Executables in VR-Link
VR-Link provides a range of features to help you create and maintain HLA and DIS applications:

Exercise Connection: An exercise connection is a VR-Link application's interface to an HLA or DIS exercise. It provides a protocol-independent interface through which to exchange simulation information with other applications, either through the DIS network, or the HLA RTI.
Object tracking: A VR-Link application uses a reflected entity list to keep track of remote participants in your virtual world by processing incoming attribute updates (through either DIS or HLA), and provides a protocol-independent1 interface to their state. It submits update requests as needed, provides notice when an entity enters or leaves an exercise, and performs dead-reckoning, trajectory smoothing, and filtering, as desired. Reflected object lists are available for other types of objects, such as emitters, transmitters, and so on.
Object publishing: A VR-Link application uses an Entity Publisher to keep remote applications informed about the state of entities that you simulate locally. You periodically set the current state of your objects through its protocol-independent interface, and the Entity Publisher automatically sends state updates when data changes or exceeds configurable thresholds. Object publishers are available for other types of objects, such as emitters, transmitters, and so on.
Interaction classes: VR-Link provides a protocol-independent1 interface to the sending and receiving of interaction messages that describe simulation events such as weapon fires, detonations, and radio signal transmissions. C++ classes representing DIS PDUs and HLA interactions usually provide mutator and inspector functions to access each field. Variable length PDUs and parameters are resized transparently. Functions are provided to print human-readable representations of interaction data.
FOM-Agility: While VR-Link comes with built-in support for the RPR FOM, the FOM Mapper class lets you map VR-Link's existing protocol-independent API to another FOM's parameters, attributes, and object or interaction classes. In this way, code that uses the API does not need to change when the FOM changes.
User extensibility: VR-Link's C++ API and implementation allow you to override most of its default functionality through subclassing. You can extend the toolkit to work with new types of HLA object or interaction classes and with new user-defined DIS PDUs. The VR-Link Code Generator can automatically generate the files needed to create new objects and interactions for HLA based on an XML or OMT data definition file.
Access to low-level details: For developers who want to work below the level of abstraction provided by our top-level API, VR-Link provides protocol-specific classes and functions. Low-level access includes direct access to the HLA RTI and to the details of network configuration in DIS.
Utility functions: VR-Link includes a rich set of utility functions, including vector and matrix manipulation functions, a platform-independent interface to the system clock, and support for discreet simulation time. Coordinate conversion utilities for geocentric coordinates, geodetic coordinates, topographic coordinates, and UTM coordinates are included as well.
Example applications: VR-Link comes with a set of HLA and DIS utility programs. For example, the netdump utility prints data received from remote simulations in an easy-to-read format. The f18 utility is a simple networked simulator that serves as a flexible debugging tool. Source code for the examples is provided to demonstrate the use of much of VR-Link's functionality.
You can use VR-Link's C++ interface from C applications.
1.2.1 Files and Executables in VR-Link
VR-Link includes the header files and libraries necessary to build applications based on VR-Link, plus executables and source code for the following utility applications:

F18
DIS Netdump
Talk
Listen.
VR-Link includes source code and executables for the sample applications. The "test" applications show how to extend the features of VR-Link by creating your own PDUs, interactions, encoders, and decoders.

1.3 - Simulation Standards Supported
Table of Contents
1.3.1 Support for the HLA RTI 1.3 and RTI 1516 Specifications
1.3.1.1 Compatibility of RTI 1.3 and RTI 1516 Applications
1.3.1.2 Support for FED and FDD (XML) Files
1.3.2 HLA FOM Support
1.3.2.1 RPR FOM Versions Supported
1.3.2.2 Support for FOM Agility
VR-Link supports HLA and DIS.

For a list of the versions of the simulation standards supported by your release of VR-Link, please refer to your release documentation. You can also check the MAK web site for platform support updates at: http://www.mak.com/support/product-versions.html.

For a brief discussion of DIS and HLA, please see 2.2 - HLA, DIS, and Protocol Independence.

1.3.1 Support for the HLA RTI 1.3 and RTI 1516 Specifications
VR-Link supports the HLA 1.3 specification, the HLA 1516 specification (SISO DLC HLA API), and the HLA Evolved (IEEE 1516-2010) specification. VR-Link's protocol independent interface lets you create applications for use with any version of the HLA largely without regard to the details of the RTI. Any code that you have written for use with the RTI 1.3 specification should be usable with RTI 1516 or HLA Evolved with very few, if any, changes.

VR-Link supports the SISO DLC HLA API 1516 (SISO-STD-004.1-2004). This API supports dynamic link compatibility, which was problematic with the original IEEE 1516 API. The IEEE 1516 API only supports compile time compatibility (uses C++ templates and implementation-specific header files). VR-Link is compatible with any RTI written to the SISO DLC HLA API 1516.

HLA Evolved is the latest version of HLA. It builds on the work done by the SISO DLC HLA API group to provide a dynamic link compatible API. It includes additional features such as FOM modules and update rate reduction.

Note
In most cases, VR-Link's implementation of HLA Evolved is identical to HLA 1516. Therefore, any references to HLA 1516 in this manual should be considered to apply to HLA Evolved as well, unless noted otherwise.
1.3.1.1 Compatibility of RTI 1.3 and RTI 1516 Applications
If you use the MAK RTI, applications built using the VR-Link 1516 APIs can interoperate with applications built with the VR-Link 1.3 API. For example, if you build the listen example with the 1516 API and the talk example with the 1.3 API, they can interoperate. For more information, please see 5.11 - Interoperability Between HLA 1.3 and IEEE 1516 Federates.

1.3.1.2 Support for FED and FDD (XML) Files
VR-Link supports HLA configuration files in both the FED and FDD (XML) formats. When you create an exercise connection, you can specify a .fed file, .fdd file, or .xml file. You can use any of these formats with RTI 1516, HLA Evolved, and RTI 1.3.

If you do not pass a filename to the exercise connection, VR-Link uses the federation execution name as the filename. If you are building for RTI 1516, VR-Link looks for a file name federation_execution.xml. If it cannot find a file with this name, it looks for a file named federation_execution.fdd, then for federation_execution.fed. If you are building for RTI 1.3, VR-Link looks for a .fed file first, then an .xml or .fdd file.

1.3.2 HLA FOM Support
VR-Link provides extensive built-in support for the Real- Time Platform Reference FOM (RPR FOM). (For version information, please see release documentation.) The RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group, which consists of representatives from many companies that used the DIS protocol in the pre-HLA era.

The goal of the RPR FOM is to facilitate a priori interoperability (to about the extent we had in DIS) among HLA simulations that choose to use it. In other words, if you use the RPR FOM (either as is, or with your own extensions), then you know that you will be able to interoperate with anyone else who chooses to use this FOM. Another advantage of using the RPR FOM is that many simulation tools, including those offered by VT MAK, support this FOM.

1.3.2.1 RPR FOM Versions Supported
VR-Link 5.4.1 has built-in support for:

RPR FOM 0.5, 0.7, 0.8, 1.0
RPR FOM 2.0, drafts 6, 14, 17, and 20
RPR FOM 2.
By default, all VR-Link examples use RPR FOM 2.0. The DtVrlApplicationInitializer class, however, still defaults to using RPR FOM 1.0.

VR-Link does not officially support RPR FOM 2 Draft 18. However, the draft appears to be similar enough to RPR FOM 2 Draft 17 that the 2.0017 FOM Mapper may be used for federates wishing to interoperate with RPR FOM 2 Draft 18.

If you want to use a version of the RPR FOM other than 1.0, pass the version number (0.5, 0.7, 0.8, 2.0006, 2.0014, 2.0017, 2.0020, 2.0) to the DtRprFomMapper constructor and pass the resulting object to the DtExerciseConn constructor. Also, make sure you are using a federation execution name that corresponds to the right FED file. For example:

DtExerciseConn conn("MAK-RPR20017-1-1.fed", "MyApp", new DtRprFomMapper(2.0017-1));
VR-Link examples like f18 and hlaNetdump have a command line option, –rprFomVersion, that you can use to choose a RPR FOM version, using one of the version numbers listed in the previous paragraph.

1.3.2.2 Support for FOM Agility
In addition to its built-in support for the RPR FOM, VR-Link can be configured to work with other FOMs, by using its FOM Mapper to define mappings between VR-Link's protocol-independent interface and the objects, interactions, parameters, and attributes defined in your FOM. For more information about VR-Link's FOM Agility, please see 6 - FOM Agility.

VR-Link has a FOM Mapper for the MATREX FOM. For details, please contact your MAK salesperson.

2 - VR-Link Concepts
These pages provide a general explanation of how VR-Link works.

2.1 - VR-Link is a Multi-Layered Toolkit
2.2 - HLA, DIS, and Protocol Independence
2.3 - A Conceptual Overview of VR-Link
2.4 - Connecting to an Exercise
2.5 - Managing State Information
2.6 - Managing Information about Events
2.7 - Other Simulation Concepts
2.8 - Big and Little Endian Wire Formats
2.9 - Basic VR-Link Examples

2.1 - VR-Link is a Multi-Layered Toolkit
Table of Contents
2.1.1 Multiple Layers of Access
VR-Link is a toolkit.

It supplies you with the classes, functions, and utilities you need to write a simulation application, but unlike a framework, it does not provide a structure that you are required to use. For example, you will probably want to check the state of a locally-simulated entity at periodic intervals, but VR-Link does not care whether you do that using a loop (as the Listen example does (Basic VR-Link Examples)), or by using a timer or some other mechanism.

2.1.1 Multiple Layers of Access
As a VR-Link developer, you have several options for approaching application development:

Work through the protocol-independent interface, which with minimal modifications, lets you create applications that work with both HLA and DIS and shields you from many of the intricacies of the underlying protocol-specific classes and functions. Most VR-Link users take this approach.
Go below the protocol-independent interface and take advantage of the protocol-specific classes. Do this if you want to tailor your application to HLA or DIS.
Fully realize the potential of VR-Link and meet your most demanding simulation needs:
Extend VR-Link by creating new classes for HLA objects and interactions or DIS PDUs.
Use the FOM Mapper to support additional FOMs.
Regardless of how you use VR-Link, read VR-Link Concepts, The Protocol Independent Interface, and study the VR-Link Examples. If you focus on a specific simulation standard, read the protocol-specific chapters for that standard. If you want to extend VR-Link, read chapters that describe how to subclass and create your own objects and interactions.

2.2 - HLA, DIS, and Protocol Independence
Table of Contents
2.2.1 The High Level Architecture (HLA)
2.2.1.1 The Federation Object Model (FOM)
2.2.1.2 The Run-Time Infrastructure (RTI)
2.2.2 The DIS Protocol
2.2.3 Protocol Independence
2.2.4 Obtaining Further Information about HLA and DIS
It is beyond the scope of the developers guide to fully describe DIS and HLA.

However, in this section we briefly describe them as a foundation for the concepts and terms discussed in the rest of this chapter.

2.2.1 The High Level Architecture (HLA)
HLA is required by the Department of Defense for use in all DoD simulations. In HLA, the types and formats of data to be exchanged among simulators are not standardized, as they are in DIS. Groups of simulators that want to play together must use the same Federation Object Model (FOM) and Run-Time Infrastructure (RTI). FOMs and RTIs are described in the next two sections.

2.2.1.1 The Federation Object Model (FOM)
Every federation execution requires a Federation Object Model (FOM), which defines the data model for the federation execution. Members of a federation execution can develop a FOM themselves, use an existing reference FOM, or build a FOM by starting with a reference FOM and modifying it.

A FOM is implemented through a Federation Execution Data (FED) file, which contains a subset of the FOM that is required by the RTI. VR-Link has extensive built-in support for the Real Time Platform Reference FOM (RPR FOM). More specifically, VR-Link supports the FOM defined within the FED file called VR-Link.fed, which is stored in the ./bin directory. VR-Link.fed represents the RPR FOM, plus a few extra classes that we have added.

The RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group, which consists of representatives from many companies that used the DIS protocol in the pre-HLA era.

The goal of the RPR FOM is to facilitate a priori interoperability (to about the extent available in DIS) among HLA simulations that choose to use it. In other words, if you use the RPR FOM (either as is, or with your own extensions), then you know that you will be able to interoperate with anyone else who chooses to use this FOM. An advantage of using the RPR FOM is that many simulation tools, including most VT MAK products, support this FOM.

Although VR-Link builds-in support only for the RPR FOM, it has features that allow you to work with new or modified FOMs and you can extend FOMs to meet your needs. The ability to work with a variety of FOMs is called FOM-agility.

You can configure VR-Link to work with other FOMs by using the VR-Link FOM Mapper to define mappings between VR-Link's protocol-independent interface and the objects, interactions, parameters, and attributes defined in the FOM.

For information about how VR-Link implements FOM-agility, please see 6 - FOM Agility. For a list of the RPR FOM versions supported by your version of VR-Link, please see VR-Link Release Notes. You can also view product version information on the MAK web site at http://www.mak.com/support/product-versions.html.

2.2.1.2 The Run-Time Infrastructure (RTI)
An RTI is an implementation of the HLA interface specification, that is, the services that make up the standard RTI application programmer's interface (API). An application can call the functions in the RTI's API either directly or through VR-Link. The HLA rules specify that federates must use the RTI to exchange all simulation data.

2.2.2 The DIS Protocol
The DIS protocol is a set of standards that govern how participating applications share information about a virtual world. The protocol specifies a set of packets, called Protocol Data Units (PDUs), that communicate this information. Each PDU identifies the sender and contains other information, depending on the PDU type. The DIS protocol also specifies when, and how frequently, PDUs are sent.

The table lists the DIS version numbers and their corresponding formal specifications.


DIS Versions
Version	Specification
0	Other
1	DIS PDU version 1.0 (May 1992)
2	IEEE 1278-1993
3	DIS PDU version 2.0 third draft (May 1993)
4	DIS PDU version 2.0 fourth draft (revised) (March16, 1994)
5	IEEE 1278.1-1995
6	IEEE 1278.1A-1998
7	IEEE 1278.1-2012 (DIS Evolved)
2.2.3 Protocol Independence
In this manual, the Protocol-Independent API refers to a set of classes that encompass most of the features of VR-Link and allow you to create applications that will work in both DIS and HLA without significant modification.

When you create a protocol-independent application, you do not create one executable that works with both protocols; you write one application and compile it for each protocol by specifying the protocol at compile time. In cases where a class uses different constructors or functions depending on the protocol, such as creating an exercise connection, you need to use #ifdef(s) so that your application compiles using the correct constructors.

2.2.4 Obtaining Further Information about HLA and DIS
The HLA 1.3 and IEEE 1516 specifications are copyrighted by their owners and MAK cannot distribute them to customers. You can get documentation for the RTI 1.3 and 1516 interface specifications at:

http://shop.ieee.org/store/ (IEEE 1516 specifications)
http://www.sisostds.org (SISO DLC HLA API 1516).
You can find general DIS information in the document library at the Simulation Interoperability Standards Organization (SISO) home page: http://www.sisostds.org/ProductsPublications/Standards.aspx

For the IEEE documentation of DIS, you can obtain the publications, IEEE Standard for Distributed Interactive Simulation, Application Protocols and Enumeration and Bit Encoded Values for Use with Protocols for DIS Applications at the IEEE World Wide Web site: http://shop.ieee.org/store/

Reference for Enumerations for Simulation Interoperability (SISO enumerations document) is also available at the SISO site.

Note
The URLs listed in this section were accurate at the time the manual was released. We cannot guarantee that they will be maintained in the future.

2.3 - A Conceptual Overview of VR-Link
Table of Contents
2.3.1 VR-Link's Protocol-Independent Classes
2.3.1.1 Protocol-Independent Object Management Classes
A simulator or other HLA/DIS application performs several tasks in order to interact with other players in a virtual world.

These tasks typically include:

Connecting to an exercise. The application must create an object through which it can send and receive simulation data. That object should provide an efficient way to direct incoming data to other parts of the application.
Managing state information. The application must inform other exercise participants about the states of its locally generated objects, such as entities, aggregates, transmitters, and so on. The application typically must receive, process, and manage state information about remote objects.
Managing information about events. The application must inform other participants about interactions such as collisions or fire/detonations involving a locally simulated entity, and receive and process events and interactions sent by other applications.
VR-Link provides classes that facilitate these tasks.

2.3.1 VR-Link's Protocol-Independent Classes
VR-Link provides the following categories of protocol-independent classes:

Exercise Connection – A class that serves as the application's interface to the RTI or to the DIS network.
Object management classes – Classes that maintain state information of local and remote objects, and handle the sending and receiving of state updates.
Interaction classes – Classes that provide a protocol-independent API to either HLA interactions or DIS PDUs that represent events.
VR-Link also provides protocol-specific classes and features. However, in most cases, your code does not need to interact directly with them.

To make the job of writing an application easier, VR-Link includes conversion routines, mathematical functions, and other useful functions. These are described in 13 - VR-Link Utility Classes and the vrlExamples page.

The figure shows how classes in a VR-Link application interact. Your application code can interact with classes at any level, and with the RTI or DIS network directly. However, for most applications, you can rely on the protocol-independent classes, which are generally easier to use. VR-Link utilities, such as the coordinate conversion utilities are also available to application code and VR-Link classes.

vrlinkappstructure.png
Structure of a typical VR-Link application
2.3.1.1 Protocol-Independent Object Management Classes
VR-Link provides a protocol-independent interface to various logical types of objects that are typically simulated in real-time platform-level simulations. For each logical type of object (entities, aggregates, transmitters, and so on), the following classes provide this interface:

An object publisher class, for example, DtEntityPublisher, which manages the sending of updates for a locally simulated object to the exercise through its DtExerciseConn. Object publishers are derived from DtObjectPublisher.
A reflected object class, for example, DtReflectedEntity, which represents a remote object. A DtReflectedEntity maintains the current state of the object based on updates received from the exercise through its DtExerciseConn. Reflected objects are derived from DtReflectedObject.
A reflected object list class, for example, DtReflectedEntityList, which keeps track of remote objects. It creates and destroys reflected objects based on information received from the exercise through its DtExerciseConn. Reflected object lists are derived from DtReflectedObjectList.
A state repository class, for example, DtEntityStateRepository, which is used by both publishers and reflected objects to store the state of the object they represent. State repositories are derived from DtStateRepository. DtEntityStateRepository and DtAggregateStateRepository are derived from a common class DtBaseEntityStateRepository. DtBaseEntityStateRepository is derived from the general base class DtStateRepository.
Below the protocol-independent interface are many lower-level objects that help manage objects in HLA. The lower-level objects are for the most part hidden by the higher-level interface and do not typically need to be used by application code directly. These lower-level objects are described in 5 - The HLA-Specific Interface.

2.4 - Connecting to an Exercise
VR-Link applications connect to an exercise through an exercise connection.

Exercise connections are implemented through the class DtExerciseConn. Higher level VR-Link classes use the DtExerciseConn to set and receive state information and other data. The member functions of DtExerciseConn allow an application to do the following:

Send interactions to the exercise
Read input from the network
Generate event IDs
Register callback functions that are executed each time VR-Link receives interactions and other input from the network
Manage the simulation clock.
For more information about exercise connections, please see 4.2 - Connecting to Exercises.

2.5 - Managing State Information
Table of Contents
2.5.1 Managing Locally Simulated Entities
2.5.2 Managing Remote Entities
A VR-Link application usually must maintain information about objects being simulated locally and communicate this information to other participants in an exercise.

The application must also obtain information about remote objects and represent them locally.

The figure illustrates how a VR-Link application manages state information. The elements of the figure are described in the remainder of this section. In a DIS exercise, locally simulated entities are included in the reflected entity list.

Note
In the remainder of this chapter, we talk about concepts primarily in the context of entities. However, most aspects of entity management apply to other objects, such as aggregates and transmitters, as well.

managingstateinformation.png
Managing State Information
2.5.1 Managing Locally Simulated Entities
Each locally simulated entity is represented by a DtEntityPublisher, which maintains state information in a DtEntityStateRepository. The DtEntityPublisher sends state update messages to the other exercise participants through the exercise connection. The previous figure illustrates a DtEntityPublisher sending information through an exercise connection. The DtEntityStateRepository class has functions that let you inspect the components of an entity's state and change its state.

The frequency with which your application sends updates to the exercise depends on your protocol.

In a DIS exercise, state updates are sent when the state of an entity changes and at regular intervals (heartbeats), regardless of whether there are any changes to the entity.

The HLA seeks to minimize unnecessary network traffic. Therefore in an HLA federation execution, state updates are sent only under the following conditions:

When update conditions (as specified by the FOM) have been met and a federate has subscribed to the entity attribute that changed. (Subscription is the process by which a federate tells the RTI that it wants to be notified about changes to an object.) The update condition for most attributes is any change since the attribute was last sent.
When a specific request for an update is received from another federate or the RTI.
For more information about managing local entities, please see 4.4 - Working with Entities.

2.5.2 Managing Remote Entities
A VR-Link application receives information about remote entities through the exercise connection. The function DtExerciseConn::drainInput() causes VR-Link to read and process input. VR-Link maintains a list of remote entities in a DtReflectedEntityList. Each entity known to the DtReflectedEntityList has a DtReflectedEntity to represent it. The DtReflectedEntity maintains the state of the entity in a DtEntityStateRepository. As with locally simulated entities, you can inspect the components of an entity's state. VR-Link also provides functions to track when entities join or leave an exercise.

The previous figure illustrates a DtReflectedEntityList and DtReflectedEntities.

For more information about remote entities, please see 4.6 - Working with Remote Entities.

Note
You may have noticed that the class names we use for managing entities reflect the terminology used by HLA, that is, publishing and reflecting. Although we use this terminology for our protocol-independent classes, for DIS, VR-Link sends the proper PDUs for state updates or interactions.

2.6 - Managing Information about Events
Table of Contents
2.6.1 Sending Local Interactions
2.6.2 Receiving Remote Interactions
We use the term interaction to refer to events such as the firing of a munition, detonation of a munition, or collision of entities.

VR-Link manages interactions through classes derived from DtInteraction. Usually, the name of an interaction class is based on the interaction type, for example, the class for a fire interaction is DtFireInteraction.

2.6.1 Sending Local Interactions
For locally-defined interactions, such as firing a munition from a locally simulated entity, you create an instance of the appropriate interaction class, set its values, and send it through the exercise connection. For more information, please see 4.3.1 Sending Interactions.

2.6.2 Receiving Remote Interactions
A VR-Link application receives notification of a remote interaction through its exercise connection. The function DtExerciseConn::drainInput() causes VR-Link to read and process input. The local application reacts through the use of callback functions.

There are no built-in functions for reacting to remote interactions. You must write a callback function for each type of interaction that you want to respond to and register the callback function with the interaction class. When your application is notified that an interaction event has occurred, it passes the interaction type and affected object to your callback function, which executes whatever code you have written. For information about callbacks, please see 2.7.3 Using Callbacks.

Note
Interactions are transient, that is, they are deleted by VR-Link immediately after the last callback function registered for the interaction is called.

2.7 - Other Simulation Concepts
Table of Contents
2.7.1 Managing Time
2.7.2 Identifying Objects
2.7.3 Using Callbacks
2.7.4 Coordinate Systems
2.7.5 Dead-Reckoning and Smoothing
2.7.6 Timestamps
This section describes how VR-Link implements the following simulation and programming concepts:

Time
Object identification
Callbacks
Coordinate systems
Dead-reckoning and smoothing
Time stamps.
2.7.1 Managing Time
The VR-Link toolkit maintains the concept of VR-Link simulation time for use in dead-reckoning of remote entities and thresholding of local entities. Typically, VR-Link simulation time is set once during each iteration of the application's main simulation loop so that all entities are dead-reckoned based on the same value of current time.

Usually, you will want to advance VR-Link simulation time each frame, in proportion to the amount of real time that has elapsed since the previous frame, so that it becomes a discrete approximation to (possibly scaled or offset) real time.

The class DtClock (defined in vlTime.h) implements a VR-Link simulation clock. DtClock has member functions such as setSimTime(), simTime(), and absRealTime(). Typically, you do not have to explicitly create an instance of DtClock, because the DtExerciseConn constructor creates one for you. A pointer to DtExerciseConn's clock is available through the clock() member function.

In a fixed frame rate application, like VR-Link's f18 example, VR-Link simulation time can be managed as follows:

DtTime dt = .05;                                // Each time step is .05 seconds
DtTime simTime = 0.0;                                 // Represents current time
DtClock* clock = exConn.clock();
...
// Main simulation loop
while(...)
{
// Tell VR-Link the current value of simulation time
   clock->setSimTime(simTime);
   ...
   // Do stuff
   ...
   // Advance simTime by dt
   simTime = simTime + dt;
   // Sleep till the next multiple of .05 seconds
   DtTime timeTillNextFrame = simTime - clock->elapsedRealTime();
   DtSleep(timeTillNextFrame);
}
In a floating frame rate application – where you go on to the next frame as soon as you are done with the previous one – you can pass the current time to setSimTime() each frame:

DtClock* clock = exConn.clock();
...
// Main simulation loop
while(...)
{
   clock -> setSimTime(clock -> absRealTime());
   ...
   // Do stuff
   ...
}
DtObjectPublishers and DtReflectedObjects use their DtExerciseConn's clock when performing dead-reckoning, thresholding, and so on. In rare cases where you are creating an instance of an entity or aggregate state repository yourself outside of the context of a publisher or reflected object, you will need to tell the repository what clock to use if you want dead-reckoning to occur properly. Do this using the repository's setClock() function.

For more information, please see 2.7.6 Timestamps.

2.7.2 Identifying Objects
One concept that HLA and DIS handle fairly differently is object identification.

In DIS, entities are identified by a triplet (site, application, entity) known as an Entity Identifier. Other types of objects are usually identified using the IDs of their host entities plus a single additional ID number.

In HLA, objects have several different identifiers, including:

An Object Handle, which is used within a federate to identify a particular object in an RTI service invocation
An Object Name, which is used within interactions and attribute updates exchanged among federates for the RPR FOM.
For more information about the various types of identifiers, and to see how VR-Link accounts for these differences, please see 4.7 - Identifying Objects.

2.7.3 Using Callbacks
Callback functions are functions that you write that enable your application to respond to events. You register a callback with VR-Link by passing a pointer to the function as an argument to a callback registration function. VR-Link calls your function in response to a specified event.

There are several places in VR-Link where callback functions are necessary to take advantage of certain functionality. For example, in order to process incoming interactions or DIS PDUs of a certain kind, a user registers an interaction callback or PDU callback with the appropriate VR-Link interaction class or PDU class. This is accomplished using the class's addCallback() static member function. Subsequently, whenever VR-Link reads that type of interaction or PDU from the RTI or DIS network, VR-Link calls your callback function, passing it a copy of the relevant interaction or PDU. In most cases, including this one, the callback gets called from within DtExerciseConn::drainInput() – the VR-Link function that causes input to be read from the exercise.

Other ways that callback functions are used in VR-Link include the following:

To respond to entity addition or removal: You can register an entity addition or entity removal callback with a DtReflectedEntityList. These functions will be called, also from within drainInput(), whenever we receive word from the exercise that a remote entity has joined or left the exercise.
For general purposes: A post-drain callback is a general callback function that can be registered with a DtExerciseConn. It is called from within drainInput(), regardless of what data has been read from the RTI or DIS network. These callbacks are executed after VR-Link finishes reading data and executes other, more specific callbacks.
Because callback functions are passed as regular function pointers to VR-Link's callback registration functions, the callback functions themselves cannot be non-static member functions of a class. They can be global (C-style) functions, or static class members. In order to have a non-static member function of a class be executed as a result of some VR-Link event, you can call the member function from within your callback.

VR-Link callback functions have strict function signatures, but most types of VR-Link callback functions have a trailing void* argument that is usually called usr. Corresponding callback registration functions also have a trailing usr argument. This lets you register an arbitrary pointer with VR-Link along with your callback function. When VR-Link executes your callback function, the pointer that you registered is passed to your function as usr.

Often, the usr argument passes a pointer to an object on which you want to call a member function. Simply cast usr back to the object's type within the callback. For example:

class MyObj
{
public:
   // The function we want to call.
   void someFunc();
   // A static member function to be registered as an interaction
   // callback with the DtFireInteraction class. When this function
   // is called by VR-Link, usr will contain a pointer to the object
   // passed to addCallback.
   static void theCallback(DtFireInteraction* inter, void* usr)
   {
      MyObjType* obj = static_cast<MyObjType *>(usr);
      obj->someFunc();
   }
};
int main()
{
   DtExerciseConn exConn(...);
   ...
   MyObj obj;
   // Register our callback function, passing a pointer to obj as usr.
   DtFireInteraction::addCallback(&exConn, MyObj::theCallback, &obj);
   ...
}
In cases where you want to pass more than one object to your callback, you must create a simple structure consisting of pointers to your objects, then pass a pointer to the structure as usr.

Note
Any pointer you pass as usr must be the address of a variable whose lifetime is at least as long as the period for which the callback function is registered.
2.7.4 Coordinate Systems
By default, DtEntityStateRepository works with geocentric coordinates. VR-Link has coordinate conversion routines that let you convert incoming and outgoing entity information to other coordinates systems. VR-Link also has coordinate views that allow you to use various coordinate systems without explicitly calling coordinate conversion routines. The view classes support:

UTM coordinates
Cartesian coordinates
Topographic coordinates.
For more information about views and coordinate conversion, please see 4.9 - Coordinate Views, and 13.3 - Coordinate Conversions.

2.7.5 Dead-Reckoning and Smoothing
To represent the behavior of entities in between state updates, VR-Link uses dead-reckoning, a process of estimating the location of an entity based on its acceleration and velocity. When updated location information arrives, VR-Link must move the simulated entity to its actual position. To ensure that transitions from an entity's dead-reckoned position to its actual position are not so abrupt as to be visually disconcerting, VR-Link implements smoothing. The figure illustrates the difference between a smoothed transition and a non-smoothed transition.

deadreckoning.png
Dead-reckoning and smoothing
For more information, please see 4.6.5 Dead-Reckoning.

2.7.6 Timestamps
When interactions or object state updates are sent through a DtExerciseConn using sendStamped(), a timestamp is sent with (or within) the message.

A DIS or RPR FOM timestamp indicates only a time (in seconds) past a particular hour at which the data in the message is supposed to be valid. However, it contains no information about what particular hour the sender had in mind. (DtPdu, DtInteraction, and DtStateMessage all have a member function called guessTimeValid() that makes a guess at the full time the sender had in mind by returning the time closest to a reference time such that the number of seconds past the hour equals the value specified in the timestamp.)

In addition to the timestamp, DIS and HLA RPR FOM messages contain a timestamp type indicator, which indicates a type of either "relative" or "absolute". Despite the confusion that these terms have generated in the DIS/HLA world, these terms only indicate whether or not the clock the sender used to obtain its timestamp is synchronized to some global exercise clock. A timestamp type of "absolute" means that the sender's clock is synchronized with the clocks of any other applications that claim to be using absolute timestamping. A timestamp type of "relative" means that the sender's clock is not necessarily synchronized with anyone else's clock.

Participants in a DIS or HLA exercise do not have to synchronize their clocks. In fact, in most exercises, clocks are not synchronized. If participants choose to synchronize their clocks, they do so using a method outside the scope of both DIS and HLA. (The HLA RTI has a set of time management services, but synchronizing clocks is not what they do.)

When a sender and a receiver are both using absolute timestamping, that is, their clocks are synchronized, the receiver can immediately make sense of the sender's timestamp. In this case, VR-Link uses the timestamp of incoming entity state updates in dead-reckoning calculations. If one or both are using relative timestamping, then the sender's timestamp is meaningless to the receiver unless he can determine the time difference between the two clocks (which is again, outside the context of DIS and HLA). In this case, like most DIS/HLA applications, we ignore the timestamp, and use the time of receipt in dead-reckoning calculations.

2.8 - Big and Little Endian Wire Formats
In rare cases, simulations may be forced to communicate with applications that use little endian rather than big endian wire formats.

VR-Link provides a mechanism for setting and inspecting the current wire format at runtime using the functions DtSetNetworkByteOrdering() and DtNetworkByteOrdering() (defined in vlNetTypes.h). Big endian is the default.

To use little endian byte ordering, call:

DtSetNetworkByteOrdering(DtLittleEndian);
To change it back to the default, call:

DtSetNetworkByteOrdering(DtBigEndian);

2.9 - Basic VR-Link Examples
Table of Contents
2.9.1 A Listen-Only Example
2.9.2.1 Connecting to An Exercise
2.9.1.2 Managing State and Interaction Information
2.9.1.3 Tracking Entities
2.9.1.4 Managing Time
2.9.1.5 Listening to the Network
2.9.2 A Send-Only Example
2.9.2.2 Managing Entities
2.9.2.3 Sending Interactions
2.9.2.4 Sending State Messages
This section lists and describes two simple VR-Link applications. The first is a listen-only application that observes an exercise without simulating any entity on the network. The second is a write-only program that does not process information about remote entities.

Note
The source code for both examples is included with VR-Link.
2.9.1 A Listen-Only Example
The Listen-Only is an application that just listens to the network. This application can be compiled for either DIS or HLA. The only protocol-specific code is contained in the #if statement that starts at line 27.

With each iteration of the loop, the program prints an entity's updated, dead-reckoned position in topographic coordinates. In addition, if a fire PDU or interaction is detected on the network, the program prints a message showing the entity ID of the attacker.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vlutil/vlProcessControl.h>
4  #include <vl/reflectedEntityList.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/reflectedEntity.h>
7  #include <vl/fireInteraction.h>
8  #include <vl/topoView.h>
9  #include <iostream>
10 
11 int keybrdTick(void);
12 
13 // Define a callback to process fire interactions.
14 void fireCb(DtFireInteraction* fire, void* /*usr*/)
15 {
16    std::cout << "Fire Interaction from " 
17          <<  fire->attackerId().string() << std::endl;
18 }
19 
20 int main(int argc, char** argv)
21 {
22    try
23    {
24       // Create a connection to the exercise or federation execution.
25       DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
26 
27       #if DtDIS
28       appInit.setUseAsynchIO(true);
29       #endif
30 
31       appInit.parseCmdLine();
32 
33       DtExerciseConn exConn(appInit);
34 
35       // Register a callback to handle fire interactions.
36       DtFireInteraction::addCallback(&exConn, fireCb, NULL);
37 
38       // Create an object to manage entities that we hear about 
39       // on the network.
40       DtReflectedEntityList rel(&exConn);
41     
42       // Initialize VR-Link time.
43       DtClock* clock = exConn.clock();
44 
45       int forever = 1;
46       while (forever)
47       {
48          // Check if user hit 'q' to quit.
49          if (keybrdTick() == -1)
50             break;
51 
52          // Tell VR-Link the current value of simulation time.
53          clock->setSimTime(clock->elapsedRealTime());
54 
55          // Process any incoming messages
56          exConn.drainInput();
57 
58          // Find the first entity in the reflected entity list
59          DtReflectedEntity *first = rel.first();
60 
61          if (first)
62          {
63             // Grab its state repository, where we can inspect its data.
64             DtEntityStateRepository *esr = first->entityStateRep();
65 
66             // Create a topographic view on the state repository, so we 
67             // can look at position information in topographic
68             // coordinates.
69             double refLatitude  = DtDeg2Rad(  35.699760);
70             double refLongitude = DtDeg2Rad(-121.326577);
71             DtTopoView topoView(esr, refLatitude, refLongitude);
72    
73             // Print the position.
74             // Since it returns a DtString, we need to force it to 
75             // const char* with a cast.
76             std::cout << "Position of first entity: "
77                <<  topoView.location().string() << std::endl;
78          }
79       
80          // Sleep till next iteration.
81          DtSleep(0.1);
82       }
83       return 0;
84    }
85    DtCATCH_AND_WARN(std::cout);
86 }
87 
88 int keybrdTick()
89 {
90    char *keyPtr = DtPollBlockingInputLine();
91    if (keyPtr && (*keyPtr == 'q' || *keyPtr == 'Q')) 
92       return -1;  
93    else
94       return 0;
95 }
2.9.2.1 Connecting to An Exercise
In lines 22-25, the program creates an exercise connection (DtExerciseConn). This connection serves as the program's interface to an exercise. DtExerciseConn has several constructors. In this example, we create a DtVrlApplicationInitializer and pass it to the DtExerciseConn. Use of a DtVrlApplicationInitializer provides support for command line arguments. The default protocol-specific initialization values are set in the

DtVrlApplicationInitializer and its base class, DtExerciseConnInitializer. This is the only protocol-specific part of the code.

If you want to specify initialization values in the DtExerciseConn, you would use code similar to the following:

int main()
{
   // Create a connection to the exercise or federation execution
#if DtHLA
   DtString execName("VR-Link");
   DtString fedName("VR-Link listen"); 
   DtExerciseConn exConn(execName, fedName, new DtSimpleRprFomMapper);
#elif DtDIS
   int port           = 3000;
   int exerciseId     = 1; 
   int siteId         = 1;
   int applicationNum = 15;
   DtExerciseConn exConn(port, exerciseId, siteId, applicationNum,
                              0,             // No Status, any error will be fatal
                              true);            // use Async IO
#endif 
2.9.1.2 Managing State and Interaction Information
Applications based on VR-Link typically use callbacks to handle incoming interactions such as fire, detonations, and collisions. For example, a callback named fireCb is registered with the DtFireInteraction class at line 36. This callback (defined at line 14) prints a message containing the attacker ID. It executes whenever the exercise connection receives a Fire PDU or interaction during a call to drainInput().

2.9.1.3 Tracking Entities
We create a reflected entity list in line 40 to keep track of entities found on the network. The entity list tracks the arrival and departure of entities, performs dead reckoning, manages time outs, and performs other entity-tracking tasks.

2.9.1.4 Managing Time
On line 43 we obtain a pointer to the simulation clock from the exercise connection.

2.9.1.5 Listening to the Network
At the start of each iteration, the program sets VR-Link simulation time (line 53) to provide a common time value for use by time-related operations that occur within an iteration of the loop (such as the dead-reckoning of multiple entities).

The drainInput() call (line 56) reads and processes any messages arriving through the exercise connection. This call triggers the execution, if needed, of any callbacks you have registered for that exercise connection.

In line 59, the program finds the first entity in the entity list, then in line 64, retrieves the pointer to the entity's entity state repository. Line 71 creates a topographic view of that entity state repository, allowing us to retrieve its position data in topographic coordinates rather than geocentric. (Lines 69 and 70 hard code the coordinates for this example.)

Line 76 obtains and prints the dead-reckoned entity location.

2.9.2 A Send-Only Example
The Send-Only application simulates the flight of an F18 aircraft. The program begins by sending a fire PDU or HLA fire interaction. Thereafter, the F18 flies north for 10 seconds, updating its position by sending DIS entity state PDUs or HLA attribute updates.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vl/topoView.h>
4  #include <vl/entityPublisher.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/fireInteraction.h>
7  #include <vl/iffPublisher.h>
8  #include <vlpi/EntityTypes.h>
9   #include <vlutil/vlProcessControl.h>
10 #include <iostream>
11 
12 int main(int argc, char** argv)
13 {
14 
15    try
16    {
17       // Create a connection to the exercise or federation execution.
18       DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");
19 
20       // Change some defaults
21       #if DtDIS
22       appInit.setUseAsynchIO(true);
23       #endif
24 
25       appInit.parseCmdLine();
26 
27       DtExerciseConn exConn(appInit);
28 
29       DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
30          DtUnitedStates, DtFighter, DtF18, 0, 0);
31 
32       // Create an entity publisher for the entity we are simulating.
33       DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
34          DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 
35 
36       // Hold on to the entity's state repository, where we can set data.
37       DtEntityStateRepository *esr = entityPub.entityStateRep();
38 
39       // Create a topographic view on the state repository, so we 
40       // can set position information in topographic coordinates.
41       double refLatitude  = DtDeg2Rad(  35.699760);
42       double refLongitude = DtDeg2Rad(-121.326577);
43       DtTopoView topoView(esr, refLatitude, refLongitude);
44    
45       // We can use the ESR to set state.
46       esr->setMarkingText("VR-Link");
47       topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));
48 
49       // Initialize VR-Link time.
50       DtClock* clock = exConn.clock();
51    
52       DtVector position(0, 0, -100);
53       DtVector velocity(20, 0, 0);
54 
55       // Send a Fire Interaction.
56       DtFireInteraction fire;
57       fire.setAttackerId(entityPub.globalId());
58       exConn.sendStamped(fire);
59    
60       // Main loop
61       DtTime dt = 0.05;
62       DtTime simTime = 0;
63       while (simTime <= 10.0)
64       {
65          // Tell VR-Link the current value of simulation time.
66          clock->setSimTime(simTime);
67 
68          // Process any incoming messages.
69          exConn.drainInput();
70 
71          // Set the current position information.
72          topoView.setLocation(position);
73          topoView.setVelocity(velocity);
74 
75          // Call tick, which insures that any data that needs to be 
76          // updated is sent.
77          entityPub.tick();
78       
79          // Set up for next iteration.
80          position[0] += velocity[0] * dt;
81          simTime     += dt;
82       
83          // Wait till real time equals simulation time of next step
84          DtSleep(simTime - clock->elapsedRealTime()); 
85       }
86    
87    }
88    DtCATCH_AND_WARN(std::cout);
89    return 0;
90 }
2.9.2.1 Connecting to An Exercise
Like the listen-only example, this program creates a DtExerciseConn to provide an interface to the RTI or DIS network (lines 17 through 27).

2.9.2.2 Managing Entities
Line 29 defines the entity type the F18 will use.

To be visible to other applications in the exercise, each locally-simulated entity requires a DtEntityPublisher, created in line 33. The entity publisher manages the generation of messages for this particular entity. It provides an entity state repository where you can set state values, and a tick() function, which causes state information to be sent to the network if necessary.

Line 37 sets up a pointer to the entity state repository, then line 43 creates a topographic view on that repository. This lets us set the entity's positional data using topographic coordinates, rather than the default geocentric coordinates. (Lines 41 and 42 hard code the coordinates for this example.) Line 46 shows an example of storing a non-positional state value in the repository.

2.9.2.3 Sending Interactions
An example of sending an interaction appears in lines 56-58. You can send the interaction using the exercise connection's sendStamped() function.

Note
You can use sendStamped() to send state updates, but it is preferable to let the entity publisher send state updates for you, using data in the entity state repository, as shown in lines 72 through 77.
2.9.2.4 Sending State Messages
The main loop executes twenty times per second for ten seconds. As in the listen-only example, this program sets simulation time at the start of each iteration (line 66).

Note
While this program's main purpose is to demonstrate the sending of data to the network, it is not a true send-only application. Incoming data is also processed with the drainInput() call on line 69. This call is required for HLA, because this is where we tick the RTI.
The program updates the F18's positional data in its entity state repository in lines 72 and 73, and ticks the entity publisher in line 77 to send the updated data onto the network. Lines 72 and 73 set topographic coordinates through a view, which VR-Link converts to geocentric coordinates.

Thereafter, the only remaining tasks are to increment the F18's position, increment the simulation time, and sleep until it is time to begin the next iteration.

3.1 - Compiling and Linking a VR-Link Application
Table of Contents
3.1.1 Libraries and Header Files
3.1.1.1 Using Microsoft Visual C++ 8 Express Edition
3.1.2 Third-Party Libraries
3.1.3 Compiling for a Particular Simulation Standard Under Linux
3.1.3.1 HLA
Compile Flags
Link Flags for HLA 1.3
Link Flags for HLA 1516
Link Flags for HLA Evolved
3.1.3.2 DIS
Compile Flags
Link Flags
3.1.4 Compiling for a Particular Protocol Version under Windows
3.1.4.1 When Compiling for HLA
3.1.4.2 Compiling for DIS
To build a VR-Link application, you must tell the compiler where to find the VR-Link header files (and for HLA, the RTI header files).

In addition, you must link with VR-Link's libraries (and for HLA, the RTI's libraries). If you are not using a C++ linker to link, you must explicitly link with C++ system libraries such as libC.so.

3.1.1 Libraries and Header Files
VR-Link consists of four libraries: mtl, vl, matrix, vlpi, and vlutil. The following versions of the vl library are provided:

Versions of the vl Library
Simulation standard	UNIX	Windows
HLA	libvlHLA13.so, libvlHLA1516.so, libvlHLA1516e.so	vlHLA13.lib, vlHLA1516.lib, vlHLA1516e.lib
DIS	libvlDIS.so	vlDIS.lib
On Windows:

The DLLs must be in your path.
You must add the C preprocessor definition: #DEFINE DT_USE_DLL = 1
3.1.1.1 Using Microsoft Visual C++ 8 Express Edition
Microsoft Visual C++ 8 Express Edition links against a different set of default libraries than Microsoft Visual Studio 2005 Professional does. Therefore, you might experience linking problems if you use Express Edition. If you have linking problems, add the following libraries to your link line:

user32.lib
gdi32.lib
winspool.lib
comdlg32.lib
advapi32.lib
shell32.lib
ole32.lib
oleaut32.lib
uuid.lib
odbc32.lib
odbccp32.lib.
3.1.2 Third-Party Libraries
VR-Link uses the third-party libraries libXml2, boost, and iconv. If you are building a VR-Link application, you must include them on your link line. The libXml2 library is part of the Red Hat Linux distribution. It is distributed with VR-Link for all other operating systems. For details about boost, please go to http://www.boost.org.

3.1.3 Compiling for a Particular Simulation Standard Under Linux
To build a VR-Link application for Linux using MAK's build system, you must use gmake 3.81 or later. You can download it from http://savannah.gnu.org/projects/make/

You can select DIS or HLA at compile time by using the flags described in the following sections. vlhome represents your VR-Link home directory.

The order of the libraries in the link line is significant. For more information, please see the Makefiles in ./examples.
Other flags may be required on some platforms. For more information, please see the example makefiles and release notes.
3.1.3.1 HLA
After you install VR-Link, create a symbolic link called RTI in the top level VR-Link directory. Point the link to the RTI distribution that you are using.

Compile Flags
-I{VLHOME}/include (VR-Link headers)

-I{VLHOME}/RTI/include (path to MAK RTI include directory)

-DDtHLA=1 for conditional compilation)

-DDtHLA_1516=1 Use only if compiling for IEEE 1516 - 2000.

-DDtHLA_1516_EVOLVED=1 Use only if compiling for IEEE 1516 - 2010 (HLA Evolved).

Link Flags for HLA 1.3
-lvrhome/lib -lvl -lvlHLA13 -lmatrix -lmtl -lvlutil -lxml2 -lRTI-NG -lfedtime
Link Flags for HLA 1516
-Lvrhome/lib -lvl -lvlHLA1516 -lmatrix -lmtl -lvlutil -lxml2 -lrti1516 -lfedtime1516
Link Flags for HLA Evolved
-Lvrhome/lib -lvl -lvlHLA1516e -lmatrix -lmtl -lvlutil -lxml2 -lrti1516e -lfedtime1516e
3.1.3.2 DIS
The compile and link flags for DIS are:

Compile Flags
-Ivlhome/include (VR-Link headers)

-DDtDIS=1 (for conditional compilation)

Link Flags
-Lvlhome/lib -lvl -lmtl -lvlDIS -lmatrix -lvlutil -lxml2
3.1.4 Compiling for a Particular Protocol Version under Windows
Under Windows, you can set your program's protocol following the procedures in this section. You need to provide build settings in Microsoft Developer Studio to define constants and specify paths for header files and RTI libraries.

VR-Link includes project files for DIS and the three HLA versions. If you are building for HLA, make sure to point to the correct location of the RTI include and library directories. The default is to use the value in the MAK_RTIDIR environment variable.

Note
In addition to linking with netapi.lib and WS2_32.lib, you must link with comctl32.lib, libxml2.lib, iphlpapi.lib, and iconv.lib. For details, please see the sample project files.
3.1.4.1 When Compiling for HLA
Choose Project -> Properties, then select the C/C++ folder.
Enter the following #define symbols in the space provided for preprocessor definitions:

DtHLA=1, DtHLA_1516=1, RTI_USES_STD_FSTREAM=1
In the C/C++ -> General section, in the space provided for additional include libraries, enter your VR-Link include path and the path to your RTI include directory, for example:

../../include, "c:/MAK/MakRti4.0.1/include"
or:

$(MAK_VRLDIR)/include, $(MAK_RTIDIR)/include
Note
The relative pathnames in this procedure (for example, ../../include) are relative to the project .vcproj file in the ./examples/f18 directory of the default VR-Link installation. The full path would be similar to C://MAK/VR-Linkx.x/include.
Select the Linker folder.
In the Linker -> Input section, in the space provided for additional dependencies, enter the appropriate RTI, VR-Link and Visual C++ library files, for example:

{libRTI-NG.lib | librti1516.lib | librti1516e.lib} {libfedtime.lib | libfedtime1516.lib | libfedtime1516e.lib} vl.lib vlutil.lib 
mtl.lib matrix.lib {vlHLA13.lib | vlHLA1516.lib | vlHLA1516e.lib} netapi32.lib WS2_32.lib comctl32.lib iphlpapi.lib 
libxml2.lib iconv.lib
Also, make sure you list the appropriate paths to these files in the "Additional Library Directories" box in the Linker -> General section, for example:

$(MAK_VRLDIR)/lib, $(MAK_RTIDIR)/lib
3.1.4.2 Compiling for DIS
In the C/C++ -> General section, in the space provided for additional include libraries, enter your VR-Link include path, for example:

../../include
In the Linker -> Input section, enter the appropriate VR-Link and Visual C++ library files, for example:

vlutil.lib mtl.lib matrix.lib vl.lib vlDIS.lib netapi32.lib WS2_32.lib iphlpapi.lib comctl32.lib
Also, make sure you list the appropriate paths to these files in the "Additional Library Directories" box in the Linker -> General section, for example:

../../lib

3.2 - Using VR-Link from C
Table of Contents
3.2.1 Calling C++ from C
3.2.2 Calling C from C++
3.2.3 Header Files that are Included by C and C++
The directory .

/examples/simpleC contains an example of using VR-Link with an application written in C. The example is a C version of the listen-only program described in 2.9.1 A Listen-Only Example. For details, please see the header files interface.h and simpleC.h.

3.2.1 Calling C++ from C
Since VR-Link is a C++ toolkit, any code that directly calls a VR-Link function must be compiled by a C++ compiler. You can compile this code in such a way that it may be called from C. To do so, you need at least one C++ file from which all calls to VR-Link functions can be made. In our example, the file interface.cxx serves this purpose. It contains several functions that interact with VR- Link code: initVRLink(), tickVRLink(), and firstEntityPosition().

To alert the C++ compiler that these functions should be compiled to be callable from C, their declarations are surrounded by the following keywords, as seen by the C++ compiler:

extern "C" {
}
The file listenC.c represents the rest of the application. It is compiled by a C compiler, and does not directly call any VR-Link functions. It does, however, call the functions defined in interface.cxx that were compiled to be called from C.

3.2.2 Calling C from C++
You can create a C++ function that interfaces with VR-Link code and can also call C functions. For example, in interface.cxx, the callback on Fire PDUs (fireCb) is a C++ function which calls the C function firePrint().

To alert the C++ compiler that an external function is a C function, its declaration is surrounded by the following keywords, as seen by the C++ compiler:

extern "C" {
}
3.2.3 Header Files that are Included by C and C++
When C and C++ code interact, the declarations of many of the same functions must be included by both C and C++ code. As described above, these declarations need to be surrounded by:

extern "C" {
}
when presented to the C++ compiler. However, these keywords are meaningless to a C compiler, so that they should always be surrounded by:

#ifdef __cplusplus
#endif
For example, listenC.h reads as follows:

#ifdef __cplusplus
extern "C" {
#endif
void firePrint(const char *attacker);
#ifdef __cplusplus
}
#endif

3.3 - Delivering VR-Link Applications to Users
A VR-Link developer's license allows you to compile applications using the VR-Link libraries and run one such application.

After you have developed an application that uses the VR-Link libraries, you may need to deliver that application to an internal or external customer. The end user of the application needs a VR-Link run-time license to use it. The customer does not need the entire VR-Link toolkit, nor do they need a developer's license (unless they need to recompile the application). They just need the application, the VR-Link libraries, the license management files, and a run-time license for each instance of the application that will be run. You should not provide the header files.

You can purchase a run-time license for your customer or have the customer purchase the license from MAK, depending on the arrangements you have made.

4 - The Protocol Independent Interface
You can access most of VR-Link's features through its protocol-independent API, described in this chapter.

Protocol-specific portions of the API are described in 5 - The HLA-Specific Interface and 8 - The DIS Specific Interface.

4.1 - Introduction to the Protocol-Independent Interface
4.2 - Connecting to Exercises
4.3 - Working with Interactions
4.4 - Working with Entities
4.5 - Working with Locally Simulated Entities
4.6 - Working with Remote Entities
4.7 - Identifying Objects
4.8 - Working with Other Types of Objects
4.9 - Coordinate Views
4.10 - Articulated Parts
4.11 - Attached Parts
4.12 - Using Independent VR-Link Objects in Multiple Threads
4.13 - Controlling MAK Products Remotely

4.1 - Introduction to the Protocol-Independent Interface
The protocol-independent interface is a set of classes that encompass most of the features of VR-Link and allow you to create applications that will work in both DIS and HLA without significant modification.

In addition to its multi-protocol capability, and perhaps more importantly, the protocol-independent interface shields you from many of the intricacies of the underlying protocol-specific classes and functions. At the same time, the protocol-specific classes are available to you if you want to use them.

When you create a protocol-independent application, you do not create one executable that works with both protocols; you write one application and compile it for each protocol by specifying the protocol at compile time. In cases where a class uses different constructors or functions depending on the protocol, such as creating an exercise connection, you need to use #ifdef(s) so that your application compiles using the correct constructors.

4.2 - Connecting to Exercises
Table of Contents
4.2.1 Creating an Exercise Connection for HLA
4.2.2 Creating an Exercise Connection for DIS
4.2.3 Initializing Applications
4.2.4 DtExerciseConn Member Functions
4.2.4.1 Sending Data to the Exercise
4.2.4.2 Receiving Data from the Exercise
4.2.4.3 Post-Drain Callbacks
4.2.4.4 Time Stamp Type
4.2.4.5 Initialization Status
In general, an HLA federation or DIS exercise can be defined as a collection of simulation applications communicating with each other through the exchange of data (HLA messages or DIS PDUs).

A simulation application (called a federate in HLA) can, in turn, be defined as a participant in an exercise. Such an application may simulate one or more entities.

VR-Link's class DtExerciseConn is a simulation application's interface to an exercise. The application sends data to other applications, and receives data from other applications, through its DtExerciseConn. Virtually all applications based on VR-Link make use of a DtExerciseConn.

There are HLA and DIS versions of DtExerciseConn. For HLA, the DtExerciseConn exchanges data with other applications by making calls to the RTI. For DIS, data is usually exchanged through the sockets-related system calls sendTo() and recvFrom().

The HLA version of DtExerciseConn is defined in exerciseConnHLA.h. The DIS version is defined in exerciseConnDIS.h. If you are writing an application for use with both HLA and DIS, you do not have to include both header files. You can include exerciseConn.h, which includes the appropriate version depending on whether or not you have included the DtHLA=1 definition in your compile line.

Although the two versions of DtExerciseConn are defined separately, most public member function names and signatures are shared by the two versions, so that you can make most of these calls regardless of which protocol you are using. Much of this commonality is enforced because both versions are derived from DtBaseExerciseConn, an abstract class that defines much of the DtExerciseConn interface.

Creating a DtExerciseConn must be done differently for HLA and DIS because they require different initialization parameters.

4.2.1 Creating an Exercise Connection for HLA
To create a DtExerciseConn in HLA, you must provide a federation execution name and a federate name. You can specify this information in the DtExerciseConnInitializer (exerciseConnInitializer.h) and pass it in to the DtExerciseConn through the constructor or you can specify it in one of the other DtExerciseConn constructors. One of DtExerciseConn's constructors lets you specify the name of the FED file that you want to use. The FED file provides information about the FOM to the RTI and to VR-Link. If you do not provide the name of a FED file to the DtExerciseConn constructor, we assume that you are using a file with the same name as the federation execution, but with a .fed extension. For example, if the federation execution name is VR-Link, we assume the FED file is VR-Link.fed.

VR-Link looks for the FED file in the directory from which you run your application. Make sure that the FED file that you are using with your DtExerciseConn is in this directory.

The default FED file supported by VR-Link is VR-Link.fed. It is in ./bin. If you are using the FOM described by this file, you must copy VR-Link.fed to the directory that you are running from.

All applications that want to interact in the same HLA world must use the same federation execution name, and the exact same FED file.

The federate name is a name you give to your application. It is used for RTI diagnostics. Federate names do not have to be unique in a federation.

The DtExerciseConn constructors:

Initialize an application's RTI ambassadors (which causes the FED file to be read)
Create the named federation execution if it does not already exist
Join the federation execution.
Note
Before you start your VR-Link-based application determine if the RTI you are using requires use of an RTI executive or similar central application. If necessary, start that application.
If you are using the Pitch RTI, make sure that you turn off asynchronous tick.

Note
DtExerciseConn has member functions fedHandle(), fedName(), and execName() for obtaining the federate handle, federate name, and federation execution name.
4.2.2 Creating an Exercise Connection for DIS
To create an exercise connection for DIS, you need:

A UDP port number
An exercise ID number
A site number
An application number.
As with HLA, you can specify these values in the DtExerciseConnInitializer and pass them to the DtExerciseConn constructor, or specify them directly in the constructor. All applications that want to interact in a DIS exercise must use the same UDP port number and exercise ID number.

By default, DIS PDUs sent through the DtExerciseConn are sent to the broadcast address of the machine's primary network interface. The DtExerciseConn receives any unicast or broadcast packets destined for the machine on the specified port. Additional constructors and functions of the DIS version of DtExerciseConn allow greater flexibility in setting up your network connection, and are discussed in 8.3 - Configuring Your Connection to the DIS Network.

4.2.3 Initializing Applications
You can specify default initialization values in DtExerciseConnInitializer. You can enable parsing of command line input, or loading XML or MTL files to VR-Link-based applications if you use a DtVrlApplicationInitializer (exerciseConnInitializer.h). You can also save the state of the DtVrlApplicationInitializer class to an XML file. For an example of using an MTL file, please see f18.mtl.

When you use this constructor, all of the initialization values, which are protocol-dependent, are in the DtExerciseConnInitializer, the configuration file, or the command line. Therefore, the initialization code is completely protocol independent. The last parameter passed into the constructor is the application name. It is printed to the screen when the command line usage is printed out, and it also specifies the default federate name in HLA.

// Create a connection to the exercise or federation execution.
DtVrlApplicationInitializer appInit(argc, argv, "VR-Link application");
appInit.parseCmdLine();
DtExerciseConn exConn(appInit);
The command parser can accept individual letter commands, prefaced by a dash (-), or multiple letter commands, prefaced by two dashes (–). The default commands and values specified in DtExerciseConnInitializer are listed in Protocol Independent Command Line Options Default HLA Command Line Options and Default DIS Command Line Options.


Protocol Independent Command Line Options
Parameter	Syntax	MTL Parameter	Default
Notification level	(-n | –notifyLevel) level	DtNotifyLevel	2
Log file to use	–logFileName <filename>		
Notify level in log file to use.	–fileNotifyLevel <level>		
Ignores the rest of the labeled arguments following this flag.	– | –ignore_rest		
Displays version information and exits.	-v | –version		
Displays usage information and exits.	-h | –help		

Default HLA Command Line Options
Parameter	Syntax	MTL Parameter	Default
Execution name	(-x | –execName) exec_name	execName	VR-Link
Federate name	(-N | –federateName) federate_name	federateName	VR-Link
FED file name	(-F | –fedFileName) fedfile_name	fedFileName	VR-Link.fed
FOM Mapper library name	(-f | –fomMapperLib) libname	fomMapperLib	
FOM Mapper initialization data	–fomMapperInitData data	fomMapperInitData	
RPR FOM revision	–rprFomRevision	rprFomRevision	1
RPR FOM version. (0.5, 0.7, 0.8, 1.0, 2.0006, 2.0014, or 2.0017)	–rprFomVersion version_number	RprFomVersion	1.0
Disable RTI Compiler version check	–noRtiCompilerCheck		
Ignore Advisories	<–ignoreAdvisories/TD>	useAdvisories	1
Federate Type	(-p | –federateType) <string>		
HLA Evolved MIM Module	–mimModule <string>	mimModule	""
Add FOM Modules. (accepted multiple times) (HLA Evolved only)	–fomModules <string>		
HLA Evolved Local Settings Designator	(-S | –localSettingsDesignator) <string>		

Default DIS Command Line Options
Parameter	Syntax	MTL Parameter	Default
DIS port	(-P | –disPort) port	disPort	3000
Exercise ID	(-x | –exerciseId) ID	exerciseId	1
Application number	(-a | –appNumber) number	appNumber	2
Site ID	–siteId ID	siteId	1
Destination address	(-A | –destAddrString) address	destAddrString	""
Device address	–deviceAddress address	deviceAddress	
Send buffer size	–sendBufferSize size	sendBufferSize	-1 (use sys-tem default)
Receive buffer size	–recvBufferSize size	recvBufferSize	-1 (use sys-tem default)
Multicast TTL	–mcastTtl ttl	mcastTtl	-1 (use sys-tem default)
Multicast address	(-S | –mcastAddresses) addresses		
Suppress self-reflection	–suppressSelfReflect	suppressSelfReflect	false
Use IPv6	–useIpv6	useIpv6	false
DIS Version	–disVersion <version>		
Use Asynchronous I/O	–useAsyncIO	useAsyncIO	0
Subnet mask to use	<–subnetMask <mask>/TD>		
4.2.4 DtExerciseConn Member Functions
The next table describes the most commonly used protocol-independent member functions for DtExerciseConn.

DtExerciseConn Member Functions
Function	Description
addPostDrainCallback()	Lets you register functions (with the DtExerciseConn) that you want to have called automatically each time drainInput() is called.
removePostDrainCallback()	Lets you unregister functions that you no longer want to have called each time drainInput() is called.
drainInput()	Causes to read and process input from the exercise. Most user callbacks are executed from within drainInput().
nextEventID()	Generates consecutive event IDs for use in fire, detonate, or collision interactions.For DIS, the event ID is composed of the site ID, application ID, and event number based on the exercise connection’s site and host. For HLA, the event ID is composed of the object ID (from setObjectId()) and event number.You can choose your own event IDs in both DIS and HLA. Event IDs are not managed by the RTI as Object IDs are. Therefore it is up to the application to ensure that event IDs are unique.
send() sendStamped()	Sends interaction messages, object updates, and DIS PDUs to the exercise. sendStamped() includes a time stamp with outgoing messages.
setTimeStampType()	Lets you specify the type of time stamp being sent. The options are DtTimeStampAbsolute and DtTimeStampRelative.
timeStampType()	Returns the time stamp type.
vrlinkVersion()	This static function returns the version of VR-Link that you are running.
The following sections contain more detailed information about these functions.

4.2.4.1 Sending Data to the Exercise
The send() and sendStamped() member functions are used to send interactions to the exercise. For more information, please see 4.3.1 Sending Interactions.

Sending of object state information is typically handled using higher-level object-management classes, such as DtEntityPublisher, rather than by sending individual update messages directly using DtExerciseConn. For more information, please see 4.5 - Working with Locally Simulated Entities.

4.2.4.2 Receiving Data from the Exercise
The DtExerciseConn::drainInput() function receives and processes information from the RTI or the DIS network. From within DtExerciseConn::drainInput(), VR-Link executes any callbacks that you have registered on DtInteractions (for either HLA or DIS), DtPdus (for DIS), or various RTI services (for HLA).

Your application should call DtExerciseConn::drainInput() periodically, usually once per simulation loop. This is true for HLA even if your application does not care about remotely simulated objects or remotely generated interactions, because the RTI requires RTI::tick() to be called periodically.

drainInput() repeatedly calls RTI::tick() until it fails to return RTI::RTI_TRUE (meaning there is no more data waiting to be read).

The mintime argument lets you specify a minimum amount of time to spend before returning. This value is passed to RTI::tick().

drainInput() reads PDUs from the network directly.

The optional timeout argument to drainInput() lets you specify a time (in seconds) after which drainInput() should return even if there is more data left to be read. A value of -1 (the default) is to never return if there is still data to be read. A value of 0 means return immediately. The second argument to drainInput() specifies the number of packets to be read or the number of times to call RTI::tick() in between tests of whether the timeout has been exceeded.

4.2.4.3 Post-Drain Callbacks
Post-drain callbacks are callback functions that you can register with a DtExerciseConn, and have called automatically by DtExerciseConn::drainInput() immediately before it returns. Post-drain callbacks are called after all interaction, PDU, and RTI service callbacks have been made. For more information about callbacks in general, please see 2.7.3 Using Callbacks.

Post-drain callbacks have the following function signature:

void myCallback(void* usr);
They are registered with a DtExerciseConn using addPostDrainCallback(), and unregistered using removePostDrainCallback(). The value passed to your callback function as the usr pointer is the value that was passed as the usr argument to addPostDrainCallback().

The most common use of post-drain callbacks is to get around an HLA restriction. RTI services cannot be invoked from within user callbacks on other RTI services. For example, at the time that you are processing an incoming interaction within an interaction callback, you cannot send an interaction in response. But you can register a response-sending post-drain callback that is executed after all RTI service callbacks have been invoked, when it is safe to send interactions. For more information, please see 4.3.2.1 Making RTI Calls in Response to Interactions.

4.2.4.4 Time Stamp Type
DtExerciseConn's setTimeStampType() function lets you set the time stamp type of your application to either DtTimeStampAbsolute or DtTimeStampRelative. Use DtTime-StampAbsolute if your local clock is synchronized to a global exercise clock, and you want to use the values of time stamps on messages from other synchronized hosts in dead-reckoning calculations. The default, DtTimeStampRelative, indicates that your local clock is not necessarily synchronized to anyone else's clock, and therefore time of receipt is used in dead-reckoning rather than incoming time stamp values. For more information, please see 2.7.6 Timestamps.

When using absolute timestamping, make sure to keep VR-Link simulation time in step with your system clock by passing the current time to setSimTime() each frame.

4.2.4.5 Initialization Status
If VR-Link fails during initialization, the default behavior is to abort. DtExerciseConn's constructor has an optional argument (status) that you can use to store the result of initialization. When this argument is non-NULL, the exercise connection does not exit if a non-license management related problem occurs during startup. The cause of the failure is put into this variable to be inspected later. For more information, please see exerciseConnDIS.h and exerciseConnHLA.h.

Note
If you use the status argument and its value is 0 (zero), the connection is good. If the value is not 0, the object did not construct properly and its behavior is undefined.
To cleanly check for license management errors, two global functions enable you to check whether a VR-Link or RTI license is available from the license server before they try to create any VR-Link data structures. They are DtHaveVrLinkLicense() and DtHaveRtiLicense() (defined in checkLicense.h). These functions return a bool instead of calling DtFatalError and exiting.

4.3 - Working with Interactions
Table of Contents
4.3.1 Sending Interactions
4.3.2 Receiving Interactions
4.3.2.1 Making RTI Calls in Response to Interactions
Within VR-Link, we use the term interaction to refer to the data that is exchanged among simulation applications in an exercise to describe events, such as the firing of a munition, detonation of a munition, or collision of entities.

While the term is from HLA (rather than DIS), we use it in a protocol-independent sense to refer to an HLA interaction or a DIS PDU that describes an event.

Each type of interaction has its own class, for example, fire, detonate, and collision interactions are represented by DtFireInteraction, DtDetonationInteraction, and DtCollisionInteraction respectively. For both DIS and HLA, the individual interaction classes are derived from DtInteraction. DtInteraction is defined in hInteraction.h (HLA) and dInteraction.h (DIS). If you include interaction.h, an appropriate version is included.

VR-Link has protocol-specific versions of each of the interaction classes. Although the protocol-specific versions of these classes are defined separately, most of the public member function names and signatures are used in both versions, so you can use most of them in the same way, regardless of whether you are using DIS or HLA.

A similar naming scheme exists for individual interaction classes and their header files. The following table lists some interaction classes and their associated header files for HLA, DIS, and protocol-independent programming. The protocol-independent header files include the appropriate version of each class for the protocol for which you are building.

Interaction Class Header File Naming Conventions
Interaction	HLA	DIS	Protocol-independent
DtFireInteraction	fireInteractionHLA.h	firePdu.h	fireInteraction.h
DtDetonationInteraction	detonationInteractionHLA.h	detonationPdu.h	detonationInteraction.h
DtCollisionInteraction	collisionInteractionHLA.h	collisionPdu.h	collisionInteraction.h
For DIS applications, DtFireInteraction, DtDetonationInteraction, DtCollisionInteraction, and so on are equivalent to DtFirePdu, DtDetonationPdu, and DtCollisionPdu. That is, we typedef one to the other. You can use the DtPdu class names if your application is only for DIS. However, you must use the DtInteraction names if you are writing code for both DIS and HLA, and this is what we recommend.

In DIS, DtInteraction is derived from DtPdu. The DtInteraction class itself has no real functionality, but the extra level gives our class hierarchy some structure. For example, DtFirePdus are (and can be implicitly cast to) DtInteractions and DtPdus. Entity state PDUs are not interactions, and thus DtEntityStatePdu is derived directly from DtPdu, not from DtInteraction.

4.3.1 Sending Interactions
To send interactions:

Create an instance of the appropriate interaction class (derived from DtInteraction).
Use its mutator functions to set values for the different parameters.
Send it using DtExerciseConn's sendStamped() function.
The following code shows how to create and send a fire interaction, which informs the exercise that you have fired a munition. The example assumes that myId, targetId, and missileId are existing objects.

DtExerciseConn exerciseConn(...);
   ...
// Create a DtFireInteraction
DtFireInteraction fireInter;
// Fill the DtFireInteraction with data
fireInter.setAttackerID(myId);
fireInter.setTargetID(targetId);
fireInter.setMunitionId(missileId);
fireInter.setEventId(exerciseConn.nextEventId());
   ...
// Send to the exercise
exerciseConn.sendStamped(fireInter);
In both DIS and HLA, sendStamped() includes a time stamp with outgoing interactions. Because this is usually desired, we recommend that you use sendStamped() to send interactions, rather then send().

The value used for the time stamp is the value returned by DtExerciseConn's currentTimeForStamping() function. By default, this function returns the current value of the system clock when using relative timestamping, or the current value of VR-Link simulation time when using absolute timestamping. If you want sendStamped() to compute timestamps for outgoing messages differently, you can subclass DtExerciseConn and override currentTimeForStamping(). Timestamps are marked as either "relative" or "absolute" depending on the DtExerciseConn's current time stamp type. For more information, please see 2.7.6 Timestamps.

For a description of the mutator functions for a particular interaction class, please see the appropriate header files.

For DIS, sendStamped() also puts the DtExerciseConn's exercise ID into the header of outgoing PDUs.

4.3.2 Receiving Interactions
Incoming interactions are handled through interaction callbacks. For more information about callbacks, please see 2.7.3 Using Callbacks.

Application developers write and register callback functions for a particular interaction type with VR-Link, and VR-Link calls those functions when it receives an interaction of that type from within DtExerciseConn::drainInput(). The received interaction is passed to the callback function, allowing you to process the interaction as it arrives.

Each interaction class has the static member functions addCallback() and removeCallback(). These functions allow you to register and unregister your callback functions for particular interaction classes.

There is a different callback function type for each interaction class. For example, only callback functions that take a DtFireInteraction pointer as an argument can be registered with the DtFireInteraction class. A DtFireInteraction callback might look like this:

void myFireCallback(DtFireInteraction* inter, void* usr)
{
   std::cout << "Got a Fire Interaction from " << 
      inter->attackerId().string()<< std::endl;
}
It would be registered with VR-Link's DtInteraction class like this:

DtFireInteraction::addCallback(exerciseConn, myFireCallback, NULL);
Note
Since addCallback() is a static member of DtFireInteraction, it can be called using the qualified name, rather than calling it on a particular instance of DtFireInteraction.
The value passed to your callback function as usr is the value that was passed as the usr argument to addCallback(). Often, this usr argument passes a pointer to an object on which you want to call a member function from within your callback. Simply cast usr back to the object's type within the callback. For examples of passing objects through the usr pointer, please see 2.7.3 Using Callbacks.

When an interaction is received for which there are multiple callbacks registered, the callbacks are called in the opposite order from that in which they were registered.

Note
DtInteractions are transient, that is, they are deleted by VR-Link immediately after the last callback function registered for the interaction is called. Therefore, do not attempt to delete or save a pointer to the DtInteraction passed to your callback function. If you need to save the data, make a copy of the DtInteraction.
4.3.2.1 Making RTI Calls in Response to Interactions
In HLA applications, interaction callbacks are called from within RTI::tick() (which is called by DtExerciseConn::drainInput()). Some RTIs do not allow calls to RTI services from within other RTI service calls (including RTI::tick()). This means that you cannot directly or indirectly make any RTI calls from within your interaction callbacks.

If you need to make RTI calls based on the receipt of a DtInteraction, in your interaction callback, use DtExerciseConn::addPostDrainCallback() to register a function with VR-Link. It will get executed right before drainInput() returns, when it is safe to make RTI calls.

For example, the following code will ensure that your application sends out a fire interaction each time it receives a fire interaction:

void sendFire(void *usr)
{
   // Cast the usr pointer back to a DtExerciseConn
   DtExerciseConn* exConn = static_cast<DtExerciseConn*>(usr);
   // Create and send a DtFireInteraction
   DtFireInteraction fireInter;
   fireInter.setAttackerId(...);
   ...
   exConn->sendStamped(fireInter);
   // Remember to deregister ourselves, so that we don't 
   // get called again the next time drainInput is called.
   exConn->removePostDrainCallback(sendFire, exConn);
}
void fireCb(DtFireInteraction* inter, void *usr)
{
   // Cast the usr pointer back to a DtExerciseConn
   DtExerciseConn* exConn = static_cast<DtExerciseConn*>(usr);
   // Can't send a fire interaction here, since that 
   // would involve an RTI call from within an RTI-service
   // callback. So instead, register a fire-sending 
   // function (sendFire) as a postDrainCallback.
   exConn->addPostDrainCallback(sendFire, exConn);
}
main()
{
   DtExerciseConn exerciseConn(...);
   ...
   // Register fireCb as a fireInteraction callback,
   // passing a pointer to the DtExerciseConn as the usr
   // pointer, so that it will be available to us within
   // the callback.
   DtFireInteraction::addCallback(&exerciseConn, fireCb,
      &exerciseConn);
   ...
}
For more information, please see 4.2.4.3 Post-Drain Callbacks.

4.4 - Working with Entities
VR-Link provides many classes that help inform the exercise about the state of your locally simulated entities and other objects, and inform your application about the state of remotely simulated entities and other objects.

These classes include:

DtObjectPublisher and its subclasses, for example, DtEntityPublisher, send updates to the exercise.
DtReflectedObjectList and its subclasses, for example, DtReflectedEntityList, keep track of remote objects.
DtReflectedObject and its subclasses, for example, DtReflectedEntity, represent a single remote object.
DtStateRepository and its subclasses, for example, DtEntityStateRepository, encapsulate an object's state.
In discussing how to manage objects using publishers, reflected object lists, reflected objects, and state repositories, we will focus on the classes used to manage entities – the most common kind of object in most exercises. Our concept of entities reflects the DIS and RPR FOM concept. Entities include vehicles, life forms, and most other types of real-world objects that have a position in space.

Publishers, reflected object lists, reflected objects, and state repositories exist in VR-Link for other types of objects as well, including aggregates, emitters, transmitters, designators and receivers. For information about managing these other types of objects, please see 4.8 - Working with Other Types of Objects.

4.5 - Working with Locally Simulated Entities
Table of Contents
4.5.1 Creating a DtEntityPublisher
4.5.1.1 Other DtEntityPublisher Constructors
4.5.1.2 Choosing Entity Identifiers
4.5.2 Setting an Entity's State
4.5.3 Coordinates
4.5.4 Example of Setting the State of an Entity
4.5.5 Using the DtEntityPublisher::tick() Function
4.5.5.1 How the tick() Function Knows When to Send Data
4.5.6 Setting Position and Orientation Thresholds
4.5.7 Removing a Locally-Simulated Entity
To inform other simulation applications about the state of locally-simulated entities, you must:

Create a DtEntityPublisher for each locally-simulated entity.
Update its current state during every frame through its DtEntityStateRepository.
Call DtEntityPublisher::tick().
The tick() function ensures that any needed information is sent to the other participants through the exercise connection.

4.5.1 Creating a DtEntityPublisher
VR-Link has versions of DtEntityPublisher for HLA and DIS, defined in entityPublisherHLA.h and entityPublisherDIS.h respectively. Rather than include both, you can include entityPublisher.h, which includes the appropriate version based on the presence of DtHLA=1 in your compile line.

Although the two versions of DtEntityPublisher are defined separately, most of the public member function names and prototypes have the same names, so you can make most of these calls regardless of which protocol you are using.

You can create an instance of DtEntityPublisher in a protocol-independent manner using a constructor that takes a DtExerciseConn and DtEntityType as arguments, for example:

DtExerciseConn exConn(...);
DtEntityType tankType(1, 1, 225, 1, 1, 0, 0);
DtEntityPublisher tankPub(tankType, &exConn);
The DtExerciseConn is the connection through which the publisher sends its updates.

The DtEntityType (defined in entityType.h) represents a seven-component enumeration defined by the DIS protocol and reused by DIS-based FOMs like the RPR FOM. It is used in outgoing entity state PDUs and in HLA updates (if you are using a FOM that includes this concept), and also determines which HLA object class is used to represent the entity in an HLA exercise. In the previous example, the entity type is that of an M1A1 tank. For a comprehensive list of valid entity types, please see the SISO Enumerations Document.

4.5.1.1 Other DtEntityPublisher Constructors
DtEntityPublisher has a second protocol-independent constructor that takes as arguments three attributes of an entity that are not likely to change during a simulation:

Dead-reckoning algorithm
Guise (alternate entity type)
Force ID.
DtEntityPublisher has protocol-specific constructors that allow you to specify parameters such as the HLA object class to represent the object. These are described in the chapters on the protocol-specific interfaces.

4.5.1.2 Choosing Entity Identifiers
All versions of the DtEntityPublisher constructor have an optional final argument that lets you choose an identifier for the entity. Object identification is handled differently in DIS and HLA. For more information about the different ways of identifying objects, please see 4.7 - Identifying Objects.

In HLA, the identifier that you are allowed to choose is the object name – an arbitrary character string that can be used to refer to an entity in inter-federate communications. If you omit the name argument to the DtEntityPublisher constructor, as in the example on the previous page, the RTI chooses one for you. The object handle, another form of object identification is always chosen by the RTI.

In the RTI 1.3. API, you can choose a name for an object at any time. In the RTI 1516 API, if you want to provide a name for an object, you must reserve the name before you create the object. If you use the VR-Link protocol independent API, VR-Link does this work for you. However, the way that VR-Link handles name reservation is not as efficient as if you do it yourself.

To reserve a name you must make a call to the RTIambassador, as follows:

ExConn->rtiAmb()->reserveObjectInstanceName(theName);
Then tick the RTI. The RTI then calls the Federate Ambassador to let the federate know if the name reservation succeeded or failed.

VR-Link keeps a list of all names that have been successfully reserved. When you create a publisher for an object and specify a name, VR-Link checks the list of reserved names, if the name is not found, it requests the reservation and ticks the RTI until it gets a response or times out. This can be time consuming, but it provides source code compatibility with previous versions of VR-Link.

You can set the number of times the publisher ticks the RTI, and the duration of the ticks using static methods in DtHlaObjectManager, as follows:

static double requestNameTickTime();
static void setRequestNameTickTime(double time);
static int numberOfRequestNameTries();
static void setNumberOfRequestNameTries(int tries);
If the publisher does not get a successful name reservation after several tries, it allows the RTI to pick the name.

VR-Link applications can make RTI calls to reserve names before they create publishers. If you want to create multiple objects it would be best to batch these requests. This could greatly improve performance. VR-Link automatically registers to get all name reservation success notifications.

In DIS, the identifier that you are choosing is a DtEntityIdentifier, the three-component identifier that is used both within an application and between applications to identify an entity. If you omit the identifier argument to the DtEntityPublisher, as in the example on the previous page, VR-Link chooses one for you, using DtExerciseConn's nextId() function.

The following example shows how you choose an identifier for HLA and DIS:

#if DtHLA
DtGlobalObjectDesignator id = "Object1";
#elif DtDIS
DtGlobalObjectDesignator id = DtEntityIdentifier(1, 2, 3);
#endif
DtExerciseConn exConn(...);
DtEntityType tankType(1, 1, 225, 1, 1, 0, 0);
DtEntityPublisher tankPub(tankType, &exConn, id);
If you do not choose an identifier for an object when you create the DtEntityPublisher, you can use the following DtEntityPublisher inspector functions to find out the identifier that was chosen:

globalId() returns the global identifier of the object – the object name in HLA; the entity identifier triplet in DIS
localId() or id() returns the local identifier of the object – the object handle in HLA; the entity identifier triplet in DIS.
4.5.2 Setting an Entity's State
You can set a DtEntityPublisher's state through its DtEntityStateRepository (defined in entityStateRepository.h) – a container for an entity's state.

Note
DtEntityStateRepository is derived from DtBaseEntityStateRepository, so some inherited member functions appear only in the base class.
In each iteration of your simulation, update the DtEntityStateRepository of each entity you are simulating locally so that it contains the current state of the entity before calling DtEntityPublisher::tick(). You can get a pointer to a DtEntityPublisher's DtEntity-StateRepository using the member function DtEntityPublisher::entityStateRep(). (You can use esr() as shorthand for entityStateRep().)

DtEntityStateRepository has mutator functions that allow you to set the various components of an entity's state. You can set time, space, and position information with:

setLocation()
setVelocity()
setAcceleration()
setOrientation()
setRotationalVelocity().
You can call these functions with a time argument that specifies the simulation time at which you want to get or inspect the data. The default is the current value of VR-Link simulation time as last set with setSimTime().

You can set components that affect the outward appearance of an entity with functions such as:

setDamageState()
setFlamesPresent()
setEngineSmokeOn()
setHatchState().
For a complete list, please see entityStateRepository.h.

DtEntityStateRepository has similar inspector functions, but these are usually used to inspect a remote entity's state, rather than that of a locally simulated entity.

Some mutator functions take enumerations as arguments. Values for these enumerations are in disEnums.h. Functions that take bool should be passed either true or false.

4.5.3 Coordinates
Positions, velocities, and accelerations must be set in geocentric coordinates, as specified in the DIS Standard and DIS-based FOMs like the RPR FOM. In this coordinate system, the origin represents the center of the earth, the X-Y plane goes through the equator, with the X axis passing through the prime meridian, the Y axis passing through 90 degree east longitude, and the Z axis pointing through the north pole (Geocentric Coordinate System). Use the DtVector class to set coordinates. Coordinates are specified in meters.

Orientation is specified as a DtTaitBryan, a class that represents three angles – successive rotations needed to transform from the geocentric coordinate system to the entity coordinate system (origin at the center of mass, X points out the front, Y points out the right side, Z points out the bottom (as illustrated below)). The specific sequence of rotations is known as the Tait-Bryan sequence, in which you first rotate about Z, then about the new Y, then about the newest X axis. The angles are specified in radians.

entitycoordinatesystem.png
Entity coordinate system
For illustrations of the different coordinate systems, information about converting between rotation matrices and Euler angles, and information about converting among the many different coordinate systems supported by VR-Link, please see 13.3 - Coordinate Conversions.

Alternatively, VR-Link provides various View classes, which let you set data in a

DtEntityStateRepository in other coordinate systems without performing explicit conversions. These are described in 4.9 - Coordinate Views.

4.5.4 Example of Setting the State of an Entity
The following code sample is an example of using DtEntityStateRepository's mutator functions to set the current state of an entity:

DtEntityPublisher tankPub(...);
...
// Grab a pointer to our entity publisher's ESR
DtEntityStateRepository *esr = tankPub.entityStateRep();
// Set location to somewhere near Ft. Hunter Liggett, CA, 
// in geocentric coordinates.
esr->setLocation(DtVector(-2696545.0, -4430407.0, 3701906.0));
// Velocity and acceleration are also in geocentric 
// coordinates
esr->setVelocity(DtVector(100.0, 100.0, 100.0));
esr->setAcceleration(DtVector(0.0, 0.0, 0.0));
// Set orientation as three Euler angles in radians
esr->setOrientation(DtTaitBryan(-2.11, 0.948, 2.469);
// Set angular velocity vector in body coordinates
esr->setRotationalVelocity(DtVector(0.0, 0.10, -0.125);
// Indicate that the entity is on fire
esr->setFlamesPresent(true);
// Indicate that the entity is slightly damaged
// The DtDamageState enumeration is in disEnums.h
esr->setDamageState(DtDamageSlight);
...
You can use DtEntityStateRepository::printData() to print the current contents of a DtEntityStateRepository in human readable form.

4.5.5 Using the DtEntityPublisher::tick() Function
DtEntityPublisher::tick() is the function that does most of the DtEntityPublisher's work. Call it for each DtEntityPublisher once per simulation frame, after the entity's state has been updated using the DtEntityStateRepository's mutator functions.

The tick() function decides what data needs to be sent to the other exercise participants and formats and sends that data through the DtEntityPublisher's exercise connection.

4.5.5.1 How the tick() Function Knows When to Send Data
DtEntityPublisher internally maintains a second DtEntityStateRepository representing the way remote applications currently see the entity, based on prior entity state updates and dead-reckoning calculations. VR-Link compares the current state with this lower fidelity representation of state. If position or orientation differences exceed the DtEntityPublisher's thresholds, or if any other attributes have changed at all, data needs to be sent so that remote applications will have the most current information.

Current data is sent whenever:

Position or orientation thresholds are exceeded
Other state data changes
The time since the last update was sent exceeds a threshold.
In the third case, data is sent even if nothing has changed. (This DIS rule is sometimes known as an entity heartbeat.) If data needs to be sent, an Entity State PDU is sent to the exercise containing current values for all fields.

An attribute update is sent containing values for only those attributes whose update conditions (as specified by the FOM) have been met. The update condition for most attributes is any change since the attribute was last sent. However, in the RPR FOM, position, velocity, acceleration, orientation, and angular velocity are always updated together based on a single update condition – when the current position or orientation differs from the value that would be computed by dead-reckoning exceeds thresholds, as described earlier in this section.

4.5.6 Setting Position and Orientation Thresholds
Position and orientation thresholds are used to determine when position and orientation data needs to be sent to other exercise participants (as described in ). The DtThresholder class (defined in thresholder.h) holds threshold values. DtThresholder has a set of global threshold values that are shared among all entities that have not overridden them. To change the global threshold values, use DtThresholder's static mutator functions.

You can override global thresholds on a per-entity basis through the mutator functions of each entity's thresholder object, which can be obtained using DtBaseEntityStateRepository::thresholder(). DtEntityPublisher has setDfltThreshold() member functions for compatibility with older releases of VR-Link, but the DtThresholder member functions should be used instead. A DtThresholder has a DtArtPartThresholder (available through the artPartThresholder() member function) through which you can set and inspect articulated parts thresholds. DtArtPartThresholder is defined in artPartThresh.h.

The translation threshold is specified in meters, and defaults to 1.0. The rotation threshold is specified in radians and defaults to the radian equivalent of 3.0 degrees.

For DIS, there is an additional time threshold that defaults to 5.0 seconds. Time is specified in seconds.

4.5.7 Removing a Locally-Simulated Entity
Deleting a DtEntityPublisher removes an entity from the exercise.

In HLA, the DtEntityPublisher destructor calls the deleteObjectInstance RTI service.

In DIS, the DtEntityPublisher destructor sends a final Entity State PDU with the FinalPdu appearance bit (bit 23) set. If you do not want a DtEntityPublisher to send this final PDU on destruction, pass an argument of false to its sendFinalPduOn-

Destruction() member function at some point before deleting it.

4.6 - Working with Remote Entities
Table of Contents
4.6.1 Creating Reflected Entity Lists
4.6.2 Iterating Through a DtReflectedEntityList
4.6.3 Delayed Discovery of Reflected Objects
4.6.4 Inspecting an Entity's State
4.6.5 Dead-Reckoning
4.6.5.1 Dead-Reckoning Details
4.6.5.2 Dead-Reckoning Algorithms
4.6.6 Using Smoothing
4.6.7 Learning when Entities Join or Leave an Exercise
4.6.8 Notifying an Application when State Updates Arrive
4.6.9 Timing Out Entities
4.6.10 Subclassing DtReflectedEntity
A DtReflectedEntityList maintains the current state of entities that VR-Link learns about through updates received from other participants in an exercise.

For DIS, an application receives entity state PDUs sent by itself along with those sent by other applications. Therefore, in DIS the DtReflectedEntityList contains a representation of locally simulated entities as well.

Each entity in the reflected entity list is represented by an instance of DtReflectedEntity. The list provides member functions that let you look up a DtReflectedEntity local ID or global ID, or iterate through all of the entities in the list.

VR-Link provides both HLA and DIS versions of DtReflectedEntityList and DtReflectedEntity, which are defined in reflectedEntityListHLA.h, reflectedEntityHLA.h, reflectedEntityListDIS.h, and reflectedEntityDIS.h. Rather than include all of these header files, you can include reflectedEntityList.h and reflectedEntity.h, which include the appropriate versions based on whether or not you have included the DtHLA=1 definition in your compile line.

Although the two versions of these classes are defined separately, most of the public member function names and prototypes are shared by the two versions, so that you can make most of these calls regardless of which protocol you are using.

4.6.1 Creating Reflected Entity Lists
A DtReflectedEntityList is created on an exercise connection as follows:

DtExerciseConn exConn(...);
...
DtReflectedEntityList(&exConn);
Whenever the DtReflectedEntityList detects a new entity, it automatically creates a new DtReflectedEntity to represent it. Whenever it receives a state update, it updates the corresponding DtReflectedEntity to reflect the current state. These two events will occur automatically as long as DtExerciseConn::drainInput() is called periodically within your application. No further action is required before inspecting data on remote entities.

4.6.2 Iterating Through a DtReflectedEntityList
To iterate through a DtReflectedEntityList, you can use the first() and last() member functions, which return the first and last entities in the list. Use DtReflectedEntity's next() and prev() member functions to get the next and previous entity in the list. These two functions return NULL if you try to read past the end or beginning of the list. You can iterate through all entities in the list as follows:

DtReflectedEntityList rel(...);
...
for (DtReflectedEntity* ent = rel.first();
   ent;
   ent = ent->next())
{
   ...
}
DtReflectedEntity also has wrapNext() and wrapPrev() member functions that are similar to next() and prev(), but which loop back to the first or last entity in the list when you try to move past the end or beginning of the list.

You can obtain the total number of entities in the DtReflectedEntityList with the count() member function.

If you want to look up a DtReflectedEntity by its ID, use DtReflectedEntityList::lookup(). The lookup() member function can accept either of the following ID types:

Global ID (object name in HLA; Entity Identifier triplet in DIS).
Local ID (object handle in HLA; Entity Identifier triplet in DIS).
For example:

DtGlobalObjectDesignator id = fireInteraction.targetId();
DtReflectedEntity* ent = reflectedEntityList.lookup(id);
or

#if DtHLA
DtObjectId id = 15;
#elif DtDIS
DtObjectId id = DtEntityIdentifier(1, 2, 3);
#endif
DtReflectedEntity* ent = reflectedEntityList.lookup(id);
For more information about the different ways of identifying objects, please see 4.7 - Identifying Objects.

4.6.3 Delayed Discovery of Reflected Objects
You can delay discovery of reflected objects until some user-defined condition is met. VR-Link will not add an object to a reflected object list or inform the application about it until the specified predicate evaluates to true.

While this functionality can be used in DIS as a means of filtering, it is especially useful in HLA applications when an object is discovered before attribute information arrives. For example, you can indicate that VR-Link should not add the object to the reflected object list until values for certain important attributes (for example, entity type) arrive. This relieves applications from the need to continuously check whether attribute values are valid yet.

To specify the discovery condition for a reflected object list, you must write a predicate function that returns a boolean value, and then register it with the list, using setDiscoveryCondition(). For example, if you want a reflected entity list to wait until the entity type is something other than the initial value (0,0,0,0,0,0,0), write a function that looks like the following:

bool criteria(DtReflectedObject* obj, void* usr)
{
   DtReflectedEntity* ent = (DtReflectedEntity*) obj;
   if (ent->esr()->entityType() == DtEntityType(0,0,0,0,0,0,0))
   {
      return false;
   }
   return true;
}
Then tell the reflected entity list about it like so:

DtReflectedEntityList rel(&exConn);
rel.setDiscoveryCondition(criteria, NULL);
The need to wait for the entity type is very common, so this behavior is already available in DtReflectedEntityList, but it is off by default. To turn it on, when you create your list, call:

rel.discoverOnlyWhenEntityTypeKnown(true);
Calling it again with false turns this behavior off again.

4.6.4 Inspecting an Entity's State
DtReflectedEntity uses a DtEntityStateRepository to store the current state of an entity. This is the same class used by DtEntityPublisher to store the state of a locally simulated entity. For more details, please see 4.5.2 Setting an Entity's State. Individual state data items are inspected through DtEntityStateRepository inspector functions, rather than directly through the DtReflectedEntity.

You can get a pointer to a DtReflectedEntity's DtEntityStateRepository using DtReflectedEntity::entityStateRep() (or DtReflectedEntity::esr()).

DtEntityStateRepository has inspector functions that allow you to look at various components of an entity's state. You can get time, space, and position information using:

location()
velocity()
acceleration()
orientation()
bodyToGeoc()
rotationalVelocity().
You can examine components that affect the outward appearance of an entity with functions such as:

damageState()
flamesPresent()
engineSmokeOn()
hatchState().
DtEntityStateRepository has inspector functions that return the last value that was passed to the respective mutator function. These functions make it easier to obtain non-dead-reckoned data from an DtEntityStateRepository that is, in general, doing dead-reckoning. The functions are:

lastSetLocation()
lastSetVelocity()
lastSetAcceleration()
lastSetOrientation()
lastSetRotationalVelocity().
For the complete list of functions, please see entityStateRepository.h. DtEntityStateRepository is derived from DtBaseEntityStateRepository, so inherited functions are in baseEntityStateRepository.h.

In HLA, when you create a DtReflectedEntityList, VR-Link requests an update of all attributes. However, because of the way HLA works, you cannot be absolutely certain that all the attributes have been updated at the point that you inspect them. For information about how to resolve this problem, please see the HLA-specific paragraphs in 4.6.7 Learning when Entities Join or Leave an Exercise.

DtEntityStateRepository has mutator functions, but these are usually used to set a locally simulated entity's state, rather than that of a reflected entity, which is set automatically from data in state updates received from the exercise.

Positions, velocities, and accelerations returned by DtEntityStateRepository are in geocentric coordinates, as specified in the DIS Standard and DIS-based FOMs. (For details, please see 4.5.3 Coordinates.) Orientation is available in one of the following forms:

The orientation() member function returns a DtTaitBryan.
The bodyToGeoc() member function returns a rotation matrix that will rotate from the body to geocentric coordinate system.
For information about how to convert rotation matrices to Euler angles, and how to convert among the many different coordinate systems supported by VR-Link, please see 13.3 - Coordinate Conversions.

VR-Link also provides various View classes (described in 4.9 - Coordinate Views), which provide the ability to inspect data in a DtEntityStateRepository in other coordinate systems without explicitly performing coordinate conversions.

Some of the inspector functions return enumerations. Values for these enumerations are in disEnums.h. When a bool is returned, it will be either true or false.

The following example shows how to use DtEntityStateRepository's inspector functions to examine the current state of a reflected entity, within a function that prints part of the state of the first entity in the list:

void printStateOfFirstEnt(DtReflectedEntityList *rel)
{
   // Grab a pointer to the first entity.
   DtReflectedEntity *firstEnt = rel->first();
   // Exit if the list is empty
   if(!firstEnt)
   {
      return;
   }
   DtEntityStateRepository *esr = firstEnt->entityStateRep();
   // Print out Entity information.
   cout
      << "ID: "     << firstEnt->globalId().string() << '\n'
      << "Loc: "    << esr->location().string() << '\n'
      << "Vel: "    << esr->velocity().string() << '\n'
      << "Accel: "  << esr->acceleration().string() << '\n'
      << "Orient: " << esr->orientation().string() << '\n'
      << "AngVel: " << esr->rotationalVelocity().string() << endl;
   if (esr->flamesPresent())
   {
      cout << "Flaming!\n";
   }
   // The DtDamageState enumeration is in disEnums.h
   if (esr->damageState() == DtDamageDestroyed)
   {
      cout << "Destroyed!\n";
   }
}
DtEntityStateRepository::printData() works in a similar way, and you can use it to print the current contents of a DtEntityStateRepository in human readable form.

4.6.5 Dead-Reckoning
By default, the position, velocity, and orientation for a DtReflectedEntity that are returned by the member functions of its DtEntityStateRepository (location(), velocity(), orientation(), and bodyToGeoc()), are dead-reckoned values. That is, they are not necessarily the values last received via state updates from the exercise. They are extrapolated forward to the current value of VR-Link simulation time from acceleration, velocity, and angular velocity based on the entity's current dead-reckoning algorithm.

The current value of VR-Link simulation time is the last value passed to setSimTime(), which should be called once per frame by an application. In this way, all entities are dead-reckoned to the same time within that frame, regardless of the order in which the locations are inspected. Time of validity of the inputs to the dead-reckoning equation is the value of VR-Link simulation time when the data was received from the exercise.

Notes
There is no performance penalty for calling the inspectors for dead-reckoned values more than once during a particular frame. As long as the value of VR-Link simulation time has not changed, the dead-reckoning code is not executed again; a cached value is used. Dead-reckoning is not performed for entities whose positions and orientations are never inspected.
Dead-reckoning applies to entities and aggregates, but not to the other objects.
Dead-reckoning of orientation as a set of Euler angles is a more expensive operation than dead-reckoning orientation as a rotation matrix. So use bodyToGeoc() rather than orientation() in cases where performance is an issue and you do not have an explicit need for the Euler angle representation.
For non-dead-reckoned values, use the values returned by DtEntityStateRepository's member functions lastSetLocation(), lastSetVelocity(), and so on.

4.6.5.1 Dead-Reckoning Details
A DtEntityStateRepository uses a DtDeadReckoner to perform dead-reckoning calculations, or other types of extrapolation of position and orientation. When DtEntity-StateRepository's mutator functions are used to set any position-related values, those values are passed to the DtDeadReckoner's mutators. Then, when DtEntityStateRepository's inspectors are used to ask for current values, the DtEntityStateRepository obtains extrapolated values from the dead-reckoner using its inspectors.

VR-Link's dead reckoning logic is in the virtual functions DtDeadReckoner::deadReckonPosition() and DtDeadReckoner::deadReckonOrientation(). These functions calculate the position and orientation based on the entity's current rates of movement and the time that has passed since the last update. To change the way dead-reckoning is handled by a DtEntityStateRepository:

Create a subclass of DtDeadReckoner.
Override DtDeadReckoner::deadReckonPosition() and DtDeadReckoner::deadReckonOrientation().
Tell a DtEntityStateRepository to use an instance of your subclass through its useDeadReckoner() function (which is inherited from DtBaseEntityStateRepository).
Similarly, if you want a DtEntityStateRepository not to perform dead-reckoning at all, pass NULL to setApproximator(). In fact, this is what a DtEntityPublisher does with its DtEntityStateRepository, since you typically do not want dead-reckoned values when inspecting the DtEntityStateRepository of a locally simulated entity.

To restore the DtEntityStateRepository's original default dead-reckoner, call useDeadReckoner() with no arguments.

4.6.5.2 Dead-Reckoning Algorithms
The enums for the dead-reckoning algorithms are as follows:

DtDrDrmRvw – Rotational, constant acceleration
DtDrDrmRpw – Rotational, constant velocity
DtDrDrmFvw – Fixed, constant acceleration
DtDrDrmFpw – Fixed, constant velocity
DtDrDrmRvb – Rotational, body coordinates, not commonly used and unimplemented in VR-Link
DtDrDrmRpb – Rotational, body coordinates, not commonly used and unimplemented in VR-Link
DtDrDrmFvb – Fixed, body coordinates, not commonly used and unimplemented in VR-Link
DtDrDrmFpb – Fixed, body coordinates, not commonly used and unimplemented in VR-Link
DtDrOther – No dead reckoning is calculated
DtDrStatic – No dead reckoning is calculated.
It is recommended that you use one of the Rotational algorithms when you require orientation to be dead reckoned (Such as visual simulations), if you only need positional calculations, then one of the Fixed algorithms will save you some processing power.

Similarly, if you expect entities to keep a constant non-zero acceleration, it is recommended you pick one of the "constant acceleration" options. This is particularly good for high speed entities, such as missiles. Otherwise, the constant velocity version will give you good results at a lower cost. When in doubt, we would generally recommend DtDrDrmRpw to be a good default choice.

For details on the individual algorithms, consult the DIS standard (IEEE Std 1278.1-1995, Annex B or IEEE Std 1278.1-2012 Annex E).

4.6.6 Using Smoothing
VR-Link can smooth out the jumps in entity position that would otherwise occur when new HLA or DIS state data arrives. The DtSmoother class (defined in smoother.h) implements this functionality. DtSmoother is derived from DtDeadReckoner, so a DtSmoother can be used by a reflected entity's entity state repository as its DtDeadReckoner. If a DtEntityStateRepository is using a DtSmoother, the values returned by location(), velocity(), orientation() and bodyToGeoc() are smoothed values.

The DtReflectedEntityList constructors have an optional boolean argument indicating whether its reflected entities should use smoothers as their dead-reckoners or not (default is no). Alternatively, you can instruct an individual reflected entity's DtEntity-StateRepository to use a DtSmoother using DtEntityStateRepository's useSmoother() member function.

To set the global default time over which smoothing takes place, use DtSmoother's static function setDfltSmoothPeriod(). To override the default in individual DtSmoothers, use setSmoothPeriod().

Note
Smoothing applies to entities and aggregates, but not to other objects.
4.6.7 Learning when Entities Join or Leave an Exercise
Often, an application will want to be notified when an entity joins or leaves the exercise. This is achieved by registering entity-addition and entity-removal callbacks with a DtReflectedEntityList. Entity-addition callbacks are called by VR-Link just after an entity is added to the DtReflectedEntityList. Entity-removal callbacks are called just before an entity is removed from the DtReflectedEntityList. The callbacks are made within DtExerciseConn::drainInput() when your application receives news from the exercise that an entity has joined or left.

Entity-addition and entity-removal callbacks must have the following function signature:

void func(DtReflectedEntity* ent, void* userData);
The callbacks are registered with a DtReflectedEntityList using its addEntityAdditionCallback() and addEntityRemovalCallback() member functions. They can be unregistered with removeEntityAdditionCallback() and removeEntityRemovalCallback().

In the following example, the application prints HELLO and GOODBYE when an entity comes or goes, along with the ID of the entity:

void printHello(DtReflectedEntity* ent, void* userData)
{
   assert(ent);
   cout << "HELLO " << ent->id().string() << endl;
}
void printGoodbye(DtReflectedEntity *ent, void *userData)
{
   assert(ent);
   cout << "GOODBYE " << ent->id().string() << endl;
}
int main()
{
   ...
   rel->addEntityAdditionCallback(printHello, 0);
   rel->addEntityRemovalCallback(printGoodbye, 0);
   ...
}
An alternate method of receiving notification that an entity has joined or left the exercise is by subclassing DtReflectedEntityList, and overriding the virtual functions entityAdded() and removeAndDelete(). The entityAdded() member function is called just after an entity is added to a DtReflectedEntityList. The removeAndDelete() member function is called to remove an entity from the DtReflectedEntityList. If you override removeAndDelete(), be sure to call down to the base version of this function from within your implementation, since this is what actually accomplishes the removal of the entity from the list.

An entity is added to the DtReflectedEntityList as soon as VR-Link receives a discoverObject() service call from the RTI. This occurs before the first attribute update is sent by the RTI. Therefore, the DtReflectedEntity's DtEntityStateRepository will not contain any data at the time that the entity is passed to your entity addition callback or the overridden version of entityAdded(). Only the entity's ID will have been set at this point. Therefore, within your callback or entityAdded() you should only be doing things like saving a pointer to the entity, rather than trying to inspect any data.

Typically, the first update immediately follows the discoverObject() invocation for a new entity. Therefore, by the time drainInput() returns, most data will be valid for your application to inspect. If you want to be notified immediately after the first update arrives, please see the next section, 4.6.8 Notifying an Application when State Updates Arrive.

Another consideration is that these callbacks as well as entityAdded() and removeAndDelete() are called from within RTI callbacks. RTI rules prohibit making RTI calls from within an RTI callback, so do not make any RTI calls (or call any functions that make RTI calls) from within entityAdded() or removeAndDelete().

Entity addition callbacks and the virtual function entityAdded() are called after the first entity state PDU for an entity has been processed. Therefore, the state of the entity is available within entityAdded(), through the entity's DtEntityStateRepository. However in the interest of writing protocol-independent code (to take into account the HLA issues discussed in previous paragraphs), you might not want to inspect the data at this point in the code for DIS applications.

4.6.8 Notifying an Application when State Updates Arrive
Some applications might want to be notified when new state data is received from the application that is simulating a particular entity. You can do this by registering a post-update callback function with a DtReflectedEntity. These functions must have the following signature:

void func(DtReflectedEntity* ent, void* userData);
They are registered using DtReflectedEntity's addPostUpdateCallback() member functions. To unregister your callback function, use the removePostUpdateCallback() member function.

Post-update callbacks are called by VR-Link from within DtExerciseConn::drainInput() immediately after a state update message has been decoded into the reflected entity's DtEntityStateRepository. Therefore, when your callback is called, the DtEntityStateRepository will already reflect the new values contained in the update.

To illustrate use of this functionality, suppose you have an application that needs to create different types of graphic icons to represent different types of entities. You want to be notified when a new entity arrives, so that you can create a new icon, but entity type information is not available to an entity-addition callback in HLA. To check for the entity type, register a post-update callback from within your entity-addition callback. When the post-update callback is invoked, you can check to see whether you have received a value for the entity type (since in HLA, that data might not arrive in the first update):

void myEntityAdditionCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // A new entity has arrived, but its ESR is empty. Ask
   // to be notified when an update has been processed.
   ent->addPostUpdateCb(myPostUpdateCb, usr);
}
void myPostUpdateCb(DtReflectedEntity* ent, void* usr)
{
   assert(ent);
   // A state update for the entity has just been processed,
   // but there is no guarantee that the entity type was included.
   DtEntityStateRepository* esr = ent->esr();
   if (esr->entityType() != DtEntityType(0,0,0,0,0,0,0))
   {
      // We have received entity type info, and can now use it 
      // to create an appropriate icon.
      addIcon(esr->entityType());
      // We probably no longer need the post-update callback.
      ent->removePostUpdateCb(myPostUpdateCb, usr);
   }
}
int main()
{
   ...
   // Register the entity addition callback with a reflected
   // entity list.
   rel->addEntityAdditionCallback(myEntityAdditionCb, someObj);
   ...
}
Because the receipt of state data works differently in DIS and HLA, and because we wanted the post-drain callback mechanism to work in a protocol-independent manner, you do not have access to the update message itself from within the post-drain callback.

Note
If you want to actually intercept an incoming state update message in either HLA or DIS, please see the appropriate protocol-specific sections.
4.6.9 Timing Out Entities
DtReflectedEntityList can time entities out, removing them from the list if an update has not been received within some period of time.

This capability is on by default in DIS, where the rules state that an entity state PDU (heartbeat) must be sent periodically (usually once every 5 seconds), even if no data has changed. Therefore, if we have not received a heartbeat in a reasonable amount of time (usually 12 seconds), we can safely assume that the entity has left the exercise.

Note
If you are using DIS 7, the heartbeat can be set to different lengths based on entity type, class type, or whether or not entities are moving. Therefore you may want to approach timing out entities similarly to HLA.
In HLA, there is no heartbeat rule. It is perfectly valid for an entity to go several minutes or more without updating attributes, as long as nothing has changed. For this reason, timeouts are off by default. When timeout processing is off, a DtReflectedEntity is not removed from the DtReflectedEntityList until we are notified by the RTI that the entity has left the exercise.

You can control timeout processing for individual reflected entity lists. For both DIS and HLA, you can turn timeouts on and off using DtReflectedEntityList::setTimeoutProcessing(). (This function is inherited from the DtReflectedObjectList base class.) The argument is a bool, either true or false.

If timeout processing is on, the DtReflectedEntityList checks to see if any entities need to be timed out each time DtExerciseConn::drainInput() is called. The timeout interval (the amount of time that can elapse since the last update before an entity is timed out) defaults to 12.0 seconds, but can be configured with DtReflectedObjectList::setTimeoutInterval().

Note
The timeout is calculated using real time, not simulated time.
4.6.10 Subclassing DtReflectedEntity
Some visually-oriented applications might want to associate additional data or functionality with a DtReflectedEntity. One way to achieve this is by subclassing DtReflectedEntity. For example, you could use a subclass of DtReflectedEntity to associate graphics data with the entity.

If you subclass DtReflectedEntity (rather than associating data through composition, for example), you need to subclass DtReflectedEntityList as well. The reason for this is simple – DtReflectedEntities are created by the DtReflectedEntityList, and the DtReflectedEntityList only knows how to create DtReflectedEntities. You need to create a derived DtReflectedEntityList that knows how to create your derived DtReflectedEntities.

A DtReflectedEntityList uses the virtual function newReflectedEntity() to create DtReflectedEntities. It is this function that you must override with a definition that returns a new instance of your derived DtReflectedEntity.

The constructors for DIS and HLA versions of DtReflectedEntity take different arguments. Therefore, the two versions of DtReflectedEntityList::newReflectedEntity(), (which basically just passes its arguments to the DtReflectedEntity constructor) take different arguments as well.

The following example shows how to subclass the two classes:

class myReflectedEntity : public DtReflectedEntity
{
public:
   // Constructor
#if DtHLA
   myReflectedEntity(DtHlaObject* obj, DtExerciseConn* conn) : DtReflectedEntity(obj, conn)
#elif DtDIS
   myReflectedEntity(DtExerciseConn* conn,
      const DtEntityIdentifier& id, const DtEntityType& type) :
      DtReflectedEntity(conn, id, type)
#endif   
   {
      // The two versions may be able to share a body
      ...
   }
   // Specifics of myReflectedEntity
   ...
};
class myREL : public DtReflectedEntityList
{
public:
   // Constructor (same for both DIS and HLA)
   myREL(DtExerciseConn* exConn) : DtReflectedEntityList(exConn) {}
#if DtHLA
   virtual DtReflectedEntity* newReflectedEntity(DtHlaObject* obj) const
   {
      return new myReflectedEntity(obj, exerciseConn());
   }
#elif DtDIS
   virtual DtReflectedEntity* newReflectedEntity(const DtEntityIdentifier& id, const DtEntityType& type) const
   {
      return new myReflectedEntity(exerciseConn(), id, type);
   }
#endif
};

4.7 - Identifying Objects
Table of Contents
4.7.1 Identifying Objects in DIS
4.7.2 Identifying Objects in HLA
4.7.3 How VR-Link Identifies Objects
4.7.3.1 Choosing A Name in HLA
HLA and DIS identify objects differently.

4.7.1 Identifying Objects in DIS
In DIS, entities are identified by a triplet (site:application:entity) known as an entity identifier. This structure can be represented in VR-Link using the DtEntityIdentifier class (defined in entityIdentifier.h). Non-entity objects are identified in various ways. For example, emitter systems are identified using the Entity Identifier of the host entity plus an additional emitter number.

4.7.2 Identifying Objects in HLA
In HLA, an object can be identified in several ways:

All objects have an object handle – that an application uses to identify a particular object in RTI service calls. In HLA 1.3, the object handle is an integer. In the HLA 1516, the object handle is variable length data. The object handle is unique within a federation execution.
All objects also have an object name – a character string that can be used to identify an object. The object name is known to the RTI, and the RTI provides functions to find out an object's name, given its handle, and vice versa. Object names can be chosen by applications that register the objects with the RTI, however if you do not want to choose names for objects, the RTI will assign names for you. Object names are represented using char*, or VR-Link's DtString class.
FOMs may choose to define other ways of identifying particular kinds of objects. These other identifiers are merely attributes of the object, and do not have any special identifier characteristics as far as the RTI is concerned. For example, the BaseEntity class in the RPR FOM contains an attribute called EntityID that is represented by a DIS-style Entity Identifier triplet – the DtEntityIdentifier class in VR-Link.
4.7.3 How VR-Link Identifies Objects
To support protocol independence, VR-Link provides two types that can be useful in passing around the various types of identifiers.

You can use a DtObjectId (defined in objectId.h) (or local ID) regardless of protocol, to identify an object within an application, but it cannot be used to communicate the identity of an object to other applications in PDUs, interactions, or attribute updates. In HLA, DtObjectId is a class that serves as a wrapper around an RTI::ObjectHandle. In DIS, we typedef DtObjectId to DtEntityIdentifier.

You can use a DtGlobalObjectDesignator (or global ID) regardless of protocol to identify an entity in inter-application communication within PDUs, interactions, and attribute updates. In HLA, we typedef DtGlobalObjectDesignator to DtString – a VR-Link wrapper around char* that can be used to store object names. In DIS, we typedef DtGlobalObjectDesignator to DtEntityIdentifier, since in DIS that same type of ID is used to identify an object both within an application, and between applications.

Reflected object lists allow you to look up reflected objects by local ID or by global ID. DtObjectPublishers and DtReflectedObjects have functions to return both the object's local ID (id() or objectId()) and global ID (globalId()). PDU, interaction, and state repository classes have mutator functions that expect global IDs and inspector functions that return global IDs.

For example, if you have a DtEntityPublisher representing an entity that you are simulating, and you are sending a fire interaction, indicating that your entity is firing a munition, you might say:

fireInter.setAttackerId(entityPub.globalId());
If you receive a fire interaction from a particular entity, and want to find out more about its state, you can look up the entity in a reflected entity list like this:

DtReflectedEntity* ent = rel.lookup(fireInter.attackerId());
When constructing an HLA publisher, you can either choose a name for your object, or pass a NULL name (the default), and let the RTI choose for you. For examples, please see 4.5 - Working with Locally Simulated Entities.

4.7.3.1 Choosing A Name in HLA
In HLA, you can choose a name for an object. In HLA 1516, the RTI might reject the name. Therefore, the name must be reserved before you create a publisher. If you do not reserve the name, VR-Link reserves it for you, however, this may take time.

To reserve a name, call:

myExconn->rtiAmb()->reserveObjectInstanceName();
VR-Link caches all reserved names. Make sure you call tick() to allow the RTI to respond. Then you can create a publisher with the name you reserved. For more details, please see 4.5.1.2 Choosing Entity Identifiers.

4.8 - Working with Other Types of Objects
Table of Contents
4.8.1 Managing Emitters
As mentioned in 4.4 - Working with Entities, most of the procedures for managing entities apply to managing other types of objects.

However, rather than using DtEntityPublisher, DtReflectedEntityList, DtReflectedEntity and DtEntityStateRepository, you use other subclasses of DtObjectPublisher, DtReflectedObjectList, DtReflectedObject, and DtStateRepository to manage the appropriate type of objects. To use any of the following objects, read the description for managing an entity and substitute the appropriate object class for those used in the descriptions and examples for entities:

aggregate
DtAggregatePublisher (aggregatePublisher.h)
DtReflectedAggregateList (reflectedAggregateList.h)
DtReflectedAggregate (reflectedAggregateList.h)
DtAggregateStateRepository (aggregateStateRepository.h)
designator
DtDesignatorPublisher (designatorPublisher.h)
DtReflectedDesignatorList (reflectedDesignatorList.h)
DtReflectedDesignator (reflectedDesignator.h)
DtDesignatorRepository (designatorRepository.h)
emitter

DtEmitterSystemPublisher (emitterSystemPublisher.h)
DtReflectedEmitterSystemList (reflectedEmitterSystemList.h)
DtReflectedEmitterSystem (reflectedEmitterSystem.h)
DtEmitterSystemRepository (emitterSystemRepository.h)
radio receiver
DtRadioReceiverPublisher (radioReceiverPublisher.h)
DtReflectedRadioReceiverList (reflectedRadioReceiverList.h)
DtReflectedRadioReceiver (reflectedRadioReceiver.h)
DtRadioReceiverRepository (radioReceiverRepository.h)
radio transmitter
DtRadioTransmitterPublisher (radioTransmitterPublisher.h)
DtReflectedRadioTransmitterList (reflectedRadioTransmitterList.h)
DtReflectedRadioTransmitter (reflectedRadioTransmitter.h)
DtRadioTransmitterRepository (radioTransmitterRepository.h)
gridded data
DtGriddedDataPublisher (griddedDataPublisher.h)
DtReflectedGriddedData (reflectedGriddedData.h)
DtReflectedGriddedDataList (reflectedGriddedDataList.h)
DtGriddedDataRepository (griddedDataRepository.h).
environmental process objects
DtEnvironmentProcessPublisher (environmentProcessPublisher.h)
DtReflectedEnvironmentProcess (reflectedEnvironmentProcess.h)
DtReflectedEnvironmentProcessList (reflectedEnvironmentProcessList.h)
DtEnvironmentProcessRepository (environmentProcessRepository.h).
The DtEnvironmentProcessPdu setEnvironmentType() and environmentType() member functions expect and return a DtEnvironmentTypeRecord instead of a DtEntityType.

4.8.1 Managing Emitters
Emitters are a bit of a special case, particularly since the RPR FOM implements emitter systems and their constituent emitter beams using two different FOM object classes. We have tried to hide this FOM detail as much as possible, so that we can work with FOMs that do not break things up this way, and with DIS.

VR-Link uses the classes DtEmitterBeamPublisher, DtReflectedEmitterBeamList, and DtReflectedEmitterBeam to manage individual emitter beam objects, but application code normally should not use these classes directly. Instances of these classes are used by the corresponding emitter system classes to manage a system's component beams, and you can get or provide information about a system's beams through the classes that manage emitter system information.

The state of an emitter beam is represented with a DtEmitterBeamRepository (emitterBeamSR.h), a class that you will need to use. A DtEmitterSystemRepository consists of some system wide state, then a list of instances of DtEmitterBeamRepository – one for each constituent beam.

When publishing an emitter system, create the DtEmitterSystemPublisher, obtain a pointer to its DtEmitterSystemRepository using its emitterSystemRep() or esr() member. Then add beams using DtEmitterSystemRepository's addBeam() function. A DtEmitterBeamRepository to be used to set the state of the new beam is returned by addBeam(). After adding a beam to a system repository, make sure to set the beam's parent system ID to your system's ID using DtEmitterBeamRepository's setEmitterSystemId().

You must set a beam's type before you call tick() on the emitter system. Do not change the type of this beam after you set it.

You can remove beams using DtEmitterSystemRepository's removeBeam() function. The list of all beam's repositories is available through DtEmitterSystemRepository's beamList() member. For example:

// Create the system publisher
DtEmitterSystemPublisher sysPub(&conn);
// Get a pointer to its system state repository
DtEmitterSystemRepository* esr = sysPub.esr();
// Add a beam, and keep a pointer to its beam repository
// Give the beam a beam ID of 10.
DtEmitterBeamRepository* bsr = esr->addBeam(10);
// Set the beam's parent system ID
bsr->setEmittingSystemId(sysPub.globalId());
while (...)
{
   // Each frame, you can set various attributes of the system's
   // state using esr, and of the beam's state using bsr. 
   ...
   // Then just tick the system publisher. This will cause any
   // necessary system and beam data to be sent.
   sysPub.tick();
   ...
}
On the receiving side, you can create an instance of DtReflectedEmitterSystemList, and iterate through or look up systems, just as you can with any other type of reflected object list.

When you inspect a DtEmitterSystemRepository, it contains a list of DtEmitterBeamRepositories for the system's beams, available through beamList(). Because beams are separate objects in the RPR FOM, beams can come and go while the system exists in HLA. If you have saved a pointer to a DtEmitterBeamRepository, you can make sure that beam is still valid by looking it up in the system's list using DtEmitterBeamRepository::isMember().

Here is an example of looking up a DtEmitterBeamRepository:

DtReflectedEmitterSystemList sysList(&conn);
while (...)
{
   ...
   // Get a pointer to the first system in the list.
   DtReflectedEmitterSystem* sys = sysList.first();
   // Get a pointer to the system's state repository.
   DtEmitterSystemRepository* esr = sys->esr();
   // Get a pointer to the system's first beam's state repository
   DtEmitterBeamRepository* bsr = 
      (DtEmitterBeamRepository*) esr->beamList()->first()->data();
   // Now you can use esr and bsr to inspect the state of the system
   // and its first beam. 
}
If VR-Link obtains HLA updates for a beam without having first discovered its parent system, DtReflectedEmitterSystemList creates a phantom system with the object name indicated by the beam's emittingSystemId attribute, and adds a beam state repository representing the beam to that phantom system's repository. If we later discover the system object, its updates are decoded directly into the existing system repository.

4.9 - Coordinate Views
Table of Contents
4.9.1 Topographic Coordinate Views
4.9.2 UTM Coordinate Views
4.9.3 Cartesian Coordinate Views
DtEntityStateRepository's mutators and inspectors send position and orientation and their derivatives in geocentric coordinates and expect to receive data in geocentric coordinates.

If you want to use a different coordinate system in your application, you can use VR-Link's explicit coordinate conversion routines to convert outgoing data to a geocentric form before setting values in an entity publisher's DtEntityStateRepository, and to convert incoming data obtained from a reflected entity's DtEntityStateRepository from geocentric to the coordinate system of choice. However, there is an easier way.

VR-Link provides several "view" classes that you can create on a DtEntityStateRepository. These views provide access to the data in coordinate systems other than geocentric. After creating the appropriate view, simply use its mutators and inspectors, rather than directly calling the DtEntityStateRepository's functions. The view's functions call down to the DtEntityStateRepository's functions before or after doing the conversions, so that the DtEntityStateRepository always stores geocentric data.

VR-Link has three view classes:

DtUtmView (utmView.h) supports UTM coordinates.
DtCartesianView (cartesianView.h) supports any arbitrary Cartesian coordinate system.
DtTopoView (topoView.h) is derived from DtCartesianView and supports topographic coordinate systems. (Cartesian systems that have their X-Y plane tangent to the Earth's surface at their origin, with the X axis pointing north, the Y axis pointing east, and the Z axis pointing down.)
For more information about these coordinate systems, please see 13.3 - Coordinate Conversions.

The DtEntityStateRepository inspector and mutator functions that you can circumvent using views are:

location()
setLocation()
velocity()
setVelocity()
acceleration()
setAcceleration()
orientation()
setOrientation()
bodyToGeoc()
rotationalVelocity()
setRotationalVelocity().
However, since rotationalVelocity() is always specified in body rather than geocentric coordinates, the views' rotationalVelocity() and setRotationalVelocity() functions pass the DtEntityStateRepository values through without any conversion.

4.9.1 Topographic Coordinate Views
The DtTopoView constructor takes a pointer to the DtEntityStateRepository that you will be accessing, and a latitude and longitude (in radians) that define the particular topographic coordinate system you want to work in, for example:

DtEntityPublisher entPub(...);
DtEntityStateRepository* esr = entPub.entityStateRep();
DtTopoView topoView(esr, DtDeg2Rad(36.0), DtDeg2Rad(-121.0));
The following example uses DtTopoView's mutators to set positions and orientations specified with respect to a topographic coordinate system whose origin is at latitude/longitude {36.0, -121.0}.

Note
Topographic Euler angles correspond to heading, pitch and roll.
// Topographic coordinates
topoView.setLocation(DtVector(100.0, 100.0, 0.0));
topoView.setVelocity(DtVector(10.0, 10.0, 0.0));
topoView.setAcceleration(DtVector(1.0, 1.0, 0.0));
// Topographic Euler angles - heading, pitch and roll
topoView.setOrientation(DtTaitBryan(0.0, DtDeg2Rad(10.0), 0.0); 
// Rotational velocity is always in body coordinates
topoView.setRotationalVelocity(DtVector(0.0, 0.10, -0.125);
The following example uses a DtTopoView to inspect a remote entity's data in topographic coordinates:

DtReflectedEntityList rel(...);
...
DtReflectedEntity* ent = rel.first();
DtEntityStateRepository* esr = ent->entityStateRep();
DtTopoView topoView(esr, DtDeg2Rad(36.0), DtDeg2Rad(-121.0));
The final examples uses DtTopoView's inspectors to get positions and orientations specified with respect to the topographic coordinate system.

// Topographic coordinates
DtVector topoLoc = topoView.location();
DtVector topoVel = topoView.velocity();
DtVector topoAccel = topoView.acceleration();
// Topographic Euler angles - heading, pitch and roll
DtTaitBryan topoOrient = topoView.orientation();
// Or choose a matrix representation of orientation
DtDcm bodyToLocal = topoView.bodyToLocal(); 
// Rotational velocity is always in body coordinates
DtVector angVel = topoView.rotationalVelocity();
4.9.2 UTM Coordinate Views
DtUtmView is a view that lets you work in UTM coordinates. Its constructor takes only a DtEntityStateRepository, but relies on the fact that you have already initialized VR-Link's UTM coordinate system using DtUtmInit. (For more information, please see 13.3 - Coordinate Conversions.) Once you have chosen a particular UTM coordinate system in this way, you can use the inspectors and mutators like you do with DtTopoView.

Locations and their derivatives are in UTM coordinates, and are expressed as DtUtmCoords (defined in utmCoord.h). UTM orientations are treated in the same way as topographic orientations. The three Euler angles represent heading, pitch, and roll, while bodyToLocal() returns a rotation matrix that can rotate a vector from the body frame to a topographic frame centered at the entity's current location. As always, rotational velocity is represented in body coordinates.

4.9.3 Cartesian Coordinate Views
DtCartesianView allows the creation of a view defined by any Cartesian coordinate system. Along with a DtEntityStateRepository, its constructor takes a DtVector, indicating the origin of the new system expressed in geocentric coordinates, and a DtDcm representing a rotation matrix that can rotate a vector from the geocentric frame to the frame we are defining.

Alternatively, you can use the constructor that takes only a DtEntityStateRepository, and initialize the view by passing the two parameters to the setOffset() and setRotation() member functions.

Since DtTopoView inherits its inspectors and mutators from DtCartesianView, the descriptions of these functions in "Topographic Coordinate Views," on page 5-58, applies here, except that Euler angles do not correspond to heading, pitch, and roll when expressed with respect to an arbitrary Cartesian system.

[<< Working with Other Types of Objects] [Home] [Top of Page] [Articulated Parts >>]

4.10 - Articulated Parts
Table of Contents
4.10.1 Inspecting Articulated Parts Data
4.10.1.1 The DtArticulatedPart Class
4.10.2 Setting Articulated Parts Data
DIS and DIS-based FOMs like the RPR FOM define articulated parts as movable parts of an entity, such as a turret, gun, or landing gear.

The state of an entity's articulated parts is part of an entity's state, and is accessible through a DtEntityStateRepository.

A DtEntityStateRepository uses a DtArticulatedPartCollection (articulatedPartCollection.h), to store the articulated parts portion of its state. You can get a pointer to a DtEntityStateRepository's DtArticulatedPartCollection with its artPartList() member function.

4.10.1 Inspecting Articulated Parts Data
DtArticulatedPartCollection has many inspector functions for examining the state of an entity's articulated parts. The partCount() member function returns the number of articulated parts the entity has. For example, if a tank has a turret and a gun, partCount() returns 2. The totalParameterCount() member function returns the number of articulation parameters the entity is using to convey articulated parts information to the exercise. For example, if a tank is publishing information about its turret's azimuth and azimuth rate, and its gun's elevation, totalParameterCount() returns 3.

The DtArticulatedPartCollection has member functions (begin() and end()) that return the beginning and ending iterators of the collection, so that you can iterate through the articulated parts. Since the DtArticulatedPartCollection is an STL map, the iterator is a pair. first contains the part type of the articulated part; second contains a DtArticulatedPart pointer. To get a list of the parameters set for a DtArticulatedPart, call the getParameterMetrics() member function. To get the value of a particular parameter:

Call isParameterSet().
Call getParameterValue() on the articulated part.
If an articulated part parameter has a rate associated with it, and the rate has a value, the value returned is dead-reckoned to the current value of VR-Link simulation time. To retrieve the non dead-reckoned value, use the getParameter() member function. Pass in a reference to a DtArticulatedPart::Parameter structure, from which the value can be retrieved.

For example, do the following to inspect the value of the turret azimuth of an entity:

DtReflectedEntityList rel(...);
....
DtReflectedEntity* firstEnt = rel.first();
DtEntityStateRepository* esr = firstEnt->entityStateRep();
DtArticulatedPartCollection* artParts = esr->artPartList();
DtArticulatedPart* turret = artParts->findPart(DtPrimaryTurret1);
float turAz = 0.0;
if (turret)
{
   if (turret->isParameterSet(DtApAzimuth))
   {
      turAz = turret->getParameterValue(DtApAzimuth);
   }
   else
   {
      printf("Entity has no turret azimuth.\n");
   }
else
{
   printf("Entity has no turret.\n");
}
To get more detailed information about articulated parts, including getting non-dead-reckoned values, you must look at the individual DtArticulatedPart objects that a DtArticulatedPartCollection uses to represent individual parts.

4.10.1.1 The DtArticulatedPart Class
You can get a pointer to a particular DtArticulatedPart (articulatedPart.h) by part type, with the DtArticulatedPartCollection findPart() member function. You can get a reference to the DtArticulatedPart with the getPart() member function. The findPart() function returns NULL if there is no part identified by the given part type. getPart() creates a new part with that type if there is no part of that type.

You can iterate through the DtArticulatedPartCollection as follows:

DtArticulatedPartCollection* parts = ...;
for (DtArticulatedPartCollection::iterator artPartIter = parts->begin();
   artPartIter != parts->end();
   ++artPartIter)
{
   int currentPartType = artPartIter->first;
   DtArticulatedPart* currentPart = artPartIter->second;
}
You can also get a DtArticulatedPart's part type with the partType() member function. The partTypeAttachedTo() member function returns the type of the part to which the current part is attached. For example, a gun is often attached to a turret, whereas a turret is usually attached to the base entity (indicated by a return value of -1).

The number of parameters used for this part is found using parameterCount(), while getParameterMetrics() is used to fill a vector that you can use to iterate through the set of parameters, as follows:

DtArticulatedPart* part = ...;
std::vector<DtArticulatedPart::ParameterMetric> parameterMetrics;
part->getParameterMetrics(parameterMetrics);
std::vector<DtArticulatedPart::ParameterMetric>::const_iterator 
paramIter = parameterMetrics.begin();
std::vector<DtArticulatedPart::ParameterMetric>::const_iterator 
paramEnd = parameterMetrics.end();
for(;paramIter != paramEnd; ++paramIter)
{
   int metric = *paramIter;
   float value = part->getParameterValue(metric);
}
DtArticulatedPart::getVal() lets you inspect the value of a parameter by parameter type, returning the value, and returning 0.0 if the parameter is not valid for the part.

If you want to get the state of the part as a whole, instead of inspecting individual parameters, then use the functions translations() and angles(). You can get the part's state expressed as a vector of X, Y, and Z translations, or as a set of three angles representing azimuth, elevation, and rotation.

Both DtArticulatedPart and DtArticulatedPartCollection have printDataToStream() functions that print their data in human readable form.

4.10.2 Setting Articulated Parts Data
An articulated parts collection is empty when it is first created. To create articulated or attached parts, call the getPart() member function on the collection.

This creates a part of the specified type and returns it to the caller. To attach the part to another, call attachPart() on the collection, and pass in a pointer to the child part and a pointer to the parent part. By default, parts are attached to the base, for example:

DtArticulatedPartCollection* artPartCollection = myESR->artPartList();
DtArticulatedPart& turret = artPartCollection->getPart(DtPrimaryTurret1);
DtArticulatedPart& gun = artPartCollection->getPart(DtPrimaryGun1);
artPartCollection->attachPart(&gun, &turret);
This creates two parts: the turret and the gun, and attaches the gun to the turret.

When an articulated part is created, it has no parameters, and nothing will be sent in a network update if none have been set. To specify a parameter value, call setParameter() on the DtArticulatedPart (which could be retrieved by getPart()).

Note
getPart() returns the part if it exists. It creates a part if it does not exist.
The values for azimuth and azimuth rate are set for the turret, and the elevation is set for the gun as follows:

artPartCollection->getPart(DtPrimaryTurret1).setParameter(DtApAzimuth, DtDeg2Rad(myTurretAz));
artPartCollection->getPart(DtPrimaryTurret1).setParameter(
DtApAzimuthRate, DtDeg2Rad(myTurretAzRate));
artPartCollection->getPart(DtPrimaryGun1).setParameter(DtApElevation, DtDeg2Rad(myGunElev));


4.11 - Attached Parts
An attached part is an entity that is attached to another entity.

For example, a missile could be attached to a launcher. DtEntityStateRepository::attPartList() returns a pointer to a protocol-independent DtAttachedPartCollection (defined in attachedPartCollection.h). DtAttachedPartCollection works similarly to DtArticulatedPartCollection. You can use DtAttachedPartCollection's inspectors to find out the current state of a reflected entity's attached parts. You can use its mutators to set the state of a locally simulated entity's attached parts.

For example:

// Create the publisher, and get its ESR's attached parts list
DtEntityPublisher pub(...);
DtEntityStateRepository* esr = pub.esr();
DtAttachedPartListDtAttachedPartCollection* attList = esr->attPartList();
// Add a single attached part, a sidewinder missile attached to
// station number 15. (Station numbers are model-specific.)
DtAttachedPart& newPart = attList->getPart(15);
newPart->setEntityType(DtEntityType(2, 1, 225, 1, 1, 0, 0));

4.12 - Using Independent VR-Link Objects in Multiple Threads
You can use independent VR-Link objects in multiple threads.

If you are using VR-Link in multi-threaded applications, note the following:

Static variables that are used for initialization should be treated with care if their values might be modified concurrently by multiple threads.
License management communication with the license server can become confused if two objects try to check out licenses at the same time. This results in the following error:

Server message checksum failure (-60,147)

To avoid this problem, stagger the creation of the conflicting objects by calling DtSleep().

You are no longer restricted to using only one map datum or UTM reference point at a time. Using the global functions DtSetMapDatum(), DtCurrentMapDatum(), and DtUtmInit() should not result in any conflicts even when multiple threads are sharing the same reference ellipse and reference point. However, when multiple reference data need to be used simultaneously, an object representing the reference ellipsoid or UTM reference point can be passed to the coordinate's constructor. The given object will then be used for any coordinate conversions instead of the defaults.

Two classes make this change possible. The first, DtReferenceEllipsoid (referenceEllipsoid.h), represents the shape of the Earth. It is initialized using a DtMapDatum instance (mapDatum.h). The second class, DtUtmReferencePoint (utmReferencePoint.h), is used to represent a UTM reference point. It is initialized using a latitude, longitude, boolean value for enabling the use of standard offsets, and a DtMapDatum for the shape of the Earth.

For example:

DtDegMinSec latRef = {35.0, 0.0, 0.0, DtNorth};
DtDegMinSec lonRef = {122.0, 0.0, 0.0, DtWest};
DtUseMapDatum(DtWGS84);
DtUtmInit(latRef, lonRef, 1);  // this will use the global map datum
DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0);
DtUtmCoord utm(geod);   
is equivalent to the following code segment:

DtReferenceEllipsoid ellipse(DtWGS84);
DtUtmReferencePoint refUtm(latRef, lonRef, 1, 0, DtWGS84);
DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0, &ellipse);
DtUtmCoord utm(geod, &refUtm); 

4.13 - Controlling MAK Products Remotely
MAK Data Logger, VR-Vantage, and VR-Forces have remote control APIs that allow you to control them from other applications.

VR-Link has two libraries, loggerControlToolkit and stealthControlToolkit, that allow you to control the MAK Data Logger and MAK Stealth (6.2 and earlier). (The Stealth Control Toolkit also provides limited remote control of VR-Vantage applications.) These libraries are provided for backward compatibility. MAK Stealth is no longer a supported product and this library should be considered obsolete.

The preferred method for controlling the Logger, VR-Vantage, or VR-Forces is to link against the libraries provided with the version of the application that you want to control.

5 - The HLA-Specific Interface
These pages describe VR-Link's HLA-specific parameters and features:

5.1 - Introduction to the HLA-Specific Interface
5.2 - Interacting Directly with the RTI
5.3 - Getting Information About the FOM
5.4 - Publishing and Subscribing to FOM Classes and Attributes
5.5 - Managing HLA Objects
5.6 - Ownership Management
5.7 - Using DDM
5.8 - Using the DtInteraction Class
5.9 - Using Generic Attributes and Parameters
5.10 - General HLA Issues
5.11 - Interoperability Between HLA 1.3 and IEEE 1516 Federates
5.12 - FOM Agility

5.1 - Introduction to the HLA-Specific Interface
Most VR-Link users will find that the protocol-independent interface meets all of their needs.

However, if you are developing only for HLA, you may want to work with the HLA-specific classes, rather than generic classes. This chapter describes the HLA-specific interface. 6 - FOM Agility and 7 - The VR-Link Code Generator go into greater detail in explaining how to use VR-Link with FOMs other than the RPR FOM.

Note
If your application is intended for both DIS and HLA, or if you plan to add this support in the future, enclose your HLA-specific code within a preprocessor directive pair to ensure that it will not be compiled when you try to build for DIS:
#if DtHLA
   #if DtHLA_1516
      #if DtHLA_1516_EVOLVED
         // 1516 evolved specific.
      #else
         // 1516 specific
      #endif
   #else
      // 1.3 specific
   #endif
#endif 

5.2 - Interacting Directly with the RTI
Table of Contents
5.2.1 Building Applications for Use with the RTI 1516 Specification
5.2.2 Federate-Initiated Services
5.2.3 RTI-Initiated Services
5.2.3.1 Subclassing DtVrlFederateAmbassador
5.2.3.2 Telling DtExerciseConn About Your Derived Class
Although most applications based on VR-Link will never need to access the RTI directly (VR-Link functions make the RTI calls for you), some applications will want the flexibility of making their own calls to the RTI.

Often, you will want to mix and match, letting VR-Link handle most interaction with the RTI, while handling some of it directly within the same application.

The RTI's API contains two main classes: the RTIambassador and the FederateAmbassador. When a DtExerciseConn is constructed, it creates instances of both of these classes.

5.2.1 Building Applications for Use with the RTI 1516 Specification
We have tried to maintain source compatibility between the 1.3 and 1516 versions of VR-Link. Most types in the 1516 RTI API have the same name as in the 1.3 RTI API. The exceptions are as follows:

In pre-1516 versions of VR-Link, RTI classes were prefaced with RTI::. This convention effectively created an RTI namespace. The new RTI 1516 API has a true namespace called rti1516. The HLA Evolved API has a true namespace called rti1516e. In rtiCompatibility.h we rename both namespaces to RTI to provide backwards compatibility. This was intended by the RTI API standards committee.
The RTI 1516 API eliminated the AttributeHandleValuePairSet class. It was replaced by a std::map<AttributeHandle, VariableLengthData> type. To preserve source compatibility with VR-Link encoders and decoders that were written to use the AttributeHandleValuePairSet, we added a wrapper class, called AttributeHandle- ValuePairSet, which is passed to all encoders and decoders. This preserves source compatibility. The definition of this class is in the file rtiCompatibility.h.
The 1516 RTI uses std::wstring (wide strings) instead of char* or std::string (narrow strings). VR-Link uses narrow strings and converts the narrow strings to wide strings for RTI calls. If you mix VR-Link and RTI calls, you must take this difference into account.
5.2.2 Federate-Initiated Services
Federate-initiated services, such as publishObjectClass(), updateAttributeValues(), and sendInteraction(), are invoked by making calls to the RTI ambassador's member functions.

A DtExerciseConn's RTI ambassador is available through the rtiAmb() member function. Use this object to invoke any federate-initiated RTI services. The object returned by rtiAmb() is an instance of the class DtVrlRtiAmbassador, which serves as a wrapper around RTI::RTIambassador. (DtVrlRtiAmbassador has the same member functions as RTI::RTIambassador, but the functions are declared virtual, so that they can be overwritten by application code.)

For example, to call the RTI's queryAttributeTransportationType() service:

DtExerciseConn exConn(...);
...
DtVrlRtiAmbassador* rtiAmb = exConn.rtiAmb();
rtiAmb.queryAttributeTransportationType(...);
5.2.3 RTI-Initiated Services
RTI-initiated services, such as discoverObject(), reflectAttributeValues(), and receiveInteraction(), are invoked when the RTI calls virtual member functions of RTI::FederateAmbassador() from within RTI::RTIambassador::tick(). Federates are responsible for deriving a class from RTI::FederateAmbassador and providing definitions for these pure virtual functions.

Normally, this responsibility is satisfied through VR-Link's DtVrlFederateAmbassador class (defined in vrlFederateAmbassador.h). This class is derived from RTI::FederateAmbassador, and includes definitions for all virtual functions (though some are empty definitions).

5.2.3.1 Subclassing DtVrlFederateAmbassador
For direct access to the data the RTI provides through RTI-initiated services, you can derive your own class from DtVrlFederateAmbassador and implement new definitions for the virtual functions in your subclass. In general, you should call the DtVrlFederateAmbassador versions of these functions from your versions, to insure that any VR-Link functionality that may depend on this continues to work.

The following example shows a subclass of DtVrlFederateAmbassador that uses the RTI-initiated service initiatePause. The implementation of DtVrlFederateAmbassador's initiatePause() member function is empty. VR-Link does not take any action by default when this service is invoked by the RTI. If you want your application to be able to handle this service invocation, you can provide your own definition for the initiatePause() virtual function.

This example is for HLA 1.3.

class MyFedAmb : public DtVrlFederateAmbassador
{
public:
   virtual void initiatePause(const RTI::PauseLabel label)
      throw (RTI::FederateAlreadyPaused, RTI::FederateInternalError);
};
void MyFedAmb::initiatePause(const RTI::PauseLabel label)
      throw (RTI::FederateAlreadyPaused, RTI::FederateInternalError)
{
   // Your code to handle the pause
   ...
   // Call superclass version in case it's 
   // doing anything important
   DtVrlFederateAmbassador::initiatePause(label);
}
5.2.3.2 Telling DtExerciseConn About Your Derived Class
After you create a subclass of DtVrlFederateAmbassador, you need to tell DtExerciseConn that it should use an instance of your class rather than the default DtVrlFederateAmbassador as its federate ambassador. To tell DtExerciseConn about your subclass, use the static member function DtExerciseConn::setFedAmbCreator(). This function expects a DtFedAmbCreator() function as an argument – a function that returns a new instance of a DtVrlFederateAmbassador or a subclass of it. The current DtFedAmbCreator() is called in the DtExerciseConn constructor, so you need to call setFedAmbCreator() before the DtExerciseConn is constructed.

A FedAmbCreator() function for the MyFedAmb class might look like this:

DtVrlFederateAmbassador* MyFedAmbCreator()
{
   return new MyFedAmb();
}
Tell the DtExerciseConn class about this function before creating a DtExerciseConn instance as follows:

DtExerciseConn::setFedAmbCreator(MyFedAmbCreator);
...
// The DtExerciseConn we create here will use a MyFedAmb as
// its federate ambassador
DtExerciseConn exConn(...);
A DtExerciseConn's DtVrlFederateAmbassador is available through its fedAmb() member function.

5.3 - Getting Information About the FOM
When an HLA DtExerciseConn is constructed, VR-Link reads the appropriate FED file and builds a database of information about the FOM that the application code can query.

This FOM information is stored in a DtFom (defined in fom.h). You can obtain a pointer to a DtExerciseConn's DtFom using the member function fom().

A DtFom contains a list of object class and interaction class descriptors. These descriptors are represented by the VR-Link classes DtObjClassDesc (defined in objClassDesc.h) and DtInterClassDesc (defined in interClassDesc.h) respectively. Class descriptors contain information about FOM classes, including:

Class handle and name
A pointer to the base class's descriptor (if any)
The set of valid attributes or parameters
Whether the class has been published or subscribed
The attributes of an object class that have been published or subscribed
Whether the class and its various attributes are needed by other federates.
The class descriptors also allow you to subscribe and publish, if you want to override the default way these are handled.

DtFom's member functions interClassByName(), interClassByHandle(), objClassByName() and objClassByHandle() allow you to obtain the class descriptor for a particular class. Alternatively, you can iterate through all of the classes in a FOM, using DtFom's firstObjClass() and nextObjClass(), or firstInterClass() and nextInterClass() member functions, for example:

// Print out the names of all object classes in the current FOM.
DtExerciseConn conn(...);
...
DtFom* fom = conn.fom();
for (DtObjClassDesc* desc = fom->firstObjClass(); desc; 
desc = fom->nextObjClass(desc))

{
   std::cout << "ClassName: " << desc->name() << std::endl;
}
The following example shows how to get a class descriptor in RTI 1516. It uses a list provided by the DtFom member functions objClassList() and interClassList(), which return a DtList of object classes to iterate through.

...
// Print out the names of all object classes in the current FOM.
DtExerciseConn conn(...);
DtFom *fom = con.fom();
#if DtHLA_1516
   DtListItem *item;
   for(item = objClassList()->first();
      item;
      item= item->next();
   {
      DtObjectClassDesc *objDesc =
         static_cast<DtObjClassDesc *>item->data();
#else
   for (DtObjClassDesc *objDesc = fom->firstObjClass()
      objDesc;
      objDesc = fom->nextObjClass(objDesc))
   {
#endif
      // Now code is independent
      std::cout << "ClassName: " << objDesc->name() << std::endl;
      ... 
DtFom has a print() member function that is similar to the example, but it prints out more information, such as attribute and parameter names and handles.

5.4 - Publishing and Subscribing to FOM Classes and Attributes
Table of Contents
5.4.1 Publishing Classes and Attributes
5.4.1.1 Publishing Interactions
5.4.2 Subscribing to Classes and Attributes
5.4.2.1 Subscribing to Interaction Classes
Before they send any data, HLA federates must tell the RTI the set of FOM classes and the set of attributes of object classes for which it is capable of sending data.

The HLA specification refers to this initialization activity as "publishing" a class, or "publishing" a class with a set of attributes. (Though some people refer to the act of sending interactions or sending attribute value updates as publishing, that is not the meaning of the word as defined by the RTI or HLA specification.)

Similarly, an HLA federate must indicate to the RTI the set of FOM classes and the set of attributes of object classes for which it is interested in receiving data from other federates. This initialization activity is called "subscribing".

Most VR-Link applications do not need to do anything special to fulfill the publishing and subscribing requirement; VR-Link takes care of this for you. However, if you want to alter the set of classes or attributes that get subscribed to or published, you can do so through VR-Link.

5.4.1 Publishing Classes and Attributes
When you create an instance of a particular kind of object publisher (for example, a DtEntityPublisher), VR-Link determines which object class from the FOM should be used to represent the object (typically by either using the class handle passed to the publisher's constructor, or by asking the FOM Mapper). Before registering the new HLA object with the RTI, we publish the object class if the federate has not already published the class or explicitly unpublished it. By default, the class's full set of valid attributes is published.

To publish only a subset of an object class's attributes, you must explicitly publish the object class, along with the desired attribute set, before creating the object publisher. This is done using DtObjClassDesc::publish(). When the object publisher is constructed, it sees that the class has already been published, and does not perform the default publication.

Note
Do not publish by directly using RTI services. The RTI API does not provide a way to find out which classes and attributes you have published. So if you publish directly through the RTI API, VR-Link cannot know that you have done so, and will perform the default publish with all attributes included.
For example, to publish only the EntityType and Position attributes of the GroundVehicle class:

#include <vlutil/vlStringUtil.h> // For DtToWString
DtExerciseConn  exConn(...);
...
#if DtHLA
   DtObjClassDesc *desc = exConn.fom()->objClassByName(
      "BaseEntity.PhysicalEntity.Platform.GroundVehicle");
   assert(desc);
   RTI::ObjectClassHandle classHand = desc->handle();
#if DtHLA_1516
   // In 1516 AttributeHandleSets are of type
   // std::set<RTI::AttributeHandle>
   RTI::AttributeHandleSet hSet;
   // Note that the parameters to getAttributeHandle have been reversed
   // in 1516. Also note that strings passed to the RTI are of type
   // std::wstring.
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(
      classHand, L"EntityType"));
   hSet.insert(exConn.rtiAmb()->getAttributeHandle(
      classHand, DtToWString("Position")));
   desc->publish(hSet);
#else
   RTI::AttributeHandleSet *hSet =
      RTI::AttributeHandleSetFactory::create(2);
   hSet->add(exConn.rtiAmb()->getAttributeHandle(
      "EntityType", classHand));
   desc->publish(*hSet);
   delete hSet;
#endif
#endif
Attribute publications apply only to the class that you specify, not to subclasses or superclasses. So you will need to call publish() on multiple class descriptors to change the set of attributes published for a whole portion of a class hierarchy.

5.4.1.1 Publishing Interactions
Publishing interactions works a little differently from publishing objects. You cannot publish only a subset of the parameters of an interaction. You either publish an interaction class with all of its parameters, or not at all. When you send an interaction of a particular class using DtExerciseConn::send() or DtExerciseConn::sendStamped(), VR-Link publishes the interaction class if it is not currently published by the federate.

5.4.2 Subscribing to Classes and Attributes
Usually, a reflected object list's constructor subscribes to object classes. A particular kind of reflected object list (for example, a DtReflectedEntityList) determines which FOM classes it is interested in, typically by either using the class handles passed to the constructor, or by asking the FOM Mapper. Then, it subscribes to each of those classes to which the federate is not already subscribed.

Most reflected object lists in VR-Link take an optional handleList argument, which lets you specify exactly which FOM classes should be subscribed to (and managed by the reflected object list). If this argument to the DtReflectedEntityList constructor is omitted, it gets the set of classes to subscribe to from the FOM Mapper. (The default FOM Mapper says that BaseEntity and all of its subclasses except AggregateEntity should be managed by DtReflectedEntityList.)

HLA 1.3: The handleList is a DtList of RTI::ObjectClassHandles, cast to void*. HLA 1516: The handleList is a list of pointers to valid RTI::ObjectClassHandles.

The following example demonstrates the procedure for telling a DtReflectedEntityList to subscribe to and manage only the GroundVehicle and Munition FOM classes:

...
#if DtHLA
   DtList handleList;
#if DtHLA_1516
   std::wstring hName(
      L"BaseEntity.PhysicalEntity.Platform.GroundVehicle");
   handleList.add(new RTI::ObjectClassHandle(
      exConn.rtiAmb()->getObjectClassHandle(hName)));
#else
   // DtList holds pointers. Since we know that Handles in HLA 1.3
   // are just integer values, we store them as pointer values.
   // This doesnt work in 1516.
   handleList.add((void *) exConn.rtiAmb()->getObjectClassHandle(
      "BaseEntity.PhysicalEntity.Platform.GroundVehicle"));
   handleList.add((void *) exConn.rtiAmb()->getObjectClassHandle(
      "BaseEntity.PhysicalEntity.Platform.Munition"));
#endif
   // Create the Reflected Entity List
   DtReflectedEntityList(&exConn, &handleList);
   ...
#if DtHLA_1516
   // we are done with the handles we created, let's clean them up
   for (DtListItem *item = handleList.first(); item;)
   {
      DtListItem* next = item->next();
      RTI::ObjectClassHandle *hand =
         static_cast<RTI::ObjectClassHandle *>(item->data());
      handleList.remove(item);
      delete hand;
      item = next;
   }
#endif 
By default, when VR-Link subscribes to an object class, it subscribes to all attributes of the class. If you want to subscribe to only a subset of an object class's attributes, the procedure is the same as that for publishing a subset of an object class's attributes, except that you use the DtObjClassDesc::subscribe() function, instead of publish(). For more information, please see 5.4.1 Publishing Classes and Attributes.

Note
Do not subscribe by directly using RTI services. The RTI API does not provide a way to find out which classes and attributes you have subscribed to. If you subscribe directly through the RTI API, VR-Link will not know that you have done so, and will perform the default subscribe with all attributes included.
5.4.2.1 Subscribing to Interaction Classes
Subscription to interaction classes normally takes place when you register a callback function with a VR-Link interaction class. That action tells VR-Link that you are interested in a certain set of interaction classes, and VR-Link passes that information on to the RTI. Just as with publication, the RTI API does not let you subscribe to a subset of an interaction's parameters.

5.5 - Managing HLA Objects
Table of Contents
5.5.1 Finding Out when HLA Objects are Discovered and Removed
5.5.2 Intercepting Reflected Attribute Values
5.5.3 Forcing Attribute Updates
5.5.4 Reflecting Locally-Generated Updates
VR-Link uses instances of the DtHlaObject class (defined in hlaObject.h) to represent both local and reflected HLA objects.

Because most entity management functionality is available through VR-Link's protocol-independent layer, most applications do not need to interact with DtHlaObjects (or even know they exist). However, there are always DtHlaObjects behind the scenes.

On the outgoing side, a DtObjectPublisher creates and uses a DtHlaObject to help with the sending of attribute updates. On the incoming side, VR-Link creates a DtHlaObject instance for each object that we discover through the RTI. If the object is to be managed by a DtReflectedObject, then that DtReflectedObject stores a pointer to its DtHlaObject, and uses it to help manage the receipt of incoming attribute updates.

Both DtReflectedObject and DtObjectPublisher have an hlaObject() member function that returns a pointer to the DtHlaObjectWithStateRep that it is managing.

VR-Link maintains a list of all reflected and locally simulated HLA objects, without regard to what kind of reflected object or object publisher is being used to manage the objects (if any). This list is accessible through the DtHlaObjectManager class (defined in hlaObjectManager.h). An instance of this class is created by DtExerciseConn, and is available through DtExerciseConn's hlaObjectManager() function.

The HLA object manager class has a function called allHlaObjects(), which returns a DtList of pointers to all current reflected or local DtHlaObjects. The list is automatically updated whenever a new object is discovered or removed by an RTI-initiated service invocation, or when you create a DtHlaObject to represent a locally simulated object (which happens when you create a DtObjectPublisher).

For example, to print the IDs of all objects currently being simulated:

#include <vl/rtiCompatibility.h>
DtExerciseConn exConn(...);
...
// Subscribe to various object classes, process discoverObjects and
// reflectAttributeValues calls. (This is usually achieved simply by
// creating a DtReflectedObjectList.)
...
DtHlaObjectManager* objMgr = exConn.hlaObjectManager();
const DtList& allObjects = objMgr->allHlaObjects();
for (DtListItem* item = allObjects.first(); item; 
   item = item->next())
{
   // Cast the generic void* to a DtHlaObject*
   DtHlaObject* obj = (DtHlaObject*) item->data();
   std::cout << "id: " << obj->objectId() << std::endl;
}
The HLA manager class also lets you look up HLA objects by ID or by name, using their hlaObject() member functions. These functions return NULL if no object with the given ID exists. It also gives you the list of all registered hlaObjects (those created by publishers and, hence, locally simulated) and the list of all discovered objects (remotely simulated) using the registerObjects() and discoveredObjects() functions. These functions return lists of pointers to DtHlaObjects.

In addition to the functions that give basic information about an HLA object (objectId(), name(), classDesc()), DtHlaObject has member functions that allow you to obtain more specialized information. The following table describes these functions:

Additional DtHlaObject Member Functions
Function	Description
attributesNeededByFederation()	Returns the set of attributes of this object that have been subscribed to by remote federates, as told to us by the RTI.
classNeededByFederation()	Tells you whether the class has been subscribed to at all by remote federates.
requestedAttributes()	Returns the set of attributes for which updates have been requested by another federate through the RTI, since the time that we last sent updates for those attributes.
lastSimTimeUpdateReceived()	Returns the time that the last attribute update was received for this object, if it is a reflected object.
5.5.1 Finding Out when HLA Objects are Discovered and Removed
4.6.7 Learning when Entities Join or Leave an Exercise, describes protocol-independent methods of receiving notification about the discovery and removal of reflected objects. These methods involved either registering "objectAddition" and "objectRemoval" callbacks with a DtReflectedObjectList, or deriving from a subclass of DtReflectedObjectList and providing new definitions for the objectAdded() and removeAndDelete() virtual functions.

Although these are the preferred methods (due to protocol-independence, and ability to access the DtReflectedObject associated with an object), this section describes another method, which works at the level of DtHlaObject. By using this method, you can be notified when any HLA object joins or leaves, rather than just one particular kind of object (entities, for example).

When a new object is discovered, the DtExerciseConn creates a DtHlaObject to represent it, and adds it to the DtReflectedObjectManager's list of all reflected HLA objects. It is then passed to any "discoverObject" callback functions that have been registered with the DtExerciseConn for the object's class. You can register discoverObject callback functions for any object class using DtExerciseConn's addDiscoverObjectCallback() member function. Callbacks can be unregistered using removeDiscoverObjectCallback().

In RTI 1.3, if you want to be notified when any object is discovered regardless of class, use:

addDiscoverObjectCallback(RTI::ObjectClassHandle(0));
In RTI 1516, if you want to be notified when any object is discovered regardless of class, use:

addDiscoverObjectCallback(RTI::ObjectClassHandle());
Callback functions that you provide should match the signature defined in discoverObjectCbInfo.h, for example:

void myDiscoverObjectCb(DtHlaObject* obj, void* usr);
If you want to be notified when an object is removed, you can use DtHlaObject::addRemoveObjectCb() to register a removal callback directly with the DtHlaObject of interest. Such functions can be unregistered with removeRemoveObjectCb().

Alternatively, you can use DtExerciseConn's addRemoveObjectCallback() and removeRemoveObjectCallback(), in which case you need to pass an object ID to specify which object you are interested in.

In either case, your callback functions should match the signature defined in removeObjectCbInfo.h. For example:

void myRemoveObjectCb(DtHlaObject* obj, void* usr);
When the removeObject() service is invoked by the RTI, the corresponding DtHlaObject is:

Removed from VR-Link's internal list of reflected HLA objects.
Passed to any callback functions registered on the removal of the object.
Deleted.
For instance, these callback mechanisms are the mechanism by which DtReflectedObjectLists are notified of the arrival and removal of reflected objects. When the reflected object list's discoverObject() callback is invoked, it creates a new instance of the appropriate DtReflectedObject subclass to manage the object. When its removeObject() callback is invoked (reflected object lists register one for each object as it is discovered), the DtReflectedObject is removed from the list and deleted.

5.5.2 Intercepting Reflected Attribute Values
4.6.8 Notifying an Application when State Updates Arrive, describes a protocol-independent way of being notified when an attribute update arrives for a particular object. This was accomplished by registering a postUpdate() callback with a DtReflectedObject.

This section describes an alternate mechanism that works at the level of DtHlaObjects. This method is useful when there are some types of objects that are not managed by a DtReflectedObjectList, or when you want to be notified when an object is updated, regardless of what type of object it is.

In HLA, VR-Link routes attribute updates directly to the DtHlaObject whose attributes the update describes, which may process it however it desires. (Typically, the DtHlaObject decodes the message into its DtReflectedObject's DtStateRepository.) If you want to be notified when an update message has been processed by a DtHlaObject, you can register a callback function with the DtHlaObject using its addPostReflectCb() member function. Use removePostReflectCb() to unregister the callback.

These callback functions should look like the following, as specified in objectReflectAttributeValuesCbInfo.h:

void postReflectCb(const DtStateMsg& msg, DtHlaObject* obj, void* usr);
Your function is called immediately after the DtHlaObject has finished processing the message. Along with the DtHlaObject (and the usr pointer, of course), the message itself is passed to your function.

DtStateMsg (defined in stateMsgHLA.h) is basically a wrapper that contains the ID of an object whose state the message is updating, and the message itself. The information is presented as an RTI::AttributeHandleValuePairSet, the form in which it arrives from the RTI. These two components of a DtStateMsg are available through its objectId() and ahvps() functions respectively.

An example of intercepting reflected attribute values is the netdumpHLA application, which works as follows:

It registers a discoverObject() callback with the DtExerciseConn for all objects of all classes.
Within the discoverObject() callback, netdumpHLA registers a postReflect() callback with each DtHlaObject that is discovered.
Within the postReflect() callback, it prints the contents of the message.
netdumpHLA has versions for HLA 1.3, HLA 1516, and HLA Evolved. For details, please see the appropriate CXX file in ./examples/netdump.

5.5.3 Forcing Attribute Updates
When you call DtObjectPublisher::tick(), it calls down to its DtHlaObject's update() function, which decides which attributes need to be sent, and then sends them. The decision is based on the following factors:

Only those attributes that are both published by the local federate, and subscribed to by some remote federates are eligible to be sent
Of these eligible attributes, it only sends those whose update conditions have been met, plus any attributes for which updates have been explicitly requested by a remote federate (as indicated by the RTI through provideAttributeUpdate() service invocations).
If you want certain eligible attributes to be sent during the next call to a DtObjectPublisher's tick() function, even if their update conditions have not been met, and they have not been specifically requested by a remote federate, you must pass the desired set of attributes to the appropriate DtObjectPublisher's forceUpdate() member function. If you omit the attribute set argument to forceUpdate(), then an update for all eligible attributes is sent during the next call to tick().

5.5.4 Reflecting Locally-Generated Updates
In HLA, you generally do not get discovers from the RTI for objects you register locally, and you do not get reflects from the RTI for updates or interactions that you send locally. For this reason, objects that you simulate locally with DtObjectPublishers will normally not show up in your DtReflectedObjectLists.

VR-Link lets you turn on reflection of locally generated data by calling the DtExerciseConn::setReflecting() function. When "reflecting" is on, objects that you are publishing and updating appear in your reflected object lists. The publisher and reflected object do not share an instance of a state repository. Rather, the reflected object's view of the object is the same as a remote federate's view of the object. The reflected object decodes attribute updates that are generated by a local publisher, just as it decodes updates received from remote federates. Locally-generated interactions are also processed by VR-Link when reflecting is on, so that your interaction callbacks are invoked as they would be for interactions sent by remote federates. The current state of the reflecting flag is obtained using DtExerciseConn::reflecting(). However, once you turn reflecting on in a particular application, you cannot turn it off again.

If you are using ownership management, you should turn on the reflection option, because you may own some attributes of an object, while a remote federate owns other attributes of the same object. With reflecting on, the DtReflectedObject's state repository includes values for all of the attributes, regardless of whether they were sent locally or remotely. (For more information, please see 5.6 - Ownership Management.)

Assuming you have the reflecting option turned on, you can control whether or not you want remotely-generated attribute updates to be decoded into your publisher's state repository in addition to your reflected object's state repository. If this option is off (the default), only local application code can modify the publisher's state repository. If the option is on, then the state repository will contain values decoded from incoming attribute updates for attributes owned by remote federates, plus values you have set for attributes that you own.

Note
The publisher's state repository does not prohibit you from setting values for attributes you do not actually own. Because you do not own the attributes, your data is never sent, and it is overwritten by incoming data when an attribute update arrives from the federate that owns the attribute.

5.6 - Ownership Management
Table of Contents
5.6.1 Implementing Ownership Management
5.6.1.2 Example: Acquiring Objects
5.6.1.1 Example: Divesting Attributes
5.6.1.3 Example: Giving Up Attributes if Requested
5.6.1.4 Example: Acquiring Attributes if Offered
VR-Link supports HLA ownership management services, which allow you to transfer the responsibility for sending updates for particular object attributes from one federate to another.

Most ownership management functionality is accessed through the DtHlaObject class. Recall that both DtObjectPublishers and DtReflectedObjects have member functions called hlaObject() that return the DtHlaObject that is being published or reflected. DtHlaObject encapsulates the HLA details of an object.

One conceptual change necessitated by support for ownership management is that the line between a locally simulated object and a reflected object is blurred. It is possible to have both a DtObjectPublisher and a DtReflectedObject associated with the same HLA object. That is, they share a DtHlaObject.

The publisher is still responsible for sending out updates for owned attributes. If you want to own and update any attributes of a particular object, you must create a publisher for that object, even if you are not the federate that registers the object with the RTI. DtObjectPublisher and its subclasses have a constructor that allows you to create a publisher for an existing DtHlaObject.

The reflected object is still responsible for collecting attribute updates sent by the owners of the various attributes, and presenting the reflected view of the object's current state through its state repository. However, now there may not be a single federate sending all of the attribute updates for an object, and some of the updates may even be coming from the local federate.

When a publisher's destructor is called, VR-Link will, by default, delete the corresponding HLA object if and only if the local federate owns the privilegeToDelete attribute. (And of course, because the HLA object gets deleted, the corresponding DtReflectedObject will be deleted and removed from your reflected object lists.) You can use DtObjectPublisher's setDeleteObjInDtorFlag() to change this behavior so that VR-Link does not delete the HLA object even if the local application owns the privilegeToDelete attribute. Use deleteObjInDtorFlag() to check the current status of the flag.

Because you can have a publisher for an object for which you do not own the privilege to delete, it is possible for your publisher's underlying HLA object to be deleted by a remote federate. When this occurs, your publisher's DtHlaObject pointer is set to NULL, and subsequent ticks will effectively be no-ops. To be notified when a DtHlaObject is deleted so that you can delete the corresponding publisher (which is now useless), you can register a removeObject() callback with the DtHlaObject using its addRemoveObjectCb() function. Alternatively, you can register an objectRemoval() callback for the corresponding DtReflectedObject with your DtReflectedObjectList. For more information, please see 4.6.7 Learning when Entities Join or Leave an Exercise.

Note
If you are using ownership management, it is recommended that you call DtExerciseConn::set-Reflecting() to enable these things to happen. Failing to call setReflecting() means that a DtReflectedObject only processes attributes updates generated by remote federates, so that the reflected object may not contain the complete current state of the object. For more information, please see 5.5.4 Reflecting Locally-Generated Updates.
To maintain backward compatibility with federates that do not use ownership management, creating a publisher and updating attributes does NOT, by default, result in the creation of a corresponding reflected object in the reflected object list, and the reflection of locally generated attribute updates unless self reflecting is turned on. If self reflecting is not turned on, you must manually manage your publish and reflected lists when an object transfer occurs. This would involve moving objects between reflected and publisher lists whenever an object's ownership changes. The Ownership Handler example shows how this management is done.

DtHlaObject has the following member functions that wrap the RTI's federate-initiated ownership management services:

acquireObject()
divestObject()
unconditionalDivest()
negotiatedDivest()
acquireAttributes()
cancelNegotiatedDivest()
cancelAcquireAttributes().
In general, you should use VR-Link's ownership-related functions rather than calling the RTI's functions directly, to insure that VR-Link can keep its ownership information consistent with the RTI's.

The first two functions, acquireObject() and divestObject() provide the easiest most straightforward way to do ownership management. Calling one of these functions will immediately attempt to acquire or divest all the attributes of a specific object. If you do not need objects to have multiple simultaneous owners, it is recommended that you use those two functions. The remaining functions allow individual attributes to be transferred, as well as provide an HLA level of control over how ownership management will be done.

When using individual attribute ownership transfer, VR-Link keeps track of the locally-owned attributes of each object, and its publishers send attribute updates only for owned attributes. The current set of owned attributes for a particular DtHlaObject is obtained using its ownedAttributes() member function.

RTI-initiated ownership management services (the RTI-callbacks) are intercepted by VR-Link (again to keep VR-Link's ownership information current), and then passed along to application code through a class called DtOwnershipHandler (defined in ownershipHandler.h). (Remember, all RTI-initiated callbacks, including these ownership management calls, are called from within the RTI's tick function, which is called by DtExerciseConn::drainInput().)

The DtOwnershipHandler class allows you to receive ownership-related callbacks, such as notification that you have successfully acquired or divested ownership of a set of attributes, or a query to allow or disallow a requested ownership. We provide three different DtOwnershipHandler classes: DtDefaultOwnershipHandler, DtPartialOwnershipHandler, and DtRprOwnershipHandler. All three classes provide callbacks that notify your application when an acquisition or a divestiture occurs. These callbacks can be optionally defined by the type of object being transferred. They also contain functions allow you to accept, or deny all requests for ownership transfer. You may instead add a callback so you can decide to accept or deny conditionally at runtime.

The DtDefaultOwnershipHandler is built for simplicity and assumes that all ownership transfer is on an object level. If you need to transfer only some attributes, it is recommended that instead you use DtPartialOwnershipHandler which contains extra callbacks for that situation. The third class, DtRprOwnershipHandler, automatically sends acquire interactions when a transfer is successful or unsuccessful as defined by the RPR standard. Alternatively, you may write your own DtOwnershipHandler, but in most cases this is not necessary.

There are two ways to register your ownership handler. You may do so globally by calling setDefaultOwnershipHandler in your DtExerciseConn. If you do it that way, every object created or reflected after the call will be set with the ownership handler you defined. You can also register individual objects by using DtHlaObject's setOwnershipHandler() member function. By doing so, you are saying to VR-Link: "This is the object I want you to use to handle incoming ownership information for this particular HLA object."

5.6.1 Implementing Ownership Management
HLA allows a transfer of ownership to be initiated by either the potential acquirer or divestor. On the following pages, we describe a few examples that use the various mechanisms.

5.6.1.2 Example: Acquiring Objects
You discover an object, and want to acquire all of it's attributes:

Create the reflected object list as usual.
At some point after you have discovered the object in question, create a publisher for the object, passing the reflected object's DtHlaObject to the publisher's constructor. This publisher constructor will not try to register the object, since it already exists.
Call DtHlaObject::acquireObject().
If you want your application code to be notified when the acquisition succeeds (so that you know, for example, to start actually simulating the relevant parts of the object), you must create a DtOwnershipHandler and attach it to your object.

void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}
// Create the reflected entity list
DtReflectedEntityList rel(...);
...
// Find the entity you are interested in, and grab its DtHlaObject
DtReflectedEntity* ent = rel.lookup(...);
DtHlaObjectWithStateRep* obj = ent->hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the
// instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
// Create a publisher for the object
DtEntityPublisher pub(obj, obj->exerciseConn());
// Initiate the acquisition.
obj->acquireObject();
5.6.1.1 Example: Divesting Attributes
You register an object, and then want to give up some attributes:

Create the publisher as usual, which results in the registration of a new object with the RTI, and the creation of a DtHlaObject by VR-Link.
In order to initiate the divestiture of attributes, call either unconditionalDivest() or negotiatedDivest() on the publisher's DtHlaObject. With unconditionalDivest(), the attributes immediately become unowned, and remain unowned until someone acquires them. With negotiatedDivest(), the divesting federate retains ownership until another federate agrees to assume ownership of them. If you do not care about individual attributes and just want to divest the entire object, you should instead call divestObject()
If you want to be notified when another federate assumes ownership, you must create a DtOwnershipHandler and attach it to your object.

void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}
// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the
// instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
// Initiate the divest
// ******************** RTI 1.3 only *********************
// The rest of this example is for RTI 1.3 only
RTI::AttributeHandleSet* hSet =
   RTI::AttributeHandleSetFactory::create(3);
hSet->add(1);
hSet->add(2);
hSet->add(3);
obj->negotiatedDivest(*hSet);
delete hSet;
5.6.1.3 Example: Giving Up Attributes if Requested
You do not want to initiate a divestiture, but you want to give up attributes of an object if another federate requests them:

Create the publisher as usual.
Create a DtOwnershipHandler for your publisher that accepts all divestitude actions

void lostOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Lost Ownership!" << std::endl;
  // Do Something
}
// Create the publisher, and grab its DtHlaObject
DtEntityPublisher pub(classHandle, conn);
DtHlaObjectWithStateRep* obj = pub.hlaObject();
// Instantiate your handler class, and tell the DtHlaObject to use the
// instance.
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipDivestitudeAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setDivestOwnershipCallback(&lostOwnership, 0));
obj->setOwnershipHandler(&defaultHandler);
5.6.1.4 Example: Acquiring Attributes if Offered
You do not want to initiate an acquisition, but you want to acquire attributes of an object if another federate initiates a divest:

Create a default ownership handler and assign it to your exercise connection. All objects, reflected or published will now use this handler
Set the default acquisition action of this handler to always accept all acquisitions
Add a callback informing you when an aquisition is successful
Create the reflected object list as usual.

void gainedOwnership(DtHlaObject* hlaObject, void* usr)
{
  DtInfo << "Gained Ownership!" << std::endl;
  // Do Something
}
DtDefaultOwnershipHandler defaultHandler;
defaultHandler.setOwnershipAcquisitionAction(OWNERSHIP_ACCEPT_ALL);
defaultHandler.setAcquireOwnershipCallback(&gainedOwnership, 0));
myExerciseConnection->setOwnershipHandler(&defaultHandler);
// Create the reflected entity list, 
DtReflectedEntityList rel(...);

5.7 - Using DDM
Table of Contents
5.7.1 Geographic DDM
5.7.2 Publishing Using Geographic DDM
5.7.3 Reflecting Using Geographic DDM
5.7.4 Interactions with Regions
5.7.5 Using DDM without VR-Link's Geographic Implementation
There are two ways to use Data Distribution Management (DDM) with VR-Link:

Use the DDM scheme implemented by VR-Link's publishers
Pass in your own DDM region and manipulate it manually.
The default VR-Link DDM scheme uses a space named BenchmarkGeographicSpace that has two dimensions, X and Y, which correspond, respectively, to longitude and latitude.

Note
This section describes the recommended ways to use DDM with VR-Link. As always, you can also make direct calls to the RTI if you want.
5.7.1 Geographic DDM
The DtEntityPublisher and DtAggregatePublisher can create their own DDM regions on instantiation, and update them based on entity location and velocity. The size of the region depends on velocity. To enable this, turn on geographic DDM in the DtExerciseConn, as follows:

exConn.setUseGeographicDdm(true);
The exercise connection also has a "playbox" that is used to define the minimum and maximum values of latitude and longitude when performing DDM normalization. The region bounds may not exceed those specified by the playbox. The default values cover the entire Earth (-90 to 90 degrees latitude, and -180 to 180 degrees longitude). To change them, for example to the region bounded by 30N–40N latitude and 120E–130E longitude, do the following:

DtGeodeticCoord lowerBound(DtDeg2Rad(30.0), DtDeg2Rad(-130.0), 0);
DtGeodeticCoord upperBound(DtDeg2Rad(40.0, DtDeg2Rad(-120.0), 0);
exConn.setDdmPlayboxLowerBound(lowerBound);
exConn.setDdmPlayboxUpperBound(upperBound);
5.7.2 Publishing Using Geographic DDM
To publish with a geographic region, the DtExerciseConn's setUseGeographicDDM flag must be set to true. When an entity or aggregate publisher is created, the object is published using a region. This region can be accessed and passed to other publishers, to allow them to publish in the same region. For example, suppose an entity is published with a region. To publish an emitter system in the same region, the entity's region can be passed into the emitter publisher's constructor, as follows:

exConn.setUseGeographicDdm(true);
DtEntityPublisher entityPub(...);
DtEmitterSystemPublisher emitterPub(&exConn, 0, entityPub.publishingRegion());
5.7.3 Reflecting Using Geographic DDM
You can create a geographic region and pass it into a reflected list to subscribe to a class with region.

Note
The DtDDMRegion and DtGeodeticRegion classes in VR-Link are passed into methods using Boost's shared pointer container, since many different objects can hold regions concurrently. The types, DtDDMRegionSP and DtGeodeticRegionSP correspond to DtDDMRegion and DtGeodeticRegion shared pointers.
To subscribe to the region spanning 35 to 40 degrees N and 118 to 122 degrees W, do the following:

DtGeodCoord lowerBound(DtDeg2Rad(35.0), DtDeg2Rad(118.0), 0);
DtGeodCoord upperBound(DtDeg2Rad(40.0), DtDeg2Rad(122.0), 0);
DtGeodeticRegionSP region(new DtGeodeticRegion(&exConn));
region->setRegionBounds(lowerBound, upperBound);
DtReflectedEntityList reflEntList(&exConn, region);
If the attribute scope advisory switch is enabled in the RTI, the federate will receive attributesOutOfScope callbacks when an object goes out of scope of the region. The object will be removed from the reflected list and rediscovered if it comes back into scope. To enable the advisory switch, do the following:

exConn.rtiAmb()->enableAttributeScopeAdvisorySwitch();
Notes
To subscribe to multiple regions, you can create an STL vector of DtGeodeticRegionSPs and pass it into the reflected list constructor.
Subscription with region is a federate-wide call. In other words, if a DtReflectedEntityList is created with one region, and a second DtReflectedEntityList is created with another region, each list will pick up entities from both regions, because the federate has subscribed to entities in both regions.
5.7.4 Interactions with Regions
VR-Link also lets you send and receive interactions in regions. The add callback member function of each interaction can take a region shared pointer, and DtExerciseConn has a member function to send interactions with regions.

To subscribe with region:

// Set up region bounds
...
DtGeodeticRegionSP region(...);
DtFireInteraction::addCallback(&exConn, fireCb, NULL, region);
To send an interaction with region:

// Set up region bounds
...
DtGeodeticRegionSP region(...);
DtFireInteraction fireInteraction;
...
exConn.sendStampedWithRegion(fireInteraction, region);
5.7.5 Using DDM without VR-Link's Geographic Implementation
You can create any type of region using the DtDDMRegion class. You can specify the space (for HLA 1.3) and dimensions, and DtDDMRegion will create an RTI region that can be manipulated using normalized values. Each publisher, reflected list, and interaction can now take a DtDDMRegion, and will publish or subscribe with whatever DtDDMRegion you pass in.

5.8 - Using the DtInteraction Class
Table of Contents
5.8.1 DtInteraction Print-Related Functions
The HLA version of the DtInteraction class is defined in interactionHLA.h.

HLA-specific data is available through a DtInteraction, much as HLA-specific object data is available through a DtHlaObject.

Much of this data is not available (unable to be determined by a DtInteraction) until the DtInteraction is told which FOM interaction class is being used to represent it, and which DtExerciseConn it is associated with. For example, you cannot determine if the DtInteraction's FOM interaction class has been subscribed to by remote federates unless you know what FOM class you wish to use and which DtExerciseConn to ask for subscription information.

DtInteraction has a member function called setExConn() that lets you set the DtExerciseConn and DtInterClassDesc (interaction class descriptor) that are currently associated with a particular instance. setExConn() must be called on an interaction before many of DtInteraction's member functions can return meaningful results. If the class descriptor argument to setExConn() is omitted, the DtInteraction subclass will choose a reasonable default (For details, please see 6.5.3.1 Choosing An Interaction Class to Publish.)

Application code rarely needs to call setExConn() explicitly. VR-Link typically calls it for you. When sending a DtInteraction, DtExerciseConn's send() or sendStamped() functions call setExConn() on the DtInteraction before trying to actually send. That DtExerciseConn passes itself as the exConn argument, and passes NULL as the classDesc argument, allowing the DtInteraction to choose a FOM class to use for sending. On the incoming side, after creating the DtInteraction instance to represent a received interaction, but before passing it to user callbacks, VR-Link calls setExConn() on the interaction, passing the DtExerciseConn on which the interaction was received, along with the interaction class of the received interaction.

Interaction classes typically store their parameter values in their own native representation, but you can obtain this data in the RTI's representation. In fact, this is what DtExerciseConn's send() and sendStamped() functions use to obtain the object to pass to the RTI for sending.

For RTI 1.3, the parameter values are stored as an RTI::ParameterHandleValuePairSet, which you can obtain using DtInteraction::phvps().

For RTI 1516, the parameter values are stored as an RTI::ParameterHandleValueMap, which you can obtain using DtInteraction::phvm().

A DtInteraction can be assigned from an RTI representation using the member function setFromPhvps() (for RTI 1.3) or setFromPhvm() (for RTI 1516). DtExerciseConn uses this function to initialize a DtInteraction as a result of a receiveInteraction() RTI service invocation.

The following table describes functions that require that a DtInteraction instance have a valid current exercise connection and class descriptor.

Additional DtInteraction Functions
Function	Description
interactionClassHandle()	Returns the current interaction class’s handle.
interactionClassName()	Returns the current interaction class’s name.
numParameters()	Returns the number of parameters in the current interaction class.
neededByFederation()	Returns whether the class has been subscribed to by remote federates.
5.8.1 DtInteraction Print-Related Functions
The following table describes DtInteraction's virtual printing functions.

DtInteraction Print Functions
Function	Description
print()	The standard printing function, used by the netdumpHLA utility. It uses the virtual name() function to print the name of the interaction, then calls printParams() and printData().
printHeader()	Prints information about the FOM class being used for the object.
printParams()	Calls printHeader(), then prints the set of parameters included in the interaction message, along with raw parameter values if its withHex argument is set to true.
printData()	A pure virtual function that is implemented by derived classes to print the specific data contained in the interaction, in the form that is available through inspector functions.
Both printHeader() and printParams() require that the interaction have a current exercise connection and class descriptor to fully do their jobs.

If you want to print the data in a DtInteraction that you create before you send it through a DtExerciseConn, you can explicitly call setExConn() before printing, to insure that all data can be printed. For example:

DtExerciseConn exConn(...);
...
DtFireInteraction inter;
inter.setAttacker(...);
...
inter.setExConn(&exConn);
inter.print();

5.9 - Using Generic Attributes and Parameters
Generic attributes and parameters are a way of accessing extended information in your FOM that is not normally supported.

For example, suppose your FOM, based on RPR contains an extra attribute on entity objects called "RadarSignature". Once generics are enabled in VR-Link, all you have to do is ask for your data:

int size;
const char* val = entity->stateRep()->getAttributeByName("RadarSignature", size, entity->hlaObject());
Interactions work in a similar manner:

val = fireInteraction->getParameterByName("RadiationEmitted", size);
There is no longer a need to write a code generator, or to hand model anything. Getting (and setting) your new attributes is simple and effective.

There are two ways to enable generics. The first is the easiest. If you enable generics in your initializer, all unknown attributes will be automatically handled:

appInit.setGenericAttributes(true);
Alternatively, you can choose to only decode generics on single classes, which might be faster than decoding every entity:

DtInterClassDesc* interClass = exConn.fom()->interClassByName("WeaponFire");
interClass->enableUnknownParameters();
Previous versions of VR-Link already supported generic handling of new classes using DtUnknownInteraction and DtUnknownHlaObject. With VR-Link 5.1, you can have hybrid objects, where some are known and some are generic.

So why would you not just use generics? Generic attributes do not have type safety. They are only sent and received as byte arrays and it is up to you to encode and decode them correctly. For attributes that VR-Link knows, this is handled for you already, letting you deal with the data in a more natural form. The same situation applies to code generated objects. However, there are many situations where this might be more work than necessary, and generics let you work with your data as fast as you can change your FOM.

5.10 - General HLA Issues
Table of Contents
5.10.1 Time Stamps
5.10.2 Registering and Responding to Synchronization Points
5.10.2.1 Responding to Synchronization Points Automatically
5.10.3 Time Management
5.10.3.1 Federation Time
5.10.3.2 Sending Time Stamp Order (TSO) Messages
5.10.3.3 Receiving TSO Messages
5.10.3.4 Using Callbacks
5.10.3.5 Converting FedTime to DtTime
5.10.4 VR-Link Calls to RTI Services
The following sections discuss general HLA issues.

5.10.1 Time Stamps
You can set and inspect an HLA DtStateMsg or DtInteraction's time stamp with the setTimeStamp() and timeStamp() functions. These work the same way as the DIS DtPdu's function – taking a time, and a time stamp type (either DtTimeStampRelative or DtTimeStampAbsolute).

DtExerciseConn::sendStamped() sets the time stamp of an outgoing HLA message to the current time, with the type returned by DtExerciseConn::timeStampType().

Consistent with the RPR FOM convention, VR-Link's sending functions encode the time in the "tag" string argument to the RTI's sendInteraction() and updateAttribute-Values() calls. The time is encoded as the 8-byte ASCII representation of the hex number that would have been sent in a DIS time stamp.

If you do not want to use this convention, use DtInteraction::setTagIsAsciiTime(false) and DtStateMsg::setTagIsAsciiTime(false). If you do this, your time stamps will not be sent, because the RTI does not provide a mechanism for sending time stamps along with your messages unless you are using RTI time management. Real-time simulations typically do not use RTI time management.

5.10.2 Registering and Responding to Synchronization Points
The HLA DtExerciseConn class can register synchronization points and register user-defined callbacks for synchronization points. To register a synchronization point named, "point1," with the RTI, call:

exConn.registerSynchronizationPoint("point1");
You can register user-defined callbacks that will be called upon receiving a callback from the RTI. The available callbacks are:

synchronizationPointRegistrationSucceeded()
synchronizationPointRegistrationFailed()
federationSynchronized()
announceSynchronizationPoint().
To add or remove user-defined callbacks, use the following member functions:

addSynchPointRegistrationSucceededCb()
removeSynchPointRegistrationSucceededCb()
addSynchPointRegistrationFailedCb()
removeSynchPointRegistrationFailedCb()
addFederationSynchedCb()
removeFederationSynchedCb()
addAnnounceSynchPointCb()
removeAnnounceSynchPointCb().
Each member function takes a string (optional), function, and a pointer to user data that may be passed to the callback when called. If the string is provided, the callback is called for that particular label. If it is not provided, that callback is called for all labels.

For example:

exConn.addFederationSynchedCb("point1", userFunction, NULL);
causes userFunction to be called when the federation is synchronized at "point1", and:

exConn.addFederationSynchedCb(userFunction, NULL);
causes userFunction to be called when the federation is synchronized at any point.

Example:

#include <vl/exerciseConn.h>
void fedsSynched(const char* label, void* /*usr*/)
{
   std::cout << "Federates synched at: " << label << std::endl;
}
void announcePoint(const char* label, const char* tag, void* usr)
{
   DtExerciseConn* exConn = (DtExerciseConn*)usr;
   std::cout << "Announce point: " << label << std::endl;
   std::cout << "Tag: " << tag << std::endl;
   usr->replyToSynchronizationPoint(label);
}
int main(int argc, char** argv)
{
   DtExerciseConn exConn(...);
   ...
   // fedsSynched is called whenever the federation is synched
   exConn.addFederationSynchedCb(fedsSynched, NULL);
   // announcePoint is called when the label "point2" is announced.
   // The exercise connection automatically replies to all synch points
   // excluding "point2"
   exConn.addAnnounceSynchPointCb("point2", announcePoint, &exConn);
   ... 
}
5.10.2.1 Responding to Synchronization Points Automatically
VR-Link applications, by default, automatically respond to announced synchronization points by immediately indicating that the point has been achieved. This means that VR-Link-based applications will not hold up a federation execution when the application developer has not done anything special to respond to synchronization points. You can enable or disable this automatic response by calling:

exConn.setReplyingToSynchronizationPoints(false);
Note
Registering an announceSynchronizationPoint() callback disables VR-Link's automatic response to announcements for the specified synchronization points.
5.10.3 Time Management
VR-Link supports HLA Time Management. The use of Time Management in an exercise allows federates to synchronize and order events with a timeline maintained by the RTI. Typically, federates use time management when they are interacting with other federates that have a different rate of simulation. However, federates do not have to use Time Management, even if other federates in a federation use it. This description of Time Management in VR-Link assumes that you are familiar with Time Management terms and concepts. For more information, please see your HLA and RTI documentation.

5.10.3.1 Federation Time
Federation Time (FedTime) is the managed simulation time for an exercise. In a time-managed federation execution, the progression of time is accomplished by federates making time requests and receiving time grants from the RTI. Regulating federates control the advancement of FedTime. Constrained federates can advance only as quickly as FedTime allows. At any point in the simulation, FedTime may be different for different federates.

In VR-Link most calls to the RTI are made using the RTI Ambassador directly and are not wrapped by VR-Link. Time Regulation can be turned on and off at any time in an exercise. Many other aspects of time management can be configured such as the LookAhead. For more information about these methods please consult your RTI documentation.

Some example calls are as follows:

DtExerciseConn exConn(. . .);
. . .
exConn.rtiAmb()->enableTimeRegulation(mySuggestedFedTime, myLookAhead);
exConn.rtiAmb()->enableTimeConstrained();
exConn.rtiAmb()->disableTimeConstrained();
exConn.rtiAmb()->timeAdvanceRequest(RequestedFedTime);
exConn.rtiAmb()->disableTimeRegulation();
. . .
5.10.3.2 Sending Time Stamp Order (TSO) Messages
To send time stamp order (TSO) messages in VR-Link, tell VR-Link to attach a FedTime to outgoing messages, as follows:

exConn.setSendFedTime(true);
When sendFedTime() is true, all messages are sent TSO. When sendFedTime() is false (the default), messages are sent read order (RO). This flag can be toggled at any time, but it must be toggled before the message is sent. VR-Link uses VR-Link simTime when it sends FedTime:

ExConn.clock()->simTime();
You need to maintain simTime as FedTime + LookAhead for the message to be delivered. If simTime is less than this, the RTI throws an exception. You can run simTime ahead of FedTime + Lookahead, because a Regulator can send messages with any time in the future, as long as the time is at least FedTime + Lookahead.

5.10.3.3 Receiving TSO Messages
VR-Link handles incoming TSO messages transparently. The RTI makes sure the messages are delivered at the correct FedTime. VR-Link uses the FedTime, when available, to perform dead reckoning computations.

5.10.3.4 Using Callbacks
When the RTI needs to update FedTime for a federate by granting a request, or enable some type of time regulation, it invokes a method in the Federate Ambassador. VR-Link provides callbacks for these methods. You can write functions that handle these RTI events. Then you can register them for callbacks.

The following examples demonstrate callbacks as well as the functions that register them.

void timeAdvanceRequestCb(const RTI::FedTime &theFedTime, void *userData)
{
   // The time we request might not be the time we get back!
   GlobalFedTime = theFedTime;
   // do something
   cout << "Time Advance Grant to: " << GlobalFedTime.getTime() << endl;
}
void timeConstrainedEnabledCb(const RTI::FedTime &theFedTime, void *userData)
{
   GlobalFedTime = theFedTime;
   // do something
   cout << "Time Constrained Enabled at time: "
      << GlobalFedTime.getTime() << endl;
}
// Call this when our time request is granted. timeAdvanceRequestCb is
// the callback. The 0 is data.
exConn.fedAmb()->addTimeAdvanceGrantCb(timeAdvanceRequestCb, 0);  
// This callback lets me know I have become constrained. I must
// remember that until I receive it, I am not time constrained
// and should not ask for a time advance. timeConstrainedEnabledCb is
// the callback. The 0 is data.
exConn.fedAmb()->addTimeConstrainedEnabledCb(timeConstrainedEnabledCb, 0);
// This callback lets me know I have become time regulating. It also 
// lets me know what FedTime it is. I must use that fed time.
// timeRegulationEnabledCb is the callback. The 0 is data.
exConn.fedAmb()->addTimeRegulationEnabledCb(timeRegulationEnabledCb, 0);
5.10.3.5 Converting FedTime to DtTime
Occasionally, VR-Link needs to convert from RTI::FedTime to DtTime. RTI::FedTime is an abstract base class and the federate needs to provide an implementation of this class. Most RTIs, including the MAK RTI, provide a subclass for federates to use. It is typically in the library libFedTime. The base class provides no method for converting RTI::FedTime to a double (DtTime), but the sub-classed method provided by many RTI's (including the MAK RTI) does. Because it is possible, and even likely, that you will use a different subclass of RTI::FedTime, VR-Link will not always know how to do this conversion. Therefore, VR-Link provides member functions in DtExerciseConn that allow you to register conversion functions for VR-Link to use.

static void DtExerciseConn::setFedTimeToVrlTimeConverter(DtFedTimeToVrlTimeConverter func);
static void DtExerciseConn::setVrlTimeToFedTimeConverter(DtVrlTimeToFedTimeConverter func);
DtExerciseConn has default conversion functions for the MAK RTI. If you need to set the conversion functions back to the default, pass a NULL value to either DtExerciseConn::setFedTimeToVrlTimeConverter() or DtExerciseConn::setVrlTimeToFedTimeConverter().

When a federate needs to convert between RTI::FedTime and DtTime, it can use the member functions:

static DtFedTimeToVrlTimeConverter DtExerciseConn::fedTimeToVrlTimeConverter();
static DtVrlTimeToFedTimeConverter DtExerciseConn::vrlTimeToFedTimeConverter();
Use them as in the following example:

RTI::FedTime *fedTimePtr =(*DtExerciseConn::vrlTimeToFedTimeConverter()) (myDtTimeVariable);
5.10.4 VR-Link Calls to RTI Services
The following table lists Federate-initiated services that may be called by VR-Link. The next table lists RTI-initiated services for which VR-Link provides non-NULL definitions.

Federate-initiated Service Called by VR-Link
RTI Service	How it is invoked
createFederationExecution	Invoked from within the DtExerciseConn constructor.
destroyFederationExecution	Invoked from within the DtExerciseConn destructor if the DtExerciseConn's destroyFedExec flag is true (the default).
joinFederationExecution	Invoked from within the DtExerciseConn constructor.
resignFederationExecution	Invoked from within the DtExerciseConn destructor.
publishInteractionClass	Invoked from within the DtExerciseConn::send() or sendStamped() whenever it is called with an interaction whose class has not been published yet.
publishObjectClass	Invoked from within an object publisher's constructor if its object class has not already been published.
subscribeInteractionClass	Invoked when registering a callback function with VR-Link on a particular interaction class using a DtInteraction subclass's addCallback() function.
subscribeObjectClassAttri- butes	Invoked from within a reflected object list's constructor.
unsubscribeInteractionClass	Called by DtObjClassDesc::deregisterInterest(). That function is not called by other VR-Link code, so if application code does not call it, this service is never invoked.
unsubscribeObjectClass	Called by DtInterClassDesc::deregisterInterest(). That function is not called by other VR-Link code. So if application code does not call it, this service is never invoked.
deleteObjectInstance	Invoked from an object publisher's destructor.
localDeleteObjectInstance	Invoked only from DtReflectedObjectList::removeObject(), which is not typically called by applications.
registerObjectInstance	Invoked from an object publisher's constructor.
requestClassAttributeValue-Update	Invoked from a reflected object list's constructor, if the list's requestClassUpdate flag is true (the default).
requestObjectAttributeValue-Update	If DtReflectedEntityList's (or any other reflected object list's) requestObjectUpdate flag is true (the default), then this service is invoked shortly after each reflected object is discovered and created. Since we cannot call the service from within our discover object callback (it would be a concurrent access violation), the service is not called until just before DtExerciseConn::drainInput() returns.
sendInteraction	Invoked from within DtExerciseConn::send() or sendStamped().
sendInteractionWithRegion	Invoked from within DtExerciseConn::send() or sendStamped() if you are using DDM.
updateAttributeValues	Invoked from within an object publisher's tick() function, if we judge that data needs to be sent based on update conditions and remote subscriptions and requests.
RTIambassador	DtExerciseConn's constructor constructs an RTI ambassador.
~RTIambassador	DtExerciseConn's destructor deletes its RTI ambassador.
enableAttributeRelevanceAdvisorySwitch	Invoked by the DtExerciseConn constructor.
enableClassRelevanceAdvisorySwitch	Invoked by the DtExerciseConn constructor.
enableInteractionRelevanceAdvisorySwitch	Invoked by the DtExerciseConn constructor.
disableAttributeRelevanceAdvisorySwitch	Invoked by the DtExerciseConn constructor.
disableClassRelevanceAdvisorySwitch	Invoked by the DtExerciseConn constructor.
disableInteractionRelevanceAdvisorySwitch	Invoked by the DtExerciseConn constructor.
synchronizationPointAchieved	Invoked from DtExerciseConn::replyToSynchPointCallback().
tick	Called from within DtExerciseConn::drainInput().

RTI-initiated Services with Non-NULL Definitions
RTI Service	VR-Link Response
startRegistrationForObjectClass	VR-Link maintains information about which object classes are needed by the federation.
stopRegistrationForObjectClass	VR-Link does not maintain information about which object classes are needed by the federation.
turnInteractionsOff	VR-Link does not maintain information about which interaction classes are needed by the federation.
turnInteractionsOn	VR-Link maintains information about which interaction classes are needed by the federation.
discoverObjectInstance	If any reflected object list has registered interest in the object's class or a super class, VR-Link creates a new reflected object and adds it to the list.
provideAttributeValueUpdate	VR-Link notes that the attribute set has been requested. The next time the object's publisher calls its tick() function, the request attribute updates are sent.
receiveInteraction	If any user callbacks have been registered with VR-Link for the received interaction type, those callbacks are invoked.
reflectAttributeValues	The reflected object's state repository is updated based on the contents of the received attribute update.
removeObjectInstance	The reflected object is removed from the reflected object list, and deleted.
turnUpdatesOffForObjectInstance	VR-Link does not maintain information about which attributes are needed by the federation.
turnUpdatesOnForObjectInstance	VR-Link maintains information about which attributes are needed by the federation.
The following ancillary services are called at various points within VR-Link:

getAttributeHandle
getAttributeName
getInteractionClassHandle
getObjectClassHandle
getObjectInstanceName
getParameterHandle
getParameterName.

5.11 - Interoperability Between HLA 1.3 and IEEE 1516 Federates
In general, the MAK RTI, and various other MAK tools support run-time interoperability between HLA 1.3 federates and IEEE 1516 federates.

Federates that are using Federation Management, Declaration Management, Object Management, Time Management, and Data Distribution Management services should be able to interoperate across the 1.3-1516 boundary. For example, you can typically run the HLA 1.3 version of the VR-Vantage Stealth and the IEEE 1516 version of VR-Forces together in the same federation execution, provided you are using the MAK RTI, or another RTI that supports 1.3-1516 interoperability.

When HLA 1.3 and HLA 1516 federates interoperate, they can use either FED or XML files as long as they describe the same classes and you use VR-Link calls, not direct calls to the RTI.

However, there note the following restrictions and requirements:

MOM is not currently supported across the 1.3-1516 boundary, and must be disabled. (The 1.3 and 1516 specifications dictate completely different data representations for MOM attributes and parameters.)
Ownership management is also problematic, and should be avoided. For object names, the 1516 RTI converts all strings from the wide char representation to a narrow character representation. So, the names supplied by the 1516 federates must allow this conversion (that is, only support the ASCII character set). For user supplied tags, the 1516 federates are restricted to the 1.3 string format. The 1.3 RTI cannot represent the complex data types allowed by 1516.
The main reason that consistency in FOM format is necessary is that HLA 1.3 and IEEE 1516 use different names for the "Root" classes of the Object and Interaction class hierarchies. A 1.3-style FED file requires a Root class called "ObjectRoot", whereas a 1516-style XML files requires a Root class called "HLAObjectRoot". This is a problem because if a federate uses an HLA-1.3-based FED file, it might subscribe to a class called "ObjectRoot.Vehicle". On the other hand, a federate that is using an IEEE-1516-style XML file might publish a class that is meant to be the same class, but that is actually named "HLAObjectRoot.Vehicle". Neither the RTI nor the federates will realize that these classes were intended to be the same, and the subscribing federate will fail to discover any objects that the publishing federate registers.

5.12 - FOM Agility
VR-Link has been designed with FOM agility in mind.

It comes with built-in support for different versions of the RPR FOM, but it can be extended or configured in many different ways to work with changes or extensions to the FOM, or to work with unrelated FOMs. FOM agility is implemented by writing additional VR-Link classes or by creating a FOM Mapper.

6 - FOM Agility explains how VR-Link's architecture enables FOM agility and how you can extend or configure VR-Link to work with a variety of FOMs.

6 - FOM Agility
These pages describe VR-Link's FOM agility and FOM mapping:

6.1 - Introduction to FOM Agility
6.2 - FOM Mapping Overview
6.3 - FOM Mapping Information Required By VR-Link's API
6.4 - FOM Mapping Details
6.5 - Setting Up a FOM Mapper's Class Mappings
6.6 - Creating Instances of DtInteraction
6.7 - Attribute and Parameter Encoding and Decoding
6.8 - Choosing a DtFomMapper
6.9 - VR-Link FOM Mapping and Extension Examples


6.1 - Introduction to FOM Agility
VR-Link has been designed with FOM agility in mind.

It comes with built-in support for different versions of the RPR FOM, but it can be extended or configured in many different ways to work with changes or extensions to the RPR FOM, or to work with unrelated FOMs. FOM agility is implemented through a FOM Mapper.

This chapter explains how VR-Link's architecture enables FOM agility and how you can extend or configure VR-Link to work with a variety of FOMs. VR-Link includes several examples of extending VR-Link for FOM agility. They are documented in the class documentation. 7 - The VR-Link Code Generator, explains how to use the VR-Link Code Generator to create new interaction and object classes automatically, rather than by hand as described in this chapter.

6.2 - FOM Mapping Overview
The figure illustrates VR-Link's basic architecture for FOM agility.

fommappingarchitecture.png
FOM mapping architecture
The top-level FOM-independent API lets you set and inspect the state of local and remote objects and the data contained in locally generated or received interactions, without regard to how the data is actually represented in a FOM. This top-level API includes the object publishers, reflected objects, reflected object lists, state repositories, and interaction classes.

The FOM Mapping layer routes and converts data between the FOM-independent API and the FOM representations you are using for a particular federation execution.

There are two broad categories of FOM modifications that developers might implement:

FOMs that contain only those concepts that are already present in VR-Link's top-level API, but which may represent the concepts differently from the way they are represented in the VR-Link API.
FOMs that include concepts that are not present in VR-Link's API.
If you are implementing FOMs that have the same concepts as the VR-Link API, you can switch from FOM to FOM just by modifying the FOM Mapping layer, which you can do without affecting the top-level API. This means that application code written to the top-level API does not need to change when switching from FOM to FOM. (6.8.2 Passing the Name of A Shared Library, explains how to load a FOM Mapper from a shared library so that your applications do not need to be recompiled when you switch between FOMs.)

For example, in one FOM (such as the RPR FOM), position data may be represented in geocentric coordinates in an attribute named "Position". In another, it might be represented in topographic coordinates in an attribute named "Location". In either case, position data is available to application code through VR-Link in the manner dictated by its FOM-independent API – as geocentric data obtainable using DtEntityStateRepository::location(). FOM Mapping code takes care of converting from the various FOMs' representations to the representation chosen by VR-Link.

If you are using FOMs that contain concepts not found in the VR-Link API, you must follow a two-step FOM-configuration process.

Extend the top-level API, by deriving new classes from our base state repository, publisher, reflected object, or reflected object list classes to include your new concepts. Once you have done this, your code is part of the FOM-independent API.
Create mappings from arbitrary FOM representations of these concepts to your new API extensions, just as if your extensions were part of the standard VR-Link API. (Typically, you will choose representations for your API that closely match the representation in a particular FOM, meaning that the mapping code will be fairly straightforward.)

6.3 - FOM Mapping Information Required By VR-Link's API
The HLA implementations of the classes that make up VR-Link's top-level API require the following pieces of FOM Mapping information:

Class mappings:
Publishers need to know which FOM object class to choose to represent a locally simulated object.
Reflected object lists need to know the set of FOM classes for which they should register discoverObject() callbacks, that is, which types of objects should be managed by the list.
Interaction instances need to know which FOM class to use to represent themselves when they are being sent.
Interaction classes need to know which FOM classes to subscribe to when their static addCallback() functions are called.
DtExerciseConn needs to know which DtInteraction subclass to instantiate when an interaction of each class in the FOM is received.
Attribute and parameter encoding and decoding:
Publishers need to know how to decide whether each attribute needs to be sent during a call to tick(), and how to encode values from its state repository into outgoing attribute updates.
Reflected objects need to know how to decode each attribute of a FOM class into its state repository.
Interaction instances need to know how to encode and decode each parameter.
Architecturally, it is the responsibility of these top-level objects to choose how they obtain this FOM mapping information. For example, a particular subclass of DtInteraction might hard-code the name of the FOM class it should be associated with, or it might check some global variable.

However, all of the FOM-independent classes in VR-Link get their FOM mapping information from a central place called a DtFomMapper. (Actually, many of these classes allow application code to override the FOM Mapper's choice, but asking the FOM Mapper is the default behavior.)

The FOM Mapper that these top-level objects use is obtained from their DtExercise-

Conn, through DtExerciseConn::fomMapper(). DtExerciseConn creates, or is passed, a DtFomMapper on construction. For more information, please see 6.8 - Choosing a DtFomMapper.

6.4 - FOM Mapping Details
A DtFomMapper (defined in fomMapper.h) is a central repository for FOM mapping information.

Top-level API classes call DtFomMapper functions to obtain FOM mapping information. For example, to find out which FOM object class to use to represent an object being managed by a particular type of DtObjectPublisher, the publisher calls DtFomMapper::chooseObjectClass().

To set or change a FOM Mapper's mappings, use DtFomMapper's mutator functions to configure a FOM Mapper so that its functions return the data you want.

For example, you can use DtFomMapper::setObjectClassToChoose() to set up a mapping between a particular subclass of DtObjectPublisher and a particular FOM object class.

To have VR-Link use new FOM mappings that you provide, you can either allow the DtExerciseConn to create its DtFomMapper, then add your own mappings to this FOM Mapper later, or you can create your own instance of a DtFomMapper, and tell the DtExerciseConn to use it. For more information, please see 6.8 - Choosing a DtFomMapper. The following sections describe how a FOM Mapper is configured, regardless of whether you choose to do it before or after DtExerciseConn construction.

6.5 - Setting Up a FOM Mapper's Class Mappings
Table of Contents
6.5.1 Choosing an Object Class to Publish
6.5.2 Mapping a Single FOM Class to a Publisher
6.5.2.1 Mapping Multiple FOM Classes to A Publisher
6.5.3 Subscribing to Object Classes
6.5.3.1 Choosing An Interaction Class to Publish
6.5.4 Subscribing to Interaction Classes
6.3 - FOM Mapping Information Required By VR-Link's API, explains that a FOM Mapper contains class mapping information as well as attribute and parameter encoding and decoding information.

This section describes how to set up a FOM Mapper's class mappings.

6.5.1 Choosing an Object Class to Publish
A DtObjectPublisher asks the FOM Mapper for the name of the FOM object class to use to represent its locally simulated object by calling chooseObjectClass(). The publisher passes the name of its own VR-Link C++ publisher class, for example, DtEntityPublisher or DtAggregatePublisher.

When you configure a FOM Mapper, you can dictate what FOM class chooseObjectClass() will return in one of two ways:

Map a single class to a publisher
Map multiple classes to a publisher.
6.5.2 Mapping a Single FOM Class to a Publisher
If one FOM class should always be chosen for a particular kind of publisher, create this association using DtFomMapper::setObjectClassToChoose(). For example, in the RPR FOM, DtAggregatePublishers should always use the FOM class BaseEntity.AggregateEntity:

fomMapper->setObjectClassToChoose("DtAggregatePublisher", "BaseEntity.AggregateEntity");
6.5.2.1 Mapping Multiple FOM Classes to A Publisher
It might be possible to map several FOM classes to a publisher. In these cases, some instance-specific data might be necessary in order to make a choice. In this case, you can associate a class choosing function with the name of a VR-Link class, rather than just a single object class, using setObjectClassChooser().

A class choosing function looks like this:

char* myClassChooser(const char* vrlinkClassName, DtExerciseConn* conn, void* usr);
You can associate a class choosing function with a VR-Link publisher class name as follows:

fomMapper->setObjectClassChooser("DtEntityPublisher", myClassChooser);
The VR-Link class may pass instance-specific data as the usr argument to chooseObjectClass(), and this data will be passed to your chooser function as usr. For example, DtEntityPublisher passes a pointer to the entity's DtEntityType, and in the RPR FOM Mapper, our class chooser function picks a FOM class based on the entity type.

6.5.3 Subscribing to Object Classes
A DtReflectedObjectList asks the FOM Mapper for the names of the FOM classes to subscribe to and manage, by calling objectClassNames(). Besides subscribing to the returned classes, the reflected object list registers discoverObjectInstance() callbacks with lower layers of VR-Link for these classes, so that it can be made aware of new instances, and can create DtReflectedObject instances to represent them. The reflected object list passes the name of its own VR-Link C++ class, for example, DtReflectedEntityList.

When configuring a FOM Mapper, you can specify which FOM classes objectClassNames() returns in one of the following ways:

If a particular DtReflectedObjectList subclass should manage only a single FOM class, create this association using setObjectClass(). For example:

fomMapper->setObjectClass("DtReflectedAggregateList", "BaseEntity.AggregateEntity");
If you want a particular kind of list to manage more than one FOM object class, use setObjectClassNames() to pass a DtList of names of FOM classes. For example:

DtList entityClasses;
entityClasses.add("BaseEntity");
entityClasses.add("PhysicalEntity");
...
fomMapper->setObjectClasses("DtReflectedEntityList", entityClasses);
6.5.3.1 Choosing An Interaction Class to Publish
Choosing an interaction class works very similarly to choosing an object class. When you call setExConn() on an interaction (DtExerciseConn::send() and sendStamped() call this function), the DtInteraction instance uses chooseInteractionClass() to ask the FOM Mapper for the name of a FOM class to use to represent the interaction. The interaction instance passes a reference to itself. Based on the name of the VR-Link C++ interaction class (which can be obtained from an interaction instance using its name() function) the FOM Mapper must choose an appropriate FOM class to use.

As with objects, you can specify which FOM class chooseInteractionClass() returns in one of two ways:

If one single FOM class should always be chosen for a particular kind of DtInteraction, create this association using DtFomMapper::setInteractionClassToChoose(). For example, in the RPR FOM, DtFireInteractions should always use the FOM class WeaponFire:

fomMapper->setInteractionClassToChoose("DtFireInteraction", "WeaponFire");
When more than one mapping is possible for a single kind of DtInteraction, associate an interaction class chooser function with the VR-Link class name using setInteractionClassChooser(). Choosers look like this:

char* myChooser(DtExerciseConn* exConn, const DtInteraction& inter);
and are registered like this:

fomMapper->setInteractionClassChooser("DtFireInteraction", myChooser);
The actual interaction for which a choice is being requested is passed to your chooser, in case any instance-specific data is needed to make the choice.

6.5.4 Subscribing to Interaction Classes
When you call the static addCallback() function on a particular DtInteraction subclass, you are saying that you are interested in interactions of that type. The DtInteraction subclass maps that request to subscriptions to FOM classes. It obtains the set of FOM classes to subscribe to from the FOM Mapper using its interactionClasses() member function.

You can determine what this function will return using setInteractionClass() or setInteractionClasses(). Use setInteractionClass() to map to a single FOM class, for example:

fomMapper->setInteractionClass("DtFireInteraction", "WeaponFire");
and setInteractionClasses() for multiple FOM classes, for example:

DtList classNames;
classNames.add(RadioSignal.ApplicationSpecific");
classNames.add(RadioSignal.EncodedAudio");
...
fomMapper->setInteractionClasses(classNames);

6.6 - Creating Instances of DtInteraction
For interactions, the final class mapping component is the mapping between FOM classes and functions that create instances of the appropriate DtInteraction subclasses.

DtFomMapper uses a DtInteractionFactory (defined in interactionFactory.h) to manage this kind of mapping.

When an interaction is received from the RTI, the DtExerciseConn asks the FOM Mapper's DtInteractionFactory to create an instance of the appropriate kind of DtInteraction subclass, using its createInteraction() member function. The FOM Mapper's interaction factory is obtained using DtFomMapper::interactionFactory().

You can add or change an interaction factory's mappings using its addCreator() member function, passing a FOM class name and an interaction creation function such as a DtInteraction subclass's static create() member function. For example, when we receive an interaction of FOM class WeaponFire, we want to create an instance of DtFireInteraction:

fomMapper()->interactionFactory()->addCreator("WeaponFire", DtFireInteraction::create);
You can replace a DtFomMapper's interaction factory with a new one using its setInteractionFactory() member. For example, you might want to create a subclass of DtInteractionFactory for your FOM that registers all of the desired creators from within its constructor. You would then create an instance of this DtInteractionFactory subclass, and instruct the FOM Mapper to use it as its interaction factory.

No analogous mapping step is required for objects, since instances of appropriate DtReflectedObject subclasses are created not by a central class like DtExerciseConn, as interactions are, but rather by DtReflectedObjectList subclasses. And each DtReflectedObjectList knows what kind of DtReflectedObject subclass to instantiate.

6.7 - Attribute and Parameter Encoding and Decoding
Table of Contents
6.7.1 Encoders and Decoders
6.7.2 Functions for Encoding and Decoding
6.7.2.1 Decoding Interactions
6.7.2.2 Decoding Object State Updates
6.7.2.3 Encoding Interactions
6.7.2.4 Encoding Objects
6.7.3 Encoder and Decoder Factories
Besides the class mappings described in 6.5 - Setting Up a FOM Mapper's Class Mappings, a DtFomMapper also contains information about how to encode and decode individual attributes and parameters, that is, how to go between an RTI message in FOM representation, and VR-Link's DtStateRepositories and DtInteractions.

This section describes how to configure that aspect of a FOM Mapper.

Encoders and decoders are tables of encoding and decoding functions – one for each attribute. Encoder factories and decoder factories are tables of encoders and decoders – one table for each object or interaction class. A DtFomMapper has an encoder factory and a decoder factory for both objects and interactions. Top-level VR-Link classes request encoders and decoders from a FOM Mapper's encoder and decoder factories, and use those encoders and decoders to generate or decode RTI representations of state updates or interactions.

When you build with RTI 1516, VR-Link wraps the Attribute Value Pair Map with an Attribute Value Pair Set to preserve encoder and decoder compatibility with RTI 1.3. Therefore, if you follow the directions in this chapter, your encoders and decoders will work with both RTI 1.3 and RTI 1516.

You can change the way that attributes or parameters are encoded or decoded, or provide methods for encoding or decoding new attributes or parameters, by adding your own functions to the tables used by the encoders and decoders. You can get a pointer to the encoder or decoder you want to change from the appropriate factory. To add new FOM classes, you can create new encoders and decoders and add them to the factories' tables.

6.7.1 Encoders and Decoders
At the heart of VR-Link's FOM Mapping functionality are our encoder and decoder classes:

DtHlaStateEncoder (hlaStateEncoder.h)
DtHlaStateDecoder (hlaStateDecoder.h)
DtInteractionEncoder (interactionEncoder.h)
DtInteractionDecoder (interactionDecoder.h)
And their subclasses.
A DtReflectedObject uses a state decoder's decode() member function to unpack data that arrives in incoming state updates or interactions (which are represented as dictated by the FOM), convert it to the representation expected by the top-level API (mutator functions in state repositories), and pass the converted data to those mutator functions.

Similarly, a DtInteraction uses an interaction decoder's decode() member function to unpack the data contained in an interaction message received from the RTI, convert it, and pass that data to the DtInteraction subclass instance's appropriate mutator functions.

The DtObjectPublisher::tick() function uses a state encoder's encode() member function to decide which attributes need to be sent, and to generate an update for those attributes. The encoder evaluates update conditions, and generates outgoing update messages by:

Obtaining data from the publisher's state repository (using its inspector functions).
Converting to the representations dictated by the FOM.
Adding these values to an outgoing message for sending through the RTI.
Similarly, a DtInteraction uses an interaction encoder's encode() member function during sending, to convert values obtained from inspector functions to outgoing interaction messages that can be sent through the RTI.

VR-Link's encoder and decoder classes implement an efficient, table-driven approach to attribute encoding and decoding. You are free to subclass encoders and decoders and to override the encode() and decode() functions, but this is rarely necessary. Usually, you will just configure encoders and decoders, adding individual attribute or parameter encoding or decoding functions to their tables.

6.7.2 Functions for Encoding and Decoding
A decoder is implemented as a table of decoding functions, one per FOM attribute or parameter. Each function is responsible for decoding the attribute or parameter it has been associated with. Similarly, an encoder contains a table of encoding functions. For objects, an encoder contains an additional table of checking functions – functions that evaluate the update conditions for individual attributes, indicating whether the attribute needs to be sent to the exercise.

Encoders and decoders have addEncoder() and addDecoder() member functions, and DtHlaStateEncoder has an additional addChecker() member function, that allow you to register your own encoding, decoding, and checking functions for a particular attribute or parameter with an encoder or decoder. These add functions return the function that had previously been registered for the attribute or parameter, if any. The add functions create associations only for attributes or parameters of a single FOM class. If you want a function to be applied to an attribute or parameter of a class and all of its subclasses, you can call addEncoder(), addDecoder() and addChecker() on multiple encoder or decoder objects, or use the more convenient multi-class registration functions in the encoder or decoder factory classes. For more information, please see 6.7.3 Encoder and Decoder Factories.

The following sections describe the form and function of encoding, decoding, and checking functions.

6.7.2.1 Decoding Interactions
The function DtInteractionDecoder::decode() takes an RTI representation of an interaction message (an RTI::ParameterHandleValuePairSet, or PHVPS), and a pointer to a DtInteraction object, to fill out based on the RTI data. It goes through the parameters in the PHVPS, and for each one, it calls the parameter decoding function that has been associated with the parameter.

The following code sample shows the parameter decoding function used for decoding the "RateOfFire" attribute of the RPR FOM class WeaponFire into a DtFireInteraction:

void decodeRateOfFire(DtFireInteraction* inter, const RTI::ParameterHandleValuePairSet& pvlist, int index)
{
   RTI::ULong length = 0; 
   DtNetU16* netVal = (DtNetU16*) params.getValuePointer(index, length);
   int nativeVal = (DtU16) *netVal;
   inter->setRate(nativeVal);
}
The general decode() function passes it a pointer to the interaction, the PHVPS containing the parameter values, and the index into the set of the parameters this decoding function should be decoding. The function:

Pulls out the index'th value.
Converts the value to the representation expected by the appropriate DtFireInteraction mutator function (in this case, setRate()).
Passes the value to the mutator function.
In this case, the conversion is fairly trivial – from a short to an int. In addition, when VR-Link's "Net" types are used, byte swapping occurs when converting to a native type, if necessary.

6.7.2.2 Decoding Object State Updates
DtHlaStateDecoder::decode() takes a DtStateMsg (a VR-Link wrapper around an RTI::AttributeHandleValuePairSet, or AHVPS), and a pointer to the DtStateRepository it will decode the message into. It walks the list of attributes in the message, and calls the attribute decoding function that has been associated with each.

The following code sample shows a decoding function for an attribute. It is a function you might use for decoding the Position attribute of the RPR FOM object class BaseEntity into a DtEntityStateRepository. Again, index indicates which attribute in the set to decode. The conversion from FOM representation to VR-Link representation looks trivial, since a DtNet64Vector can be implicitly converted to a DtVector. Clearly, more complex conversions, such as coordinate conversions, could be added if necessary.

void decodePosition(DtEntityStateRepository* stateRep,
   const RTI::AttributeHandleValuePairSet& attrs, int index)
{
   RTI::ULong length = 0;
   DtNet64Vector* netVal = (DtNet64Vector*) 
      attrs.getValuePointer(index, length);
   stateRep->setLocation((DtVector) *netVal);
}
6.7.2.3 Encoding Interactions
Encoders work like decoders, but in reverse. DtInteractionEncoder::encode() takes a DtInteraction instance containing interaction data, and a PHVPS to fill out with the FOM representation of this data. For each parameter in the DtInteraction's FOM interaction class, encode() calls the encoding function that has been registered with the encoder for that parameter. Parameter encoding functions look like the following example. The paramHandle argument specifies the handle (not index) of the parameter to encode. Again, the byte swapping occurs if necessary when converting from an int to a DtNetU16.

void encodeRateOfFire(
   const DtFireInteraction& inter,
   RTI::ParameterHandleValuePairSet* params,
   RTI::ParameterHandle paramHandle)
{
   DtNetU16 netVal = (DtNetU16) inter.rate();
   params->add(paramHandle, (char*) &netVal, sizeof(DtNetU16));
}
6.7.2.4 Encoding Objects
Encoding objects is a little bit more complicated than encoding interactions, because the encoder has to first decide which attributes need to be sent, and then encode those attributes. A DtHlaStateEncoder contains a table of encoding functions and a table of checking functions that determine whether an attribute needs to be sent by comparing the current state of the object with the values from its previous update. Update conditions are specified in a FOM. For example, many attributes have an update condition of ON_CHANGE, meaning that they need to be sent every time their value changes.

When a publisher's tick() function calls a DtHlaStateEncoder::encode() function, it passes five arguments:

A DtStateRepository containing the current state of the object to be encoded.
A second DtStateRepository containing the state of the object as it would be seen by remote federates based on attribute updates that we have already sent. This state repository is maintained by the publisher by using a decoder to decode updates that it sends into its as-seen-by-remote state repository after it sends them.
The set of attributes that are currently subscribed to by remote federates.
The set of attributes that should be sent now, even if their update conditions have not been met. This includes any attributes that have been specifically requested by a remote federate through a requestAttributeUpdate RTI service invocation, and any attributes for which the user has called DtObjectPublisher::forceUpdate().
A pointer to the DtStateMessage (wrapper around AHVPS) to fill out.
For each published attribute of the FOM class, encode() determines whether the attribute needs to be included in the update message or not. This may require calling the checker function that has been registered for the attribute. If the attribute needs to be sent, encode() calls the encoding function that has been registered for the attribute to encode it.

Encoding functions look similar to interaction encoding functions described previously. They take the state repository containing current state, the AHVPS to encode into, and the attribute handle of the attribute to be encoded.

void encodePosition(
   const DtEntityStateRepository& stateRep,
   RTI::AttributeHandleValuePairSet* avList,
   RTI::AttributeHandle attrHandle)
{
   DtNet64Vector netVal = (DtNet64Vector) stateRep.location();
   avList->add(attrHandle, (char *) &netVal, sizeof(DtNet64Vector));
}
Checking functions take two state repositories as arguments: one holding the current state of the object, and one holding the state of the object as it would be seen by remote federates based on updates that the local application has sent. (The publisher decodes its outgoing updates into this as-seen-by-remote state repository in order to keep it up to date.) Many checking functions usually need to compare the current value to the as-seen-by-remote value to determine whether an attribute needs to be sent. Here's an example of a checker used for the DamageState attribute of the PhysicalEntity RPR FOM class. It returns true if the value has changed since it was last sent:

bool needDamageState(
   const DtEntityStateRepository& stateRep,
   const DtEntityStateRepository& asSeenByRemote)
{
   return (stateRep.damageState() != asSeenByRemote.damageState()) 
? true : false;
}
6.7.3 Encoder and Decoder Factories
When a publisher, reflected object, or incoming interaction is created, or when an outgoing interaction is sent, it obtains from the FOM Mapper an instance of an encoder, decoder, or both that has been configured for use with its FOM class. These are the instances that they will later use to perform the encoding and decoding of FOM data.

DtFomMapper uses four factory classes to help with the job of returning appropriate encoders and decoders:

DtStateDecoderFactory (stateDecoderFactory.h)
DtStateEncoderFactory (stateEncoderFactory.h)
DtInteractionDecoderFactory (interactionDecoderFactory.h)
DtInteractionEncoderFactory (interactionEncoderFactory.h).
You can get pointers to a DtFomMapper's various encoder and decoder factories using the following member functions:

stateDecoderFactory()
stateEncoderFactory()
interactionDecoderFactory()
interactionEncoderFactory().
These factories have addEncoder() or addDecoder() member functions that allow you to associate a properly configured instance of an encoder or decoder with each FOM object or interaction class. When a publisher, reflected object, or interaction needs an instance of an encoder or decoder for its FOM class, it requests one by calling a factory's createEncoder() or createDecoder() member function. These functions return a new'ed encoder or decoder that is a clone of the instance you have associated with the class using addEncoder() or addDecoder(). Clones are created using the encoder or decoder's virtual clone() member function.

The factory classes also have encoder() and decoder() functions that return pointers to the encoder or decoder that is currently registered for a particular FOM class. The optional second argument to these functions lets you indicate what you want to happen when there is no encoder or decoder associated with a class. Use true to indicate that you want the encoder or decoder associated with the most specific superclass for which one has been registered. Use false to indicate that you want NULL to be returned when there is no encoder or decoder registered for exactly the FOM class you specified.

When you want to register your own encoding or decoding functions for a particular FOM class, use a factory's encoder() or decoder() function to get a pointer to the object containing the function table for that class. Then use the encoder or decoder's mutators to register your own functions:

RTI::InteractionClassHandle handle = 
   rtiAmb->getInteractionClassHandle("WeaponFire");
DtInteractionDecoder* fireDecoder = 
   fomMapper->interactionDecoderFactory()->decoder(handle);
fireDecoder->addDecoder("RateOfFire", myFunc); 
When you use this method to register functions, you are associating new encoding, decoding, or checking functions only with a single FOM class at a time. If you want to add such functions to the encoders and decoders for a class and all of its subclasses, you can use one of the following member functions of one of the factory classes:

addAttributeEncoder()
addAttributeDecoder()
addAttributeChecker()
addParameterEncoder()
addParameterDecoder().
These functions takes the name (or handle) of a FOM class, the name (or handle) of an attribute or parameter, a function to register, and a boolean flag indicating whether the function should apply to subclasses of the indicated FOM class (default is true).

For example, to register a new encoding function for the Position attribute of the BaseEntity RPR FOM class and all of its subclasses:

fomMapper->stateEncoderFactory()->addAttributeEncoder("BaseEntity", "Position", myFunc, true);
You can replace any of the factories used by a FOM Mapper using the factory_typesetFactory() functions. For example, if you are creating a FOM Mapper for a new FOM, you might create a subclass of DtHlaStateEncoderFactory whose constructor registers all of the desired encoder prototypes. You can tell the FOM Mapper to use an instance of this subclass like this:

MyEncoderFactory* factory = new MyEncoderFactory(...); 
fomMapper->setStateEncoderFactory(factory);
Alternatively, you can start with the empty factories, or the factories contained in some existing FOM Mapper (like VR-Link's RPR FOM Mapper), and just add your own encoders and decoders to them without ever creating new factory instances.

6.8 - Choosing a DtFomMapper
Table of Contents
6.8.1 Passing a DtFomMapper Instance
6.8.2 Passing the Name of A Shared Library
6.8.3 The Fallback FOM Mapper Creation Function
6.8.4 Configuring a FOM Mapper After Constructing a DtExerciseConn
6.8.5 Using Different RPR FOM Versions
6.8.6 Deriving Your Own DtFomMapper
When you construct a DtExerciseConn, you must choose a FOM Mapper for it to use.

You can do this in one of several different ways:

Pass a DtFomMapper instance to a DtExerciseConn constructor.
Pass the name of a shared library containing a function that creates the desired FOM Mapper to a DtExerciseConn constructor.
Set the fallback FOM Mapper creation function, using DtExerciseConn's static setFomMapperCreator() function.
Allow DtExerciseConn to create an empty FOM Mapper and configure it after the DtExerciseConn constructor returns. (In fact, regardless of how you choose a FOM Mapper, you can always modify or reconfigure it after the DtExerciseConn constructor returns.)
6.8.1 Passing a DtFomMapper Instance
The following DtExerciseConn constructor takes an instance of a DtFomMapper.

DtExerciseConn(const char* execName, const char* federateName, DtFomMapper* mapper = DtRprFomMapper::create(), const char* fedFileName = NULL);
For example, if you create a FOM Mapper subclass called MyFomMapper, you might instruct the DtExerciseConn to use your FOM Mapper as follows:

MyFomMapper mapper(); 
DtExerciseConn("VR-Link", "MyAppName", &mapper);
Note
The mapper argument has a default value, which is a pointer to a new'ed DtRprFomMapper – a FOM Mapper implemented in VR-Link that maps to the Real-time Platform Reference FOM (RPR FOM). If you omit the FOM Mapper argument, as in the examples in the protocol-independent section, the RPR FOM Mapper is used. For more information, please see 6.8.5 Using Different RPR FOM Versions.
If you pass a value of NULL as the mapper argument to this constructor, VR-Link uses the FOM Mapper creation function last passed to setFomMapperCreator() to create a FOM Mapper. The default is a function that creates a DtEmptyFomMapper.

6.8.2 Passing the Name of A Shared Library
The following DtExerciseConn constructor takes the name of a shared library (DSO or DLL).

DtExerciseConn(const char* execName, const char* federateName,
   const char* dsoName, const char* fedFileName = NULL,
   void* fomMapInitData = NULL);
When you use this constructor, dsoName must be the name of a shared library (DLL or DSO) that contains definitions for the following functions:

DtFomMapper* DtCreateFomMapper(void* usr);
void DtDeleteFomMapper(DtFomMapper* mapper);
DtCreateFomMapper() is called by the DtExerciseConn after it opens the shared library. It should return a pointer to an instance of a DtFomMapper (or a subclass) that you want to use. DtDeleteFomMapper() is a function that will be called from within the DtExerciseConn destructor, which should delete the FOM Mapper instance that you provided.

When you specify the name of your shared library, you can omit the filename extension (.so or .dll) to provide platform independence.

These two function definitions that you provide in a shared library should have C linkage. You can insure this, by wrapping extern "C" {} around your function definitions. For example:

extern "C"
{
   DtFomMapper* DtCreateFomMapper(void* usr)
   {
   return new MyFomMapper();
   }
   void DtDeleteFomMapper(DtFomMapper* mapper)
   {
      delete mapper;
   }
}
You can specify the full path to your shared library within the dsoName argument to the DtExerciseConn constructor, or make sure that it is in your current shared library search path.

The final argument to the DtExerciseConn constructor that takes a shared library name, is a void* that can point to any arbitrary data that is required by the DtCreateFomMapper() function defined in your FOM Mapper shared library. The pointer that is passed to the DtExerciseConn constructor as fomMapInitData will be passed as the usr argument to the DtCreateFomMapper() function defined in your shared library. In the example above, we simply ignored this usr data.

If VR-Link cannot successfully open the specified shared library, or if VR-Link cannot find the symbols DtCreateFomMapper() and DtDeleteFomMapper() within it, DtExerciseConn acts as though you explicitly passed a NULL FOM Mapper: VR-Link uses the function last passed to DtExerciseConn::setFomMapperCreator() to create a FOM Mapper. The default is a function that creates a DtEmptyFomMapper.

For a demonstration of the process of creating a FOM Mapper shared library, please see the myFomMap example under ./examples/extend/myFomMap.

6.8.3 The Fallback FOM Mapper Creation Function
DtExerciseConn has a fallback FOM Mapper creation function that is used when you pass NULL as the mapper argument to the DtExerciseConn constructor, or when an invalid FOM Mapper shared library is passed as the dsoName argument.

You can set the fallback FOM Mapper creation function by using DtExerciseConn's static setFomMapperCreator() member function before creating a DtExerciseConn instance. A FOM Mapper creation function has the same prototype as the DtCreateFomMapper() function shown above. The default fallback function is DtEmptyFomMapper::create() – which creates an instance of DtEmptyFomMapper (defined in emptyFomMapper.h). A DtEmptyFomMapper is a clean slate – a FOM Mapper that contains no mappings between VR-Link classes and FOM classes.

6.8.4 Configuring a FOM Mapper After Constructing a DtExerciseConn
A DtFomMapper can be configured using its mutator functions after the DtExerciseConn constructor returns. You can use this capability to add a few extra mappings to a FOM Mapper that has been passed to the DtExerciseConn, or constructed from a shared library.

If you want to, you can do all of your FOM configuration after the DtExerciseConn constructor returns. Pass NULL as the mapper argument to the DtExerciseConn constructor and start with the default DtEmptyFomMapper that gets created (assuming that you have not set the fallback FOM Mapper creation function to something other than DtEmptyFomMapper::create()).

6.8.5 Using Different RPR FOM Versions
VR-Link contains built-in support for the RPR FOM. It uses a class called DtRprFomMapper (defined in rprFomMapper.h) – a DtFomMapper that self-registers mappings for RPR FOM classes, attributes and parameters.

The DtRprFomMapper constructor takes an optional version argument that indicates which version of the RPR FOM you want to use. For currently supported versions, please see VR-Link Release Notes.

For example, to tell VR-Link to use a FOM Mapper configured for RPR FOM version 2.0, draft 17, do the following:

DtExerciseConn conn("VR-Link", "MyAppName", new DtRprFomMapper(2.0017));
Because DtRprFomMapper contains information about all RPR FOM classes, attributes, and parameters, using it within your application can make your executable fairly large. To help alleviate this problem, we have created an alternate FOM Mapper called DtSimpleRprFomMapper (defined in simRprFomMap.h). DtSimpleRprFomMapper has mappings for only a subset of the RPR FOM, those classes that are needed by VR-Link's examples and other MAK products such as the MAK Data Logger and VR-Forces:

BaseEntity and all of its many subclasses
EmbeddedSystem.EmitterSystem
EmitterBeam and its subclasses
WeaponFire
MunitionDetonation
Collision
ViewControl
LgrControl.
If you are using only these classes, passing an instance of DtSimpleRprFomMapper to your DtExerciseConn constructor instead of the default DtRprFomMapper will significantly reduce executable size.

If you are using just a few additional classes, you can create a DtSimpleRprFomMapper, and manually add mappings for the other classes that you need.

6.8.6 Deriving Your Own DtFomMapper
One way that you might configure your DtFomMapper, is to create a subclass of DtFomMapper that self-registers the desired mapping information, and tell the DtExerciseConn to use an instance of your subclass. (For more information, please see 6.8 - Choosing a DtFomMapper.) This is a way to group your configuration code all in one place. In fact, this is how VR-Link uses the DtRprFomMapper class for the RPR FOM.

When you create a DtFomMapper subclass, you should usually derive from DtEmptyFomMapper, rather than directly from DtFomMapper. DtEmptyFomMapper initializes all factories and lists for you, so that you only need to add mappings within your subclass.

Because we wanted to allow the possibility of creating a DtFomMapper before a DtExerciseConn (and passing the DtFomMapper to the DtExerciseConn), the DtFomMapper constructor does not take a DtExerciseConn as an argument. However, a DtFomMapper needs a DtExerciseConn in order to fully initialize itself.

For this reason, the DtFomMapper constructor does very little. Most initialization occurs within the virtual init() function, which is called by the DtExerciseConn constructor after it has read the FED file. The DtExerciseConn passes a pointer to itself to init(), so that it is available to the DtFomMapper during its real initialization work.

In your derived DtFomMappers, you must break things up this way as well. Your constructor should be basically empty. All of your registration of mapping code belongs in your implementation of the virtual init() function. From within your init() function, call down to the base class's (usually DtEmptyFomMapper's) version of init(). Then perform your specific initialization, such as addition of encoders, decoders, and class mappings. For an example, please see ./examples/myFomMap.

6.9 - VR-Link FOM Mapping and Extension Examples
VR-Link includes examples of how to create FOM Mappers, and of how to extend the top-level API to work with new FOM concepts.

These examples are in several subdirectories of ./examples.

The myFomMap example shows how to create a FOM Mapper for a new FOM, but assumes that the new FOM contains concepts already covered by VR-Link's API (so no extensions are necessary.) It also demonstrates how to put the new FOM Mapper into a shared library that can be loaded by DtExerciseConn, and by MAK applications like MAK Data Logger and VR-Forces. The shared library works with the FED file called MyFomMap.fed, which is in the VR-Link root directory.
The addAttr example demonstrates how to extend the RPR FOM by adding new attributes or parameters to existing classes, particularly when this requires extending VR-Link's API to work with them.
The testInter and testObj examples demonstrate how to add a new interaction or object class to your FOM, including extending VR-Link's API to work with them.
The testSimpInter example demonstrates a method of working with new interaction classes that does not use VR-Link's encoder and decoder classes. This implementation is simpler in some cases, but less extensible and less efficient. We do not provide a walk-through of this example. Please see comments in the source files for details.
All the examples except myFomMap create executables that work with the VrlExtend.fed FED file that is in the VR-Link root directory.

7 - The VR-Link Code Generator
These pages describe how to use the VR-Link Code Generator to extend VR-Link to work with different FOMs.

7.1 - Introduction to the Code Generator
7.2 - Starting the VR-Link Code Generator
7.3 - Code Generator Projects
7.4 - Using the Code Generator
7.5 - The Generated Code

7.1 - Introduction to the Code Generator
Table of Contents
7.1.1 Code Generator Limitations
7.1.2 Installing the VR-Link Code Generator
The VR-Link Code Generator is a tool that can help you extend VR-Link to handle HLA objects and interactions that are not part of its internal object model, that is, objects that are not part of the RPR FOM.

You would do this if you want to use a FOM that is so dissimilar from the RPR FOM that creating a FOM Mapper would not be a sensible option.

Note
The VR-Link Code generator produces code for HLA. It does not extend the protocol-independent API.
VR-Link provides a rich set of objects and interactions to represent simulated data. Implementations of these built-in objects and interactions are provided for DIS and HLA. VR-Link's FOM-agile design means applications written using the built-in object and interaction set can work with different FOM variations, as long as the FOM supports objects and interactions similar to those built into VR-Link. Application developers should always try to use the built-in object set in order to effectively leverage the protocol-independent API. However, there are times when you need an expanded set of objects and interactions. When you need an expanded object set or a completely new object set, you can write the new classes by hand, as described in the FOM agility examples in the VR-Link class documentation, or you can generate them with the VR-Link Code Generator.

When you extend VR-Link, you make several tradeoffs. You now have a much richer set of objects and interactions to work with, however by using these objects and interactions you lose your ability to easily recompile the code to support a new protocol. You do not lose FOM-agility. You can create a FOM Mapper for this new object and interaction set.

The VR-Link Code Generator generates classes based on a FOM definition file (OMT or XML). It produces C++ code, along with a project file or Makefile. You can use this code to build a dynamic library, which you can then build into application code.

The classes generated know which object or interaction they correspond to, so no extra FOM mapping needs to be done. FOM mapping is taken care of inside the generated code. In other words, if you extend VR-Link using the VR-Link Code Generator, you do not have to create separate FOM Mappers.

7.1.1 Code Generator Limitations
The VR-Link Code Generator is designed to assist customers with the extension of VR-Link for HLA (and in an experimental capacity for DIS). FOMs are frequently complex. They may contain many complex data types, and often have object definitions that computers cannot interpret. In many circumstances the Code Generator will not be able to fully generate the code required to extend VR-Link for your FOM. In such cases the Code Generator will produce mostly complete extensions, which require minor hand editing. However, it is possible to produce a FOM that is so complex that major hand editing is required.

MAK wishes to make our Code Generator as complete as possible, however we expect that most FOMs will not fully generate out-of-the-box. We believe that, on average, over 90% of the work will be done automatically with a few attributes requiring hand editing. MAK is committed to improving the Code Generator. If you discover issues with your FOM and would like us to take a look, we would be happy to examine your FOM and provide advice as part of standard support. However, we cannot promise that we can fix all problems, or provide code for incomplete encoders and decoders. Solutions will be provided on a case-by-case basis. Please contact support@mak.com for further details.

7.1.2 Installing the VR-Link Code Generator
The VR-Link Code Generator is installed as part of the VR-Link package in ./bin.

7.2 - Starting the VR-Link Code Generator
Table of Contents
7.2.1 The VR-Link Code Generator Window
You can start the VR-Link Code Generator from the command line, from a script or batch file, or from the Windows Start menu.

If you use a Windows shortcut, the VR-Link Code Generator must be run from the same directory that it is located in, because it looks for code template files relative to that directory.

The command-line syntax is:

./bin/vrlcodegenerator [-p <string>] [-I <string>] [-P <string>] [-F <string>] [-O <string>] [-A] [-G] [–] [-v] [-h]

Where:

-p <string>, –classPrefix <string> Specifies a prefix for generated class names.
-I <string>, –includeDir <string> Specifies the include directory for generated code.
-P <string>, –project <string> Specifies the project file.
-F <string>, –fomDefFile <string> Specifies a FOM definition file (accepted multiple times).
-O <string>, –outputDir <string> Specifies the output directory for generated code.
-A, –all Specifies to generate all objects in the FOM definition.
-G, –generate Performs file generation without opening the GUI (requires FOM definition, output directory, and 'all' flag to be set).
–, –ignore_rest Ignores the rest of the labeled arguments following this flag.
-v, –version Displays version information and exits.
-h, –help Displays usage information and exits.
7.2.1 The VR-Link Code Generator Window
The VR-Link Code Generator window has two panes (Code Generator Window). Objects and interactions contained in the FOM definition file are listed in the left pane. Objects and interactions for which code will be generated are listed in the right pane.

7.3 - Code Generator Projects
Table of Contents
7.3.1 Creating a Project
7.3.2 Loading a Project
7.3.3 Saving a Project
When you use the Code Generator, you work in the context of a project.

7.3.1 Creating a Project
To create a new project:

Choose File -> New Project, or click the New Project button. The New Project File dialog box opens.
Select the directory where you want to store the project and type a name for the project.
Click Save.
7.3.2 Loading a Project
To load a project:

Choose File -> Load Project, or click the Load Project button. The Open Project File dialog box opens.
Select the project you want to load.
Click Open.
7.3.3 Saving a Project
To save a project:

Choose File -> Save Project, or click the Save Project button.

7.4 - Using the Code Generator
Table of Contents
7.4.1 Loading a FOM Definition File
7.4.2 Selecting the Objects and Interactions to Generate
7.4.3 Removing Classes from the Objects to Generate List
7.4.4 Customizing Encoders and Decoders
7.4.5 Configuring Code Generation Preferences
7.4.6 Choosing an Output Directory
7.4.7 Generating Objects and Interactions
This section explains how to load a FOM definition file and generate class and interaction code to support it.

7.4.1 Loading a FOM Definition File
You can load FOM definition files in the XML and OMT formats.

To load a FOM definition file:

Choose File -> Import FOM. The Open File dialog box opens. You can select XML files or OMT files. If you are using HLA Evolved and you need to specify FOM modules, use Import FOM multiple times. If there are any merge errors, they will appear in the footer of the window.
Select the file to open.
Click Open.
7.4.2 Selecting the Objects and Interactions to Generate
The objects and interactions in the FOM definition file are displayed as an expandable tree view (as illustrated below).

To select the objects or interactions that you want to generate:

Select the objects and interactions using one of the following methods:

Click the list item you want to select.
Shift-click to select a series of contiguous items.
Ctrl-click to select multiple non-contiguous items.
To select all items, choose Edit -> Select All.
Click the right-pointing arrow. The selected objects are displayed in the Objects/Interactions to Generate window.


vrlinkcodegenerator.png
Code Generator with Definition File Loaded
When you add an object or interaction to the right pane, all parent objects or interactions are also added to the right pane, since the parent classes must be generated to support the children. No subordinates are moved. Therefore, if, for example, you want to generate code for the objects in the Objects.BaseEntity.PhysicalEntity.Platform category, you cannot just select Platform. You must select all the objects listed under Platform.
The ObjectRoot and InteractionRoot nodes are used to separate objects and interactions in the display. No code is generated for ObjectRoot or InteractionRoot.
7.4.3 Removing Classes from the Objects to Generate List
When you remove a parent from the right pane, all children are removed.

To remove a class from the Objects/Interactions to Generate list:

Select the class in the list.
Click the left-pointing arrow.
7.4.4 Customizing Encoders and Decoders
The Code Generator lets you customize the encoders and decoders for object attributes and interaction parameters before you generate the code.

To customize an object or interaction class's encoders and decoders:

In the Objects/Interactions to Generate pane, double-click the class whose encoders and decoders you want to customize (or right-click and select Customize). The Customize Encoders and Decoders window opens. It lists the attributes for the object or interaction.

In the list of attributes, select the one you want to edit. The default encoder and decoder code is displayed on the Encoding and Decoding tabs.

encodingtab.png
Customize Encoders and Decoders Window
Select the Encoding tab.

Edit the function body as desired. (Only the function body is editable; the header should never change.)

Select the Decoding tab.

Edit the function body as desired.

Click Save Changes.
Note
If you edit an encoder, you should almost always make corresponding changes to the decoder (and vice versa). There may be rare cases where you would not make matching changes, but this is not the normal or expected practice.
When you edit an attribute, an asterisk (*) is added to its name to show that it has changed. The asterisk is removed when you save the changes.
When you save an edited attribute, it is highlighted in green. This lets you know that it no longer uses the default code.
7.4.5 Configuring Code Generation Preferences
You can set the following preferences in the ./data/config/codeGenConfig.xml configuration file, the GUI, or both:

Namespace. You can wrap all generated code within a namespace to avoid name conflicts within VR-Link or application code. For example, if you define a data type named EntityType, it will generate code that will conflict with VR-Link's built in DtEntityType. You can specify a namespace in the configuration file by editing the namespaceName parameter. If you set this value to "" (the default), no namespace is used.
Create Include Directory. If selected, header files are placed in the specified directory relative to the output directory. If not selected, header files are placed in the same location as .cxx files. If header files are placed in an include directory, all .cxx files reference that directory. No changes are made to the vcproj or make files to reference the directory.
Prefix Classnames. Adds the specified prefix to class names. The code generator automatically adds the prefix Dt to generated classes. For example, if an object is is called MyObject, the code generator names the class DtMyObject. However, there may be times when doing so causes a conflict with an existing VR-Link class. Adding a prefix prevents these conflicts. For example, if you specify the prefix Ab, it would create the class DtAbMyObject.
64-bit Linux Makefile. This option generates a makefile for building the generated code on Linux for 64-bit computers.
Generate Examples. This option allows you to generate simple talk and listen examples that demonstrate how an object or interaction is used. You can specify creation of examples in the configuration file with the generateExamples parameter. The default is True.
Map RTIObjectId to DtGlobalObjectDesignator. The RTIObjectId is a common structure that is used to represent HLA object names. VR-Link implements it using the DtGlobalObjectDesignator. Since this structure may appear frequently, you may want to map RTIObjectId to VR-Link's internal DtGlobalObjectDesignator. If the mapping is chosen, RTIObjectId is not generated in the types or net types files. Instead, DtGlobalObjectDesignator is used in the implementation code to encode and decode this type. You can set this preference in the configuration file with the mapRtiObjectIdToGlobalId parameter. The default is True.
Generate #error for undecodable attributes. If set, the Code Generator inserts #error <comment> into any output for which it cannot figure out how to generate the correct code. You will need to replace this #error with valid code that correctly provides the missing functionality. If this option is not set, the code generator inserts an #include <> statement to a stub file, which the code generator will not automatically generate.

The advantage of using an #include file is that subsequent regeneration of code by the code generator will not delete functionality which you have added. This behavior is particularly useful when you are actively developing a FOM.

Include HLA Standard MIM. This option includes the Management Information Model (MIM) FOM elements that are part of the HLA Evolved standard even if they are not found in the loaded FOM.
Generate DIS PDUs. This is an experimental feature and is not supported by MAK. If checked, the Code Generator will try to produce custom DIS PDUs and a protocol-independent API. While the DIS PDUs that are generated will work, they will only work for simple FOM types, and PDUs are neither aligned or padded correctly. However, the DIS output will get you quite far in extending the object model for DIS support.
Save Parse Tree. This feature produces an output file that contains the internal state of the code generator's parse tree after it has parsed the FOM. Send this output to MAK when a problem arises that requires support.
To configure code generation preferences:

Choose Configuration -> Preferences. The Preferences dialog box opens.

codegenprefs.png
Preferences Dialog Box
To specify a namespace, select Use Namespace and type a name for the namespace.
To specify any of the other options, select the relevant check box.
Click OK.
7.4.6 Choosing an Output Directory
You must tell the code generator where to write its output. If you do not specify an output directory using this procedure, the first time you generate code you are prompted for an output directory. Thereafter, the code generator continues to use that output directory until you tell it to use a different one.

To specify an output directory:

Choose Configuration -> Choose Output Directory. A selection window opens.
Select the output directory.
Click Select Folder.
7.4.7 Generating Objects and Interactions
To generate the code, choose Build -> Generate, or click the Generate button.

7.5 - The Generated Code
Table of Contents
7.5.1 Enumerations
7.5.2 Data Types
7.5.3 Objects and Interactions
7.5.4 Project Files and Makefiles
7.5.5 Attributes and Types that Cannot be Decoded and Generated
The VR-Link Code Generator generates files containing all the enumerations, data types, net types, and classes that implement the publishing and subscribing of the objects and interactions contained within the FOM definition file.

7.5.1 Enumerations
An enumerations file is generated from the enumerated data types in the OMT or XML file. The file is named FomNameEnum.h, where FomName is the name of the FOM for the definition file you loaded. The size of the enumeration over the network is determined based on the type of definition file loaded, as follows:

If you load an XML file, the size is determined by its representation in the XML file.
If you load an OMT file, if the enumeration name ends in EnumX, where X is the size of the enumeration, the code generator uses X as the enumeration size. For example, the RPR-FOM contains an enumeration called ActionEnum32. The size for this enumeration would be 32 bits. If the enumeration is not specified in this format, it is interpreted as 32 bits in size.
7.5.2 Data Types
The VR-Link Code Generator generates files to implement complex data types and their network types. These files are named FomNameTypes.h or .cxx, and FomNameNetTypes.h or .cxx, respectively. If the definition file is an OMT file, these types are generated from the complex data types. If the definition file is an XML file, these types are generated from the combination of simpleDataTypes, arrayDataTypes, fixedRecordDataTypes, and variantRecordDataTypes.

New data types that are used in the object or interaction implementation files are generated. Any components of these types with dynamic (+) cardinality, are generated using STL vectors.

7.5.3 Objects and Interactions
For each object, a DtStateRepository, DtObjectPublisher, DtReflectedObject, DtReflected-ObjectList, DtHlaStateEncoder, and DtHlaStateDecoder is created. For each interaction, a DtInteraction, DtInteractionEncoder, and DtInteractionDecoder is created. Each interaction, publisher, and reflected list knows which FOM object or interaction it corresponds to, so no FOM mapping needs to be done. After code is generated, all you need to do to send or receive an object is instantiate the correct publisher or reflected list. Similarly, to send or receive an interaction, send the appropriate interaction or add a callback to the appropriate interaction. All encoding and decoding is built into the object and interaction classes.

7.5.4 Project Files and Makefiles
Windows project files and UNIX Makefiles are generated with the code. This allows you to build a dynamic library that you can link into application code to incorporate the FOM extensions generated. To build a library, set the environment variables VRLINK_DIR and RTI_DIR to the VR-Link and RTI directories, respectively.

7.5.5 Attributes and Types that Cannot be Decoded and Generated
There are a few instances in which the code generator will not be able to properly generate encoding or decoding of attributes or complex data types, as follows:

If a complex data type contains more than one component of dynamic cardinality, the code generator cannot generate code to decode this. This is because it cannot determine the size of the two variable length pieces of data.
If an attribute or complex data type contains a component of variable size data, which is also of variable size, the code generator cannot generate code.
If the complex data type contains a variant record, the code generator will try to write the code that encodes or decodes it. You should consider the resulting code to be a guideline. The code is surrounded by #if 0, so that it will not be compiled accidentally, and a compiler error will be injected.
In all cases, when you compile, #error is injected to bring attention to the potential problem.

8 - The DIS Specific Interface
VR-Link's protocol-independent interface provides the functionality most simulations need to interact with a DIS exercise.

However, some applications need greater control over DIS parameters. These pages describe VR-Link's DIS-specific interface.

8.1 - Working with PDUs
8.2 - Working with Non-Standard PDUs
8.3 - Configuring Your Connection to the DIS Network
8.4 - Intercepting Incoming Entity State PDUs
8.5 - Setting Different Heartbeats in DIS 7

8.1 - Working with PDUs
Table of Contents
8.1.1 Sending PDUs
8.1.2 Receiving PDUs
8.1.2.1 More Control Over Receiving PDUs
8.1.2.2 Using the netRead() Function
8.1.2.3 Using the readUntil() Function
8.1.3 Inspecting and Setting Data in a PDU Header
8.1.4 Getting a PDU's Network Representation
8.1.5 DtPdu Constructors
8.1.5.1 Constructing a Blank PDU
8.1.5.2 PDU Header Information
8.1.5.3 Constructing a PDU from a Network Representation
8.1.6 DtPduFactory
8.1.7 Using External Buffers in a PDU Class
8.1.8 Copying PDUs
8.1.9 Getting an Object ID
Protocol Data Units (PDUs) are the mechanism through which DIS applications send data.

VR-Link's DtPdu class (defined in pdu.h) is used to represent DIS PDUs. DtPdu is an abstract base class. All PDU classes are derived from DtPdu. Every interaction supported by VR-Link has an interaction PDU. For example fire interactions are represented by DtFirePdu. Interaction PDUs that have HLA counterparts are derived from DtInteraction, an essentially empty class, which is in turn derived from DtPdu. We have provided typedefs so that you can refer to, for example, a DtFirePdu as a DtFireInteraction in protocol-independent code.

All DIS 4, 5, and 6 PDUs have PDU classes implemented in VR-Link. Since there are nearly 70 PDUs, we do not describe all of their inspectors and mutators in this manual.

The derived PDU classes provide mutator and inspector functions to set and examine the values of PDU fields. Header information is accessed through DtPdu member functions. In general, an inspector function has the same names as the field being inspected, and returns the value it is inspecting, for example DtEntityStatePdu::entityType(). Mutator functions have the same names, preceded by the word "set", for example, DtEntityStatePdu::setEntityType().

Please see the header files for the exact prototypes of all PDU class member functions.

8.1.1 Sending PDUs
The procedure for sending a PDU is identical to the procedure for sending interactions, described in 4.3.1 Sending Interactions. This section contains additional DIS-specific information.

You send PDUs using the DtExerciseConn::send() or DtExerciseConn::sendStamped() functions. The sendStamped() member function sends a copy of the PDU that has the exercise ID and timestamp fields in the PDU header set to the DtExerciseConn's exercise ID, and the current time. The send() member function leaves the PDU header unmodified.

The following example shows how to create and send a Transmitter PDU:

DtExerciseConn exchange(...);
...
// Create a DtTransmitterPdu
DtTransmitterPdu pdu;
// Fill the PDU with data
pdu.setEntityId(DtEntityIdentifier(1,2,3));
pdu.setRadioId(4);
pdu.setTransmitState(DtOn);
...
// Send to the exercise
exConn.sendStamped(pdu);
Normally, send() and sendStamped() send the PDU to the DtExerciseConn's default destination IP address. (For details, please see 4.2.2 Creating an Exercise Connection for DIS.) However, the functions have an optional argument that specifies a different destination address. For example, to send a PDU to the machine with address 207.86.232.1, use:

DtInetAddr("207.86.232.1");
exConn.sendStamped(pdu, &addr);
Note
Applications usually send interaction PDUs as described in this section. They usually use DtEntityPublisher to manage the sending of entity state PDUs.
8.1.2 Receiving PDUs
Applications handle incoming PDUs through callbacks. The process for receiving PDUs is virtually identical to that described in 4.3.2 Receiving Interactions. This section has additional DIS-specific information.

As described in the 4 - The Protocol Independent Interface, a callback is registered with VR-Link using a PDU class's static addCallback() function, and within the callback function, you can use the PDU class's inspector functions to examine the fields of the PDU.

Note
The DIS version of DtExerciseConn has callback registration and unregistration functions called addPduCallback() and removePduCallback(). However, these functions are meant to be used only by a PDU class's static addCallback() function, and not directly by application code. If an application uses the DtExerciseConn functions directly, then the PDU class never gets registered with the DtPduFactory (this occurs within a PDU class's addCallback() function), and VR-Link will not be able to correctly create instances of the class to pass to your callback functions. For more information, please see 8.1.6 DtPduFactory.
8.1.2.1 More Control Over Receiving PDUs
Most applications use VR-Link's callback mechanism to handle incoming PDUs, leaving the job of actually reading the PDUs and dispatching them to the callbacks to DtExerciseConn::drainInput(). However, to give you more flexibility and control over reading PDUs from the network, DtExerciseConn provides access to the functions used by drainInput().

The drainInput() function works by repeatedly calling readAndProcess(). The readAndProcess() function tries to read a single PDU from the network using netRead(), then passes the PDU to processPdu(), from which all callbacks are invoked. Application code can use any of these functions instead of calling drainInput().

8.1.2.2 Using the netRead() Function
The netRead() function tries to read a packet from the network, constructs an instance of a PDU class from the network representation, and returns it. If you use netRead() directly, note the following considerations:

For efficiency reasons, successive calls to netRead() return DtPdus that all use the same buffer for their network representations. Applications must delete the DtPdu returned by netRead() before making another call to netRead(). Otherwise, the previous DtPdus are corrupted. Using readAndProcess() or drainInput() ensures that each DtPdu is deleted before the next call to netRead(), which is why it is safer to use these two functions.
Because PDU filtering based on PDU kind is done at the DtInetSocket level (before the packets get to netRead()), if filtering is enabled, netRead() returns only those kinds of PDUs for which interest has been registered. If you are using netRead(), you should either turn filtering off with DtExerciseConn::disableFiltering(), or use DtExerciseConn::addInterestInPduKind() to explicitly register interest in the kinds of PDUs you want to receive.
When a typical application calls a PDU's addCallback() function, the PDU class registers itself with DtExerciseConn. Registration allows DtExerciseConn to know which type of derived DtPdu to create to represent an incoming PDU of a particular kind. If you are using netRead() and not using addCallBack(), make sure that all PDU classes you want to use are registered with DtPduFactory. For more information, please see 8.1.6 DtPduFactory.
The optional return code argument to netRead() is a pointer to a return code that is set depending on the results of the netRead() operation as follows:

If a PDU was successfully read, retCode is set to DtNET_READ_SUCCESS. If there are no PDUs to be read, retCode is set to DtNET_READ_NO_PACKETS, and NULL is returned.
If data is read, but it is not a PDU of the correct DIS version, DtNET_READ_BAD_PACKET is indicated.
If the PDU length field conflicts with the actual size of the packet, the packet is rejected with status DtNET_READ_SIZE_MISMATCH.
So, an application can use netRead() as follows:

DtExerciseConn exConn(...);
...
int retCode;
while (1)
{
   DtPdu* pdu = exConn.netRead(&retCode);
   if (retCode == DtNET_READ_SUCCESS)
   {
      // do something with the PDU
      ...
      delete pdu;
   }
}
8.1.2.3 Using the readUntil() Function
The readUntil() function is similar to drainInput() in that it repeatedly reads and processes PDUs. It is different in that it returns when the predicate() function returns true when called on the PDU being processed, or after timeout seconds, whichever happens first. If timeout seconds elapse, it returns DtOtherPduKind. Otherwise, it returns the kind of the PDU that caused the predicate() function to return true. You must provide the predicate() function. It has the following signature:

int predicate(DtPdu *pdu, void *arg);
readUntil()'s signature is as follows:

DtPduKind readUntil(DtPredicate predicate, void* arg, 
DtTime timeout, DtTime sleepTime);
The arg argument passed to readUntil() is passed as the arg argument to predicate() each time it is called.

If no PDU is available to be read, then readUntil() sleeps for sleepTime seconds before polling the socket again. A timeout less than 0 causes readUntil() to poll continuously, without sleeping.

8.1.3 Inspecting and Setting Data in a PDU Header
The DtPdu class has functions to inspect and set the data in a DIS PDU's header. Other fields of the various PDUs are accessed through member functions of the classes derived from DtPdu.

The following DtPdu member functions return the values of their respective fields in the PDU's header:

protocolVersion()
exerciseId()
kind()
protocolFamily()
length().
The DtPduKind and DtProtocolFamily enumerations are in disEnums.h.

The following table describes other functions for setting and returning data.

DtPdu Member Functions
Function	Description
timeStamp()	Returns a floating point number representing the time (in seconds past the hour) that is encoded in the PDU’s time stamp.
timeStampType()	Returns either DtTimeStampRelative or DtTimeStampAbsolute, depending on the type of the PDU’s timestamp.
setExerciseId()	Sets the value of PDU header’s exercise ID field.
setTimeStamp()	Sets the PDU’s timestamp to time modulo 3600, and the timestamp type to relOrAbs. Time is the time in seconds at which the PDU’s data is to be considered valid. relOrAbs</zargumen> must be either DtTimeStampRelative or DtTimeStampAbsolute. Default: DtTimeStampRelative.
setVersion()	Sets the value of the Protocol Version field.
print()	Prints the entire contents of a PDU in human readable form, including header and data, by calling printHeader() followed by printData(). This is the function used by the netdump utility to print the contents of PDUs. The printHeader() function prints the information contained in the PDU’s header, while printData() is a virtual function that prints the data below the header. The base class version of printData() prints the data in hexadecimal format.
Other header information is set at the time the DtPdu is constructed, and cannot be set later. For details, please see 8.1.5 DtPdu Constructors.

8.1.4 Getting a PDU's Network Representation
DtPdu::packet() returns a pointer to a buffer containing the network representation of the PDU – the exact bytes that would be sent onto the network if you were to send a DtPdu at any given time. This is a pointer to an internal buffer that, in most circumstances, you should not try to modify. Use member functions to set values for particular fields.

However, if you want to directly change the data that will go out to the network, you can modify a network representation. If you do so, it is your responsibility to keep the data consistent and to ensure that the buffer represents a valid PDU.

Note
This will only work for those DtPdu classes that store their current data in their network representation buffer, (as opposed to storing it in some other representation and merely converting to network representation when packet() is called). While this has been the chosen implementation for all PDU classes so far, we might choose other implementations in the future.
8.1.5 DtPdu Constructors
Since DtPdu is an abstract class, you cannot directly create an instance of a DtPdu. You can only create instances of classes derived from DtPdu.

All PDU classes have at least two constructors, a blank PDU constructor, and a from-network-representation constructor.

8.1.5.1 Constructing a Blank PDU
The blank PDU constructor constructs a blank, minimal PDU. By minimal, we mean that for variable length PDUs the size is equal to the smallest size that a PDU of that type can legally have. For example, a DtDataPdu created with the blank PDU constructor has zero fixed datum fields and zero variable datum fields; a DtEntityStatePdu created with the blank PDU constructor contains zero articulated parts. By blank, we mean that all bytes of the PDU below the header typically contain zeros (although in some cases other values more accurately represent the concept of a field being blank).

8.1.5.2 PDU Header Information
When a blank PDU is constructed, the protocol version is set to the value of the VR-Link global variable DtProtocolVersionToSend, (declared in pdu.h). See DIS Versions for a list of version numbers.

PDU kind and protocol family depend on what type of PDU class you are creating (based on the value returned by the virtual function internalGetPduKind(), which must be defined for each derived PDU class). The length is the PDU's minimal length, as defined above. The exerciseId and time stamp are zero.

There is an optional buffer argument to the blank PDU constructor. In most cases, you can ignore this argument and use the default, DtUSE_INTERNAL_BUFFER. Blank DtPdu's are constructed as follows:

DtFirePdu pdu();
or:

DtFirePdu pdu;
Alternate uses of the buffer argument are outlined in 8.1.7 Using External Buffers in a PDU Class.

The blank PDU constructor is typically used when creating PDUs that you are sending. After creating the PDU, you can use its member functions to set the various data, then pass it to DtExerciseConn::sendStamped() for sending.

8.1.5.3 Constructing a PDU from a Network Representation
The from-network-representation constructor takes a pointer to a network representation of a PDU as an argument, and constructs a DtPdu object, which represents this PDU. By network representation, we mean a buffer containing the exact bytes that would be used to represent the PDU on the network.

It is rare that an application will need to directly use the from-network-representation constructor for a DtPdu. It is most commonly used only by a DtPduFactory, which is used by DtExerciseConn after receiving a packet from the network in order to construct the PDU class object that is passed to application callbacks.

Like the blank PDU constructor, the from-network-representation PDU class constructor has an optional buffer argument. This argument is used in the same way as the buffer argument to the blank PDU constructor, and is discussed in 8.1.7 Using External Buffers in a PDU Class.

Each of the PDU class from-network-representation constructors requires a network representation of that type of PDU as an argument. For instance, the DtFirePdu constructor specifically requires a DtNetFirePdu.

When constructing a DtPdu from a network representation through a PDU class constructor, the argument passed must be a valid network representation of a PDU. You can use the status() member function to determine whether a DtPdu represents valid data after construction. If status() returns DtSTATUS_OK, it represents valid data. Otherwise, results of using the DtPdu are undefined. The meaning of the value returned by status() depends on the type of PDU, and is meant to give some indication of why the PDU representation is invalid.

Currently, status is not verified by all DtPdu constructors. Therefore, a status of DtSTATUS_OK does not necessarily mean that a PDU is valid. However, a status other than that means that the PDU is not valid.

To construct a DtPdu object from a network representation of a PDU whose type you do not know, you can use the DtPduFactory::createPdu() member function (defined in pduFactory.h).

8.1.6 DtPduFactory
A DtPduFactory implements a kind of "virtual construction", by maintaining a table of associations between PDU kinds and functions that create a corresponding PDU class object.

The createPdu() function checks the PDU kind in the packet, then passes it and the buffer argument to the right creator function from the table. The creator in turn, is just a wrapper around the appropriate PDU class from-network-representation constructor (a constructor itself cannot be added to a table). A pointer to the newly constructed object is returned by createPdu().

If the PDU kind in a packet does not have an individual PDU class implemented (that is, there is no creator registered with the DtPduFactory for the PDU kind), a DtUnknownPdu is created. For more information, please see 8.2.1 Using DtUnknownPdu.

You can use DtExerciseConn::pduFactory() to get a pointer to the PDU factory that a DtExerciseConn uses to create PDU class objects.

Given a buffer containing the network representation of a PDU (perhaps you read it from a file), you can use this DtPduFactory to construct the right type of PDU class as follows:

DtExerciseConn exConn(...);
...
// buffer contains the network representation of some PDU
char *buffer = ...;
// Grab a pointer to our DtExerciseConn's DtPduFactory
DtPduFactory* fact = exConn.pduFactory();
// Cast the buffer to a DtNetPacket* before passing it to
// createPdu to indicate you are treating it as the network
// representation of a PDU.
DtPdu* pdu = fact->createPdu((DtNetPacket*) buffer);
The createPdu() function rejects packets (returns NULL) that have a protocol version less than DtProtocolVersionToRecvMin or greater than DtProtocolVersionToRecvMax. These are global variables declared in pdu.h. They default to 4 and 6 respectively. See DIS Versions for a list of version numbers.

By default, a DtExerciseConn creates an empty DtPduFactory, one that is not aware of any associations between PDU kinds and PDU classes. However, when you call a PDU class's addCallback() function, that class registers itself with the exercise connection's PDU factory. If you are using DtPduFactory, and are not using VR-Link's PDU callback mechanism, you must register creator functions with the DtPduFactory for all PDU classes you might want to work with.

Each PDU class has a static member function called create(), which can serve as that PDU's creator function. These creator functions have the following signature:

DtPdu *create(const DtNetPacket *initial,
DtBufferPtr buffer = DtUSE_INTERNAL_BUFFER);
So, for example, to change a DtExerciseConn's DtPduFactory so that it will create a DtEntityStatePdu to represent PDU kind number 10, you can do this:

DtExerciseConn exConn(...);
...
exConn.pduFactory()->addCreator(DtPduKind(10), DtEntityStatePdu::create);
A NULL creator function can be added for a PDU kind to indicate that there is no PDU class for that kind and DtUnknownPdu should be used instead.

8.1.7 Using External Buffers in a PDU Class
Each DtPdu object stores a network representation of the PDU it represents. It is a pointer to this network representation that is returned by packet(). Normally, the memory used for this network representation is allocated internally by the PDU class constructor and deleted by the destructor.

In some cases, you might want the DtPdu class to use a specific area of memory for storage of its network representation (for example, memory from the stack, or from a shared memory pool). For this purpose, all PDU class constructors have an optional buffer argument. You can cast a pointer to a particular area of memory to a DtBufferPtr and pass it as the buffer argument to indicate that a DtPdu should store its network representation there:

char buffer[144];
// construct blank PDU, but use buffer to store network
// representation
DtEntityStatePdu pdu(DtBufferPtr(buffer)); 
However, the most common reason why you would want to have a DtPdu use an external buffer for storage of its network representation is increased efficiency. When constructing a DtPdu from a network representation of a PDU, if you specify that the memory already occupied by the network representation be used by the PDU to store its network representation, a buffer copy may be avoided, for example:

DtNetFirePdu* netPacket = ......;
DtFirePdu(netPacket, DtBufferPtr(netPacket)); 
In fact, this is what DtExerciseConn does when it creates a PDU class object. It reads a packet from the network into a buffer, then instructs the PDU class object to use this buffer for its network representation. The data does not need to be copied into a buffer internal to the DtPdu.

When you pass a pointer to external memory to the blank DtPdu constructor, keep the following considerations in mind:

It is your responsibility to insure that this external buffer is large enough to accommodate the largest network representation that this particular DtPdu object will need.
It is your responsibility to insure that the lifetime of the buffer memory extends for the lifetime of the DtPdu.
Once you pass a buffer pointer to a DtPdu constructor, it belongs to the DtPdu object for the duration of its lifetime. Modifying the buffer will result in undefined behavior when later using the DtPdu's mutator or inspector functions.
This memory will not be freed by the DtPdu object; since it was allocated by the application, it is the application's responsibility to free it.
8.1.8 Copying PDUs
DtPdu has the copy constructor and assignment operator overloaded. You can copy data as follows:

DtPdu pdu1, pdu2;
pdu1 = pdu2;
pdu1 now contains the same data as pdu2. The two objects do not, however, share any data objects.

Classes derived from DtPdu do not usually have copy constructors or assignment operators. To ensure that data is copied correctly from one PDU to another, you must use the network representation of the PDU, for example:

DtFirePdu pdu1;
DtFirePdu pdu2((const DtNetFirePdu*)pdu1.netRep());
As with the standard PDU class constructors, the DtPdu constructor has an optional buffer argument. (For more information, please see 8.1.7 Using External Buffers in a PDU Class.) To copy a DtPdu using a buffer, do the following:

DtPdu pdu1;
DtPdu pdu2(pdu1, buffer);
To copy a PDU derived from DtPdu using an external buffer, do the following:

DtFirePdu pdu1;
int sz = pdu1.length();
char* bfr = new char[sz];
DtFirePdu pdu2((const DtNetFirePdu*)pdu1.netRep(), (DtBufferPtr)bfr);
8.1.9 Getting an Object ID
DtExerciseConn has a DIS-specific function – nextId(). The nextId() member function obtains an ID for use with an object that you are simulating. It returns an object of the type DtObjectId (defined in objectId.h). You can choose your own entity IDs rather than obtain them using nextId().

DtObjectId is typedef-ed to DtEntityIdentifier (defined in hostStructs.h) – a class that represents the DIS identification triplet of site ID, application number, and entity number. DtObjectID is used rather than DtEntityIdentifier or RTI::ObjectID() when we want to refer to an identifier in a protocol-independent fashion.

The DIS version returns an identifier consisting of the DtExerciseConn's site and host, and an entity number that is one greater than the one returned in the previous call to nextId(). There is no guarantee that the entity ID is unique in the DIS exercise.

8.2 - Working with Non-Standard PDUs
Table of Contents
8.2.1 Using DtUnknownPdu
8.2.2 Deriving Classes from DtPdu
Many VR-Link users need to use PDUs that are not part of the DIS standard, and thus not implemented in VR-Link.

However, VR-Link can work with user-defined PDUs just like it treats PDUs that are implemented in VR-Link.

There are two ways to work with user-defined PDUs:

Use DtUnknownPdu to represent your type of PDU
Derive a class from DtPdu.
Using DtUnknownPdu is sometimes easier for simple PDUs that can be represented by C-style structures. In essence, the DtUnknownPdu just serves as a wrapper around such a structure. Deriving your own DtPdu class requires some extra work up front, but it is easier to use in your application, especially if it is a variable-length PDU, or one that has several variants.

8.2.1 Using DtUnknownPdu
You can use a DtUnknownPdu (defined in unknownPdu.h) to represent a PDU for which there is no PDU class. This includes new or experimental PDUs that you develop.

To send a PDU using the DtUnknownPdu class:

Fill a buffer with the exact bytes you want to send on the network (probably by filling in a C-structure). Make sure this structure includes the DIS PDU header whose structure is defined in pduHeader.h (in ./include/packets).

By using our "Net" types, such as DtNetInt32 (defined in vlNetTypes.h), you insure platform independence. When you are on little endian machines, byte swapping is performed when assigning to a Net type, and when a Net type is implicitly cast to a native type.

Note
When VR-Link sets the network byte order of data, it tries to use operating system calls to byte-swap. On some operating systems, these calls may be atomic processor instructions or NO-OPs.
Pass this network representation to the DtUnknownPdu from-network-representation constructor.
Send the PDU using DtExerciseConn::sendStamped().
For example, suppose you create a Test PDU with two fields called a and b, and choose PDU kind number 220 to represent this PDU:

// Define the structure of your network representation
typedef struct NetTestPdu
{
   DtNetPduHeader header;
   DtNetInt32 a;
   DtNetInt32 b;
} NetTestPdu;
// Create an instance of the structure and fill in the net 
// representation
NetTestPdu aNetPdu;
aNetPdu.header.version = 5;
aNetPdu.header.DtExercise = 1;
aNetPdu.header.DtLength = sizeof(NetTestPdu);
aNetPdu.header.DtKind = 220
...
aNetPdu.a = 10;
aNetPdu.b = 11;
// Create a DtUnknownPdu from this network representation
DtUnknownPdu pdu((DtNetPduHeader*) &aNetPdu);
// Send the PDU as you normally would
exConn.sendStamped(pdu);
On the receiving side, DtUnknownPdu does not have addCallback() or removeCallback() functions, since a DtUnknownPdu does not know what PDU kind you are interested in. But you can still register callbacks with the DtExerciseConn on a particular PDU kind, in our case 220. Note the cast of the integer 220 to a DtPduKind enum here.

exConn.addPduCallback(DtPduKind(220), testCallback, NULL);
Since 220 is not a PDU kind that VR-Link knows about, when it receives a packet of that kind, it creates a DtUnknownPdu and passes that to your callback function. You can cast the DtPdu* to a DtUnknownPdu* within your callback if you want to, but it is not necessary, since the only useful thing you can do with a DtUnknownPdu is get its network representation, which is done through a DtPdu member function.

void testCallback(DtPdu* pdu, void *usr)
{
   // Get the PDU's network representation, and cast it to a 
   // NetTestPdu structure, so that you can access the data
   NetTestPdu* aNetPdu = pdu->packet();
   int a = aNetPdu->a;
   int b = aNetPdu->b;
}
8.2.2 Deriving Classes from DtPdu
VR-Link's DtExerciseConn::send() and DtExerciseConn::sendStamped() functions can send any type of PDU, as long as the object passed to it is of a type derived from DtPdu. So, to send user-defined PDUs, you can write a derived class, after which you can immediately use your derived class with these functions.

When DtExerciseConn receives a packet from the network, it creates an object of the appropriate class derived from DtPdu, based on the PDU type in the packet. For instance, a DtEntityStatePdu is created if a packet representing an Entity State PDU is received. For this reason, VR-Link needs to know that your derived class exists. Registration of your class with VR-Link is usually done in your PDU class's addCallback() function.

The testPdu example creates a variable length PDU. The TestPdu class represents a hypothetical variable-length "Test PDU" – one that has three fields: an integer named "a", a variable-length array of integers named "b" whose cardinality is the value of "a", and a float called c. The code for this example is in ./examples/extend/testPdu. The class documentation contains a complete description of the example.

8.3 - Configuring Your Connection to the DIS Network
Table of Contents
8.3.1 DtExerciseConn Constructors
8.3.1.1 Standard Constructor
8.3.1.2 A Constructor that Takes A Destination Address
8.3.1.3 Using A Secondary Network Device
8.3.1.4 A Constructor that Takes A Pointer to A DtInetSocket
8.3.2 Configuring a DtDisSocket
8.3.3 Using Asynchronous IO
8.3.4 Subscribing to Multicast Addresses
8.3.5 Filtering PDUs
8.3.6 Bundling and Unbundling PDU Packets
8.3.7 Sending Packets Using DtInetSocket
8.3.8 Receiving Packets Using DtInetSocket
As described in 4.2 - Connecting to Exercises, a DtExerciseConn serves as an application's connection to a DIS or HLA exercise.

The DIS version is defined in dExerciseConn.h.

A DIS DtExerciseConn uses a DtInetSocket (defined in vlInetSocket.h) as its low-level interface to a virtual network. DtInetSocket is an abstract class whose virtual functions send() and recv(), along with their variants (described in the header file), allow you to send and receive a packet of data among applications without regard to the actual communication mechanism used. Subclasses of DtInetSocket implement different methods of communication and take different configuration parameters.

8.3.1 DtExerciseConn Constructors
Two of DtExerciseConn's constructors create a DtInetSocket based on their arguments; the other takes an existing DtInetSocket as an argument.

All constructors take an exercise ID as an argument. The exercise ID is copied into the header of outgoing PDUs when sendStamped() is used, and is used for filtering incoming PDUs as well. Only those PDUs on the matching exercise are passed to the application by the exercise connection. If a DtExerciseConn's exercise ID is set to zero, it reads and processes PDUs from all exercises. However, PDUs should never be sent to exercise zero, so exercise ID zero should usually be used only in applications that are listen-only. Once a DtExerciseConn is constructed, you can change or examine the current exercise ID with setExerciseId() and exerciseId().

8.3.1.1 Standard Constructor
The standard DtExerciseConn constructor (described in 4.2.2 Creating an Exercise Connection for DIS) creates a DtDisSocket (vlDisSocket.h) to communicate directly to the network. The DtExerciseConn receives any unicast or broadcast packets destined for the computer on the specified port, and by default, sends packets to the broadcast address of the computer's primary network interface (when no address is specified in a call to send() or sendStamped()).

8.3.1.2 A Constructor that Takes A Destination Address
The second DtExerciseConn constructor is similar to the first, but in addition to the four arguments expected by the standard constructor, it takes a destination address. The destination address is used as the default IP address to which outgoing packets are sent. It can be a unicast, multicast, or broadcast address.

For example, to indicate that packets should be sent only to the computer with the address 207.86.232.1, do this:

DtExerciseConn(3000, DtInetAddr("207.86.232.1"));
In this case, we will still receive packets destined for our broadcast and unicast addresses.

8.3.1.3 Using A Secondary Network Device
The second constructor is also useful when you want to use a device other than a computer's primary network device. Pass the broadcast address associated with the desired device as the destination address.

Note
The two devices must be on different networks. There is no way for a UDP socket to distinguish between two devices on the same network.
8.3.1.4 A Constructor that Takes A Pointer to A DtInetSocket
The third DtExerciseConn constructor takes a pointer to a DtInetSocket, and thus gives you full control of how the socket is created. You can even derive your own type of DtInetSocket and pass an instance of it to a DtExerciseConn. (Perhaps you want to create a SharedMemorySocket.) In this case, the socket is not deleted by the DtExerciseConn object. Because you allocate it, it is your responsibility to delete it. However, you must not delete the DtInetSocket until after the DtExerciseConn has been destroyed.

Please see the following sections for more configuration information. Once a DtExerciseConn is constructed, its socket() member function will return a pointer to the socket it is using.

8.3.2 Configuring a DtDisSocket
The DtDisSocket class is a subclass of DtInetSocket, which can be passed into the DtExerciseConn constructor. It contains features that help to send and receive DIS PDU's.

If you are constructing a DtDisSocket, (vlDisSocket.h), several parameters may be passed in, but the only required parameter is the DtInetEndpoint, which describes the destination address and port of DIS PDU's sent. Other optional parameters are:

The local port to use
The interface to use
The socket flags
A flag that determines whether to open the socket immediately
A flag that determines whether the socket should filter out PDU's sent by itself.
The flags argument is a bitwise OR of several options that are defined in vlInetSocket.h. The default is DtDefaultSockOpts, which is a bitwise OR of DtReadWrite, DtSockOptAllReuse, and DtSockOptNoDelay. This creates a socket that can read and write, can reuse addresses and ports, and has the no-delay option set. Please see the vlInetSocket.h class documentation for the definitions of these flags.

If a DtInetDevice is passed in, the socket binds to that device for reading. This is useful for multi-homed machines if you only want to read DIS PDU's from one network card. For instance, if you have two network cards with the addresses 1.1.1.1, and 192.168.0.1, and you are only interested in receiving PDU's from the 192.168.0.1 network, you can construct the socket as follows:

DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"),
3300);
DtInetDevice deviceToUse(DtInetAddr("192.168.0.1"));
DtDisSocket* sock = 0;
if (deviceToUse.isOk())
{
   sock = new DtDisSocket(endpoint, 0, deviceToUse); 
}
This causes the socket to only read from the 192.168.0.1 interface. If a NULL pointer is passed in, the socket binds to the "any" address, allowing it to receive any PDU's sent to the specified port.

8.3.3 Using Asynchronous IO
VR-Link supports asynchronous IO for DIS. (Asynchronous IO for HLA is handled by the RTI.) A socket with asynchronous IO enabled has all the functionality of DtInetSocket. However, it creates two threads that read and write to the network. The read thread reads packets from the network and places them on a queue. When an application reads a packet from the socket, it reads it from the queue. When an application writes to the network using asynchronous IO, it writes to a queue. The send thread reads the queue and sends packets to the network as soon as possible.

You create a socket that uses asynchronous IO just like you create a DtDisSocket.

The DIS version of DtExerciseConn can use asynchronous IO in either of the following ways:

Pass a socket with asynchronous IO enabled to the constructor, as follows:

// Pass a pointer to the constructor    
DtInetEndpoint endpoint(DtInetProto_UDP, DtInetAddr("192.168.255.255"),
3300);
DtDisSocket *netSocket = new DtDisSocket(endpoint, 0, 0,
(DtDefaultSockOpts | DtAsyncReadWrite));
DtExerciseConn  *exConn = new DtExerciseConn(netSocket, exerciseId, 
siteId, applicationNum );
. . . 
delete exConn;
delete netSocket;
Set the DtExerciseConn's initializer useAsynchIO() member function to true. The default is false:

DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
appInit.setUseAsynchIO(true);
DtExerciseConn exConn(initializer);
Asynchronous IO is not faster, but if your simulation has well separated spikes of network traffic, it can help reduce dropped packets.

8.3.4 Subscribing to Multicast Addresses
DtExerciseConn allows subscription to one or more multicast addresses. Valid multicast addresses are those that lie between 224.0.0.0 and 239.255.255.255, but you should probably not use any that start with 224.0.0, to avoid potential conflict with addresses used by operating systems and network services.

Note
Not all platforms support multicast.
Interest in a particular multicast address is indicated using DtExerciseConn::addInterestInMcastAddr(). When a multicast group is no longer of interest, call subtractInterestInMcastAddr().

Different code modules can add and subtract interest in a particular group independently. As long as the number of calls to addInterest() outnumbers calls to subtractInterest() for a particular group, packets on that multicast address are received.

To send to a particular multicast address, include that address as the destAddr argument to send() or sendStamped().

You do not have to be subscribed to a multicast address to send to it.

If the destination address passed to a DtExerciseConn constructor is a multicast address, you do not need to call addInterest() for that address. You will automatically be subscribed.

Note
On many platforms, multicast subscription works on a per-host basis, rather than on a per-application basis. This means that if you have several applications listening to the same port on the same machine, and one of them subscribes to a particular multicast address, all of the applications will receive packets on that multicast address, even if they did not explicitly subscribe.
If there are several routers on your network between machines that are exchanging PDUs using multicast, you may need to increase the Time To Live (TTL) for outgoing multicast packets, to ensure that the packets are actually forwarded across the routers. You can do this with DtInetUdpSocket::setMcastTtlOption().

8.3.5 Filtering PDUs
A DtExerciseConn can instruct its DtDisSocket to filter out PDUs based on certain criteria. In this way, unwanted PDUs require no processing by the DtExerciseConn.

By default, packets that are not of an expected protocol version and packets whose exercise IDs do not match the exercise ID of the DtExerciseConn are filtered out. Expected protocol versions are those between the values of the global variables DtProtocolVersionToRecvMin and DtProtocolVersionToRecvMax, declared in pdu.h. These parameters default to 4 and 6 respectively. Table 3-1 lists the DIS version numbers.

In addition, the DtExerciseConn maintains a list of all PDU kinds in which it is interested. This includes all PDU kinds on which callbacks have been registered, as well as any PDU kinds in which an interest has been explicitly added using DtExerciseConn::

addInterestInPduKind(). (The subtractInterestInPduKind() function removes interest in a PDU kind.) The DtExerciseConn's DtInetSocket filters out all PDU kinds in which it has no interest. The DtPduKind enumeration is in disEnums.h.

You can turn filtering on and off with the functions DtExerciseConn::disableFiltering() and DtExerciseConn::enableFiltering().

8.3.6 Bundling and Unbundling PDU Packets
VR-Link supports bundling of multiple PDUs into a single network packet, and unbundling of such packets into their constituent PDUs.

Bundling is off by default, but can be turned on using the DtDisSocket::setBundling() member function. Pass to it the desired maximum size for a packet, along with some default values. When bundling is on, a sequence of packets passed to a socket's send member function (for example, from DtExerciseConn::sendStamped()), are concatenated together. The bundle is passed to DtDisSocket::sendTo() whenever a packet would push the bundle size beyond maxSize. A good choice for maxSize is the maximum size of the data portion of an ethernet packet: 1464 bytes. If you are using a networking scheme other than ethernet, use the maximum packet size for that scheme. Bundling is turned off by passing false as the second parameter to setBundling(). For example, to turn on bundling with a max size of 1464 bytes, you can call:

disSocket.setBundling(1464, true, 0, 0, 0, 0);
To turn it off, you can call:

disSocket.setBundling(0, false, 0, 0, 0, 0);
Note
If you turn on bundling, other participants in your simulation must be able to unbundle the packes.
You can force sending of the current bundle with DtDisSocket::flush(). If you are using bundling, call the flush() member function at the end of each simulation frame to ensure that all packets generated during a frame get sent before the next frame begins.

The isBundling() member function returns false if bundling is off, and the getMaxBundleSize() member function returns the maximum bundle size.

Unbundling is enabled by default, but it can be turned on or off by passing 0 or 1 to DtDisSocket::setUnbundling(). With unbundling on, when a packet arrives containing more than one PDU, successive calls to the receive function (the call made by DtExerciseConn:: netRead()) return successive PDUs from the packet. On the next call to receive after the last PDU from a packet has been returned, the first PDU from the next packet is returned.

If unbundling is disabled, but a bundled packet is received, all but the first PDU in the packet is ignored.

8.3.7 Sending Packets Using DtInetSocket
There are several ways to send packets with any DtInetSocket class. The header files of each socket class (vlInetSocket.h, vlInetUdpSocket.h, vlInetTcpSocket.h, and vlDisSocket.h) provide a description of each member function.

To send, the DtExerciseConn class uses either the send() or sendTo() member function of the DtInetSocket, depending on whether an address is passed into the DtExerciseConn::send() member function. The socket's send() member function returns the number of bytes sent, or -1 if the packets cannot be sent. If -1 is returned, the getLastError() or getLastErrorString() member function can be used to query which error was encountered.

Note
DtInetSockets do not know anything about byte swapping or PDU layout (with the exception of some knowledge of PDU header layout used for filtering). The data contained in the buffer passed to DtInetSocket's sending functions are the exact bytes that will go out onto the network.
8.3.8 Receiving Packets Using DtInetSocket
As with sending, there are several ways to receive packets with any DtInetSocket class. Please see the header files and class documentation for a description of each member function.

The DtExerciseConn uses the recv() member function to read the next packet available. The return status can be checked to determine the status of any of the receive calls.

DtInetSockRcv_ERROR is returned if there was an error. getLastError() can be called on the socket to retrieve the error code, or getLastErrorString() can be used to obtain a description of the error.
DtInetSockRcv_NO_PACKET will be returned if nothing was read.
Any value greater than 0 contains the number of bytes that were read.

8.4 - Intercepting Incoming Entity State PDUs
In 4 - The Protocol Independent Interface, we mention that processing incoming state updates for a particular entity must account for the protocol, because the concept of an HLA attribute update is fairly different from the concept of a DIS entity state PDU.

In DIS, there are two ways to intercept incoming entity state PDUs:

Register a callback on entity state PDUs, just as you would on any other kind of PDU.
Override DtReflectedEntity::processEntityState().
When an entity state PDU arrives, it is dispatched to a callback that DtReflectedEntityList registers with the DtExerciseConn. Within this callback, the reflected entity list calls the appropriate DtReflectedEntity's processEntityState() function, depending on the entity ID in the PDU.

DtReflectedEntity's default implementation of this virtual function is to update its own DtEntityStateRepository based on the contents of the PDU. But by subclassing DtReflectedEntity, you can provide an alternate implementation. Your version of this function should probably call down to DtReflectedEntity::processEntityState() to make sure that the entity state repository is properly updated even if there is additional work you want to perform here.

Remember that when subclassing DtReflectedEntity, you must also subclass DtReflectedEntityList so that it knows to create your new type of DtReflectedEntity. For examples of subclassing these two classes, please see 4.6.1 Creating Reflected Entity Lists.

8.5 - Setting Different Heartbeats in DIS 7
DIS 7 lets you set the heartbeat of an object based on its entity type, class type, or whether or not it is moving.

To set the heartbeat for non-moving entities, call setStationaryDfltTimeThreshold() anywhere in your software. For example, to set the heartbeat to 20 seconds, do this:

DtEntityPublisher::setStationaryDfltTimeThreshold(20.0);
To set the heartbeat by entity type, use setEntityTypeDfltTimeThreshold(). For example, to have all air units heartbeat once every second and humans heartbeat every 2 seconds, do this:

DtEntityPublisher::setEntityTypeDfltTimeThreshold(DtPlatform,DtPlatformDomainAir,1.0);
DtEntityPublisher::setEntityTypeDfltTimeThreshold(DtLifeForm,-1,1.0);
To set the heartbeat value by class type, use setClassDfltTimeThreshold(). For example, to tick all IFF objects every 10 seconds and entities every 5:

DtIffPublisher::setClassDfltTimeThreshold(10.0);
DtEntityPublisher::setClassDfltTimeThreshold(5.0);
You can still set a single heartbeat value for every DIS object. By default, this is set to 5 seconds.

DtObjectPublisher::setDfltTimeThreshold(8.0);
You can set multiple heartbeat values to make sure that important units get updated more frequently than less important units. If you wrote all six lines above, you would get stationary entities heartbeating every 20 seconds, moving air units and lifeforms heartbeating at 1 second, and all other moving entities heartbeating at 5 seconds. Non-entities will heartbeat every 8 seconds unless they are IFF objects, which heartbeat every 10 seconds.

You still need to call DtExerciseConnection.tick() to actually send the data over the network. At the very least, you should be ticking at the rate of the smallest heartbeat threshold.

9 - Writing Applications Using the C# API
VR-Link for C# allows C# programmers to access the VR-Link SDK.

9.1 - Introduction to the C# API
9.2 - Adding the VR-Link for C#.dll to Your Project
9.3 - Initializing an Exercise Connection
9.4 - Using the Application Initializer Class
9.5 - Publishing Objects
9.6 - Reflected Objects
9.7 - Callbacks and Interactions

9.1 - Introduction to the C# API
This chapter explains how to develop applications using the VR-Link C# library.

It references the F-18 example, which is in the ./C-sharp/examples, to illustrate the concepts that are introduced. The explanations include example code. However, we recommend that you browse the F-18 project while reviewing this information. If your application involves extending VR-Link for C#, please see Extending VR-Link for C#. It is assumed that you know the C# language.

9.1.1 Build Requirements
VR-Link for C# is built with Microsoft Visual Studio. It uses both the 32 and 64 bit compilers. It is built against the VR-Link version and uses the 32 and 64 bit libraries. It is also built on the .NET Framework. Please see VR-Link Release Notes for the supported versions of Visual Studio and .NET for your version of VR-Link for C#.

9.2 - Adding the VR-Link for C#.dll to Your Project
To use VR-Link for C# in your application you must add vrLinkSharp.dll reference to your project.

To do so:

Right click on your project and select Add Reference.
Select the Browse tab.
Navigate to the ./bin directory inside the root VR-Link install folder.
Select vrLinkSharp.dll from the list.
Add the following using statement to access the C# library:

using makVrl;

9.3 - Initializing an Exercise Connection
To create an exercise connection in VR-Link for C#, you need an exercise connection initializer.

The ExerciseConnectionInitializer class contains one member, the connection type. Since VR-Link for C# is protocol-agile, you must specify the type of connection. This is so that the C# can tell the VR-Link library which exercise connection to initialize. The connection type variable is defined as such:

enum ConnectionType { DIS, HLA13, HLA1516, HLA1516E, WEBLVC };
A connection type must be supplied when constructing an ExerciseConnectionInitializer.

The following classes are derived from the ExerciseConnectionInitializer. There is one for each supported protocol.

DisExerciseConnectionInitializer - DIS
Hla13ExerciseConnectionInitializer - HLA 1.3
Hla1516ExerciseConnectionInitializer - HLA 1516
Hla1516eExerciseConnectionInitializer - HLA Evolved
WebLvcExerciseConnectionInitializer - WebLVC
These initializers contain information specific to their protocols. Once created, an exercise connection can be initialized. They also automatically define the ConnectionType of their parent class. Here is an example for DIS:

DisExerciseConnectionInitializer initializer = new DisExerciseConnectionInitializer();
ExerciseConnection exConn = new ExerciseConnection(initializer);

9.4 - Using the Application Initializer Class
As an alternative to initializing an exercise connection, a simpler way to handle initialization is to use the ApplicationInitializer class.

Create this class to allow your application to handle MAK-supplied command line arguments by default. The ApplicationInitializer parses the command line on creation, searching for a connection type (ConnectionType). To define a connection type, provide a -C or -ConnectionType command with either DIS, HLA13, HLA1516, HLA1516E, or WEBLVC as the value (if no ConnectionType is provided, DIS is the default). Here is an example of launching an application with the ApplicationInitializer:

Talk-Sharp.exe -C HLA13
To see the full list of command line arguments use the -h or -help command to display valid arguments.

You can extend the ApplicationInitializer. The f18Init class is a good example of the possibilities introduced when extending the ApplicationInitializer. See the f18Init.cs file in the f18-Sharp example for reference.

9.5 - Publishing Objects
VR-Link for C# supplies publishers for objects that it defines.

In the F-18 example, we define a VehicleSim class that is used to manipulate the information we publish. To start, a publisher of the right type is required, so we define and initialize that. As you can see, it requires the exercise connection that is being used in the project.

EntityPublisher myEntityPub;
myEntityPub = new EntityPublisher(myExConn);
Our vehicle is an entity type so we define the EntityPublisher. To start to edit the values that the publisher sends, the EntityStateRepository of the publisher must be edited. The VehicleSim class stores a member for the EntityStateRepository (ESR).

EntityStateRepository myESR;
myESR = myEntityPub.esr;
The ESR information that needs to be modified is usually handled in a tick() function. Tick often refers to a defined amount of time between updates. Therefor a tick() function is called every time the threshold is reached. For this reason, the tick() functions require a time that represents the change in time since last call of this function. VehicleSim defines a simTick() function to handle modifying the ESR. Here is a small sample:

public void simTick(double dt)
{
   ...
       //update position
    myPos[i] += (myVel[i] + 0.5 * myAccel[i] * dt) * dt;
    
   ...
    //Convert position to correct format
    myESR.worldPosition = myCoordTrans.coordTrans(myPos);
    ...
    //call publisher tick function
    myEntityPub.tick(dt);
 
}
Notice that you must call the EntityPublisher.tick() function after your ESR has been modified.

9.6 - Reflected Objects
A reflected object is a class used to store information about an object that has been discovered on the exercise connection.

A reflected object list keeps track of multiple reflected objects. The reflected object lists also handle the callbacks associated with discovering, updating, and deleting objects. This means that when an object is published from a source that the VR-Link application can receive information from, the reflected object list is notified and handles the information according to its callback functions. For example, if an object is discovered, the reflected object list stores it. If an object is updated, the refelected object is updated.

In the F-18 example, the ReflectedEntityList is used to store multiple ReflectedEntity types. First, the reflected list is created using the exercise connection defined.

ReflectedEntityList rel = new ReflectedEntityList(exConn);
Now that the ReflectedEntityList is hooked into the exercise connection, we need to make sure the exercise connection is listening to input. To do that we use the drainInput(t) function inside the simulation's main loop. drainInput() takes a double representing the max time between updates. In f18-Sharp:

exConn.drainInput(-1.0);
This used so that the exercise connection is constantly listening to input (negative value).

From this point we have a ReflectedEntityList that will pick up entities that are published on the exercise connection. In the f18-Sharp example, the reflected entity list is used to find the closest entity when firing a projectile. Here is an example of a way to use this information:

static ReflectedEntity nearestEntity(string myObjId,Vector3d geocPos, ReflectedEntityList rel)
{
   ReflectedEntity nearest = null;
   double minDistSqr = 0.0;
   // Loop through the entities in the rel
   foreach (ReflectedEntity re in rel.entities)
   {
      if (re.esr.id == myObjId)
         continue;
        //NOTE: Is world position correct? Does this temp creation work?
        double distSqr = (re.esr.worldPosition - geocPos).LengthSquared;
        if (distSqr < minDistSqr || nearest == null)
        {
            nearest = re;
            minDistSqr = distSqr;
        }
    }
    return nearest;
}

9.7 - Callbacks and Interactions
Interactions are handled differently than objects.

Typically, interactions are created and sent one time, then received and reacted to appropriately. An example of such interaction is the FireMessage. Interactions are denoted as messages in VR-Link for C#. The f18-Sharp example has the ability to fire at other entities, and it does so with fire interactions.

To send a fire interaction (FireMessage), create it and send it with the exercise connection. Here is a snippet from the example:

myFire = new FireMessage();
//Fill out FireMessage here
... 
myFire.worldPosition = ESR.worldPosition;
myFire.velocity = ESR.worldVelocity;
         
...
myExConn.sendMessage(myFire);
This code creates and sends a FireMessage over the exercise connection.

To be able to receive a FireMessage the exercise connection needs to register a callback for receiving it, for example (from the VehicleSim class):

myExConn.addMessageHandler(FireMessage.theName, new MessageDelegate(processFireMessage));
This code uses the addMessageHandler() function. addMessageHandler() takes the name associated with the interaction type and a new MessageDelegate, which is a function to call when the message is received. The name is a static string defined within the message. The delegate is how you handle the interaction. Here is how f18-Sharp handles receiving a FireMessage:

internal void processFireMessage(Message m)
{
    FireMessage fm = m as FireMessage;
    Console.WriteLine("Fire Message received from entity " + fm.firingId + " targeting entity " + fm.targetId + ".");
}

10 - Using Plug-ins to Extend VR-Link for C#
VR-Link programmers can extend the C# API by creating plug-ins.

10.1 - Extending VR-Link for C#
10.2 - Architectural Overview
10.3 - ManagedInterface Class
10.4 - Loading Plug-ins
10.5 - Initializating Connections
10.6 - ManagedInterface Concepts
10.7 - Messages
10.8 - Code Generator
10.9 - Laser Designator Example

10.1 - Extending VR-Link for C#
Table of Contents
10.1.1 Build Requirements
This chapter explains how to develop plug-ins to extend the behavior of VR-Link C# through its C++ SDK.

It assumes that you are familiar with distributed networking concepts and VR-Link (the C++ API). This document also references the example Laser Designator plug-in that is included with the SDK to show how all the concepts covered in this guide are used to extend VR-Link C#.

10.1.1 Build Requirements
Please see VR-Link Release Notes for the compilers and VR-Link versions supported by your version of VR-Link for C#.

10.2 - Architectural Overview
VR-Link C# is composed of several layers.

The bulk of the work is accomplished in a C++ library called ManagedInterface, which we use to manage how information gets pushed to and from C#. Above the C++ ManagedInterface library is a set of C# bindings called ManagedInterfaceCS, which allows the C# application to access the power of VR-Link and ManagedInterface directly from C#. ManagedInterfaceCS communicates with the underlying C++ libraries through a simple message-passing API.

The ManagedInterfaceCS layer is responsible for passing messages between VR-Link C# and VR-Link C++.

For messages coming from DIS/HLA, ManagedInterfaceCS receives messages from VR-Link and stores current state in VR-Link C# reflected objects. It automatically updates objects with the same VR-Link dead-reckoning and smoothing algorithms. Users can extend the built-in message handler to fit the needs of their simulation design. For events (for example, Fire and Detonate), ManagedInterfaceCS provides a mechanism to register callbacks or custom handlers.

For objects owned by the C# application, ManagedInterfaceCS provides a "Publish" component, which is responsible for passing current state across the language boundary to VR-Link. VR-Link then publishes objects to the DIS/HLA network. For events/interactions, ManagedInterfaceCS provides a C# API to fill out and send the appropriate messages.

10.3 - ManagedInterface Class
The ManagedInterface class is a singleton class that provides a centralized location to register message decoders, strategies, and resources used during execution.

It is automatically created during startup and will load any plug-ins.

10.4 - Loading Plug-ins
In order for a VR-Link C# plug-in to be loaded, the DLL must be in the plug-ins directory with the distributed VR-Link C# DLLs and it must export a function with the following name and signature:

extern "C" {
   DLL_EXPORT bool initManagedInterfaceModule( DtManagedInterface* gl);
}


10.5 - Initializating Connections
VR-Link C# is a protocol agile library.

It allows for the protocol specific strategies to be loaded at runtime based on what the user asked for. Since many strategies may rely upon one another for shared resources, a connection initialization procedure is needed.

In an unconnected state, VR-Link C# only has four strategies loaded. These are the protocol-specific initialization strategies. When a connection message is received, the appropriate initialization strategy handles creating the remaining protocol specific strategies that are responsible for handling objects and interactions. Customer created strategies need to register themselves with the appropriate initialization strategy during plug-in loading so they can be executed when a connection is made.

Since the order of initialization is important for dependent strategies, a simple multi-pass initialization step is used to initialize all created strategies during a connection. A number of initialization passes are done to ensure that all strategies are able to create and find any shared resources or other strategies. During each pass, if a strategy is unable to fully initialize due to a missing resource, it will attempt to initialize in the next pass. This process is repeated until all strategies are initialized or until a deadlock is detected. This initialization step fails if there is a circular dependency.

10.6 - ManagedInterface Concepts
Table of Contents
10.6.1 - Strategies
10.6.2 - Resources
10.6.3 - Delegates
10.6.1 - Strategies
Strategies are the modular components within ManagedInterface; they process object state updates and interactions from VR-Link and create the messages to send to the C# application, and vice versa. There are several strategies included with VR-Link C#:

Initialization
Entity State
Fire Interaction
Detonate Interaction
Start/Stop
Transmitters
Set Data
Signal Interaction
Laser Designator
Action Response/Request
There are copies of each of these strategies for each of the protocols supported by VR-Link (DIS, HLA 1.3, HLA 1516, HLA 1516-Evolved). The initialization strategy is responsible for creating the other strategies when a network connection is requested. You can add new types of strategies or replace existing ones with updated behaviors through the use of plug-ins.

Strategies are given some CPU time every frame during a tick() function. During this function, any internal work may be done and is typically used to update any entity publishers that the strategy owns.

10.6.2 - Resources
During execution, certain data structures and classes need to be shared between different strategies. Typically shared resources are reflected objects, the simulation clock, and the initialization strategy. Sharing objects between strategies is done with a resource manager that is accessible from the ManagedInterface class. Resources are generic pointers to objects wrapped in Handles, which are discussed below. The resource manager does not manage the memory of stored objects throughout their lifetime, but does proved a generic means to find and access stored objects and data structures.

There are several default names used for commonly used objects that are defined in ManagedInterface/utility.h:

MANAGEDINTERFACE_DLL extern const char* EXERCISE_CONNECTION_NAME;
MANAGEDINTERFACE_DLL extern const char* CLOCK_NAME;
MANAGEDINTERFACE_DLL extern const char* REFLECTED_ENTITY_LIST_NAME;
MANAGEDINTERFACE_DLL extern const char* ENTITY_PUBLISHER_LIST_NAME;
\endcoe
These defined names provide a uniform way to access commonly used objects, such as the VR-Link DtExerciseConnection or the DtClock.
There are also several utility functions to access commonly used objects: 
\code
MANAGEDINTERFACE_DLL DtExerciseConn* findExConnResource();
MANAGEDINTERFACE_DLL void setExConnResource(DtExerciseConn* conn);
MANAGEDINTERFACE_DLL DtReflectedEntity* findReflectedEntityResource(std::string id);
MANAGEDINTERFACE_DLL void setReflectedEntityResource(std::string id, DtReflectedEntity* ent);
MANAGEDINTERFACE_DLL DtEntityPublisher* findEntityPublisherResource(std::string id);
MANAGEDINTERFACE_DLL void setEntityPublisherResource(std::string id, DtEntityPublisher* pub);
MANAGEDINTERFACE_DLL DtClock* findClockResource();
MANAGEDINTERFACE_DLL void setClockResource(DtClock* clock);
MANAGEDINTERFACE_DLL DtReflectedEntityList* findReflectedEntityListResource();
MANAGEDINTERFACE_DLL void setReflectedEntityListResource(DtReflectedEntityList* rel);
10.6.3 - Delegates
Delegates are C++ classes that wrap a function to callback at a later time. These are used for message handlers that are registered with ManagedInterface. When a strategy wants notification that a message arrives from the C# application, it will create a delegate with one of the strategy's member functions and register that with the ManagedInterface message handlers.

10.7 - Messages
Table of Contents
10.7.1 Message Definition Language
10.7.2 Message Example
10.7.3 Message Enums
10.7.4 Message Structures
10.7.5 Message Attributes
10.7.6 Message Configuration
VR-Link communicates with VR-Link C# through messages.

All messages are serialized into a byte buffer and then sent to VR-Link C# through a simple API. Messages are able to serialize and deserialize themselves. Adding new messages requires that a C# implementation and a C++ implementation be created. This is done by using code generators and a message definition language.

10.7.1 Message Definition Language
The message definition language is written using the Lua language. Messages are declared using the "MESSAGE" keyword followed by the message layout and configuration in a key:value pair table.

MESSAGE{
   fileName="transmitterState";  
   className="TransmitterState";
   includes={};
   dllExport="MANAGEDINTERFACE_DLL";   
   enums={
      TransmitState=[[OFF, RADIO_ON_NOT_TRANSMITTING, ON]];
      InputSource=[[OTHER, PILOT, COPILOT, FIRST_OFFICER, DRIVER, LOADER, GUNNER, COMMANDER, DIGITAL_DATA_DEVICE, INTERCOM]];
      AntennaPatternType=[[OMNIDIRECTIONAL=0, BEAM=1, SPHERICALHARMONIC=2]];
      CryptoSystem=[[ OTHER, KY_28, VINSON, NSVE, WSVE, SINGARS_ICOM, KY_75, KY_100]];
      CryptoMode=[[BASEBAND, DIPHASE]];
      ModulationMajorType=[[OTHER, AMPLITUDE,   AMPLITUDE_ANGLE, ANGLE=3, COMBINATION=4, PULSE=5, UNMODULATED=6, CARRIER_PHASE_SHIFT=7]];
      ModulationDetailAplitudeType=[[ OTHER, AFSK, AM, CW, DSB, ISB, LSB, SSB_FULL, SSB_REDUC, USB, VSB]];
      ModulationDetailAplitudeAngleType=[[ OTHER, APLITUDE_ANGLE]];
      ModulationDetailAngleType=[[ OTHER, FM, FSK, PM]];
      ModulationDetailCombinationType=[[ OTHER, AMPLITUDE_ANGLE_PULSE]];
      ModulationDetailPulseType=[[ OTHER, PULSE, X_BAND, Y_BAND]];
      ModulationDetailUnmodulatedType=[[ OTHER, CONTINOUS_WAVE]];
      ModulationDetailCarrierPhaseShiftType=[[ OTHER  ]];
      ModulationSystemType=[[OTHER, GENERIC, HQ, HQII, HQIIA, SINCGARS, CCTT_SINCGARS, EPLRS, JTIDS]];
      ReferenceSystem=[[WORLDCOORD=1, ENTITYCOORD=2]];
      StartOfMessage=[[NOT_START, START]];
      ClearChannel=[[NOT_CLEAR, CLEAR]];
      TransmitTerminalPrimaryMode=[[NTR, JTIDS]];
      TransmitTerminalSecondaryMode=[[NONE, NET_POSITION_REFERENCE, PRIMARY_NAVIGATION_CONTROLLER, SECONDARY_NAVIGATION_CONTROLLER]];
      SyncState=[[COURSE=1, FINE=2]];
      
   };
   structs={
      ModulationType={
         {type="enum", name="major", enum="ModulationMajorType"};
         {type="UInt16", name="detail"}; --needs to be as the right enum
         {type="enum", name="system", enum="ModulationSystemType"};
      };
      OmniAntennaPattern={}; --this is a null pattern
      BeamAntennaPattern={
         {type="Vector3", name="orientation"};
         {type="float", name="AzimuthBeamWidth"};
         {type="float", name="ElevationBeamWidth"};
         {type="enum", name="referenceSystem", enum="ReferenceSystem"};
         {type="float", name="EZ"};
         {type="float", name="EX"};
         {type="float", name="phase"};
      };
      SphericalAntennaPattern={
         {type="byte", name="order"};
         {type="List<float>", name="coefficients"};
         {type="enum", name="referenceSystem", enum="ReferenceSystem"};
      };
   };
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="radioId"};
      {type="EntityEnum", name="radioEntityType", new=true};
      {type="enum", name="transmitState", enum="TransmitState"};
      {type="enum", name="inputSource", enum="InputSource"};
      {type="Vector3", name="worldAntennaLocation"};
      {type="Vector3", name="relativeAntennaLocation"};
      {type="enum", name="antennaPatternType", enum="AntennaPatternType"};
      {type="UInt64", name="Frequency"};
      {type="float", name="transmitBandwidth"};
      {type="float", name="power"};
      {type="struct", name="modulationType", struct="ModulationType"};
      {type="enum", name="cryptoMode", enum="CryptoMode"};
      {type="enum", name="cryptoSystem", enum="CryptoSystem"};
      {type="UInt16", name="cryptoKey"};
      {type="List<byte>", name="modulationParameters", new=true};
      {type="List<byte>", name="antennaPaternParameters", new=true};
      {type="bool", name="freqHopInUse"};
      {type="bool", name="pseudoNoiseInUse"};
      {type="bool", name="timeHopInUse"};
   }
}
10.7.2 Message Example
Message attributes can be simple data types, listed below, structures, enumerations, or arrays(lists) of acceptable attribute types.

10.7.3 Message Enums
Message Enumerations are defined in the enums table. Enumerations are given a name and then a list of enumerated values within double brackets [[ ]]. If a specific enumeration should have a specific value, then assign the enum=value in the definition. When declaring a message attribute as an enum, the type is "enum" and there is an additional field to declare which enum is used.

The following code shows how to declare an enum attribute within a message definition:

{type="enum", name="transmitState", enum="TransmitState"};
10.7.4 Message Structures
Some messages need to package up several data fields into a single structure. These structures can be defined in the structs table. A structure follows the same rules as the attributes table and uses the same data types, which are defined below. When declaring a message attribute as a struct, the type is "struct" and there is an additional field to declare which struct is used.

The following code shows how to declare a struct attribute within a message definition:

{type="struct", name="modulationType", struct="ModulationType"};
10.7.5 Message Attributes
Message attributes define the message layout. Attributes can be defined a simple data type, an enum, a structure, or a list of any of these types.

string
bool
Int8
Uint8
Int16
UInt16
Int32
UInt32
Int64
UInt64
float
double
Vector2
Vector3
Vector4
Quaternion
EntityEnum
List<DATA TYPE>
Note
Using an EntityEnum, user defined struct or List<> datatype as an attribute requires that the attribute have the field new=true be defined as well, for example:
{type="EntityEnum", name="munitionType", new=true};
10.7.6 Message Configuration
The message description has fields for the name of the file to generate (not including the extension) and the name of the class to build. The message definition also contains fields to describe any required include files, or DLL Export macro name, which are only used for the C++ code generator.

10.8 - Code Generator
Once the message definition is written, the included code generators generate C++ and C# source code to encode and decode the message data.

Both code generators are command line tools and can be integrated into your build steps to generate message source code as a build step.

The C# code generator has the following command line parameters:

-i The full path to the message definition file.
-o The full path to where the generated C# files should go.
The C++ code generator has the following command line parameters:

-i The full path to the message definition file.
-h The full path to where the generated C++ header files should go.
-s The full path to where the generated C++ source file should go.

10.9 - Laser Designator Example
Table of Contents
10.9.1 Project Description and Setup
10.9.2 Laser Designator Messages
10.9.3 Laser Designator Plugin
10.9.4 Laser Designator Protocol Specific Plug-ins
10.9.5 Laser Designator Strategy
10.9.6 Laser Designators in C#
The included example is the complete source code for a plug-in that adds support for Laser Designators in DIS and HLA.

It uses the C++ VR-Link toolkit and the VR-Link C# library.

10.9.1 Project Description and Setup
The project files for the example are broken down into five projects. One project for the protocol independent message representations to be loaded into the message factory, then 4 protocol project to create plug-ins that load a protocol specific strategy into the strategy factory and registers it with the initialization strategy so that it gets created on connection. Since VR-Link is protocol independent and uses compiler flags to determine which protocol to support, most of the source code for the example is shared between the 4 protocol specific projects. Changes to files in project will show up as changes in other projects.

Since the project files are configured to use environment variables to find the C++ VR-Link SDK, it is recommended to edit the included setupEnvironment.bat file to match your system and use it to launch Visual Studio.

10.9.2 Laser Designator Messages
Laser designators are stateful objects within DIS and HLA and change their state when painting a target. This means that we will need a discovery, state update, and removed message to inform VR-Link C# about laser designators.

These three messages are defined in laser.lua. Two things to note: entity ID�s are transferred to VR-Link C# as strings and all positions are vectors in VR-Link C#.

10.9.3 Laser Designator Plugin
The Laser Designator plug-in loads the laser designator messages into the message factory in its initManagedInterfaceModule() function:

bool initManagedInterfaceModule( DtManagedInterface* gl)
{  
   //add the message types to the factory so that ManagedInterface knows how to decode them
   gl->messageFactory().registerCreator(LaserDesignatorDiscoveryMessage::theMessageName(), LaserDesignatorDiscoveryMessage::decode);
   gl->messageFactory().registerCreator(LaserDesignatorRemovedMessage::theMessageName(), LaserDesignatorRemovedMessage::decode);
   gl->messageFactory().registerCreator(LaserDesignatorStateMessage::theMessageName(), LaserDesignatorStateMessage::decode);
   return true;
}
10.9.4 Laser Designator Protocol Specific Plug-ins
The protocol specific laser designator plug-ins load their specific strategy into the strategy factory and register with the initialization strategy to be loaded during connection.

bool initManagedInterfaceModule( DtManagedInterface* gl)
{  
   //add the strategies to the factory
   //this is ok to do multiple times since it won't damage anything/or leak resources
   gl->addStrategyCreator(DtLaserDesignatorStrategy::theName(), DtLaserDesignatorStrategy::create);
   
   //add the strategy to the correct init strategy so that it gets created during initialization
   DtInitStrategy* initStr=dynamic_cast<DtInitStrategy*>(gl->findStrategy(DtInitStrategy::theName()));
   if(initStr!=NULL)
   {
      initStr->addInitChild(DtLaserDesignatorStrategy::theName());
   }
   else
   {
      DtWarn << "Unable to register Laser strategy with the Initialization strategy for DIS protocol" << std::endl;
   }
   return true;
}
10.9.5 Laser Designator Strategy
When the laser designator strategy is created, it registers interest in laser object messages with ManagedInterface. It does this by wrapping its handler member functions with a delegate and passing this delegate to ManagedInterface:

myDesignatorDiscoveredHandler=new DtMessageDelegate(this, &DtLaserDesignatorStrategy::handleUnityDesignatorDiscovered);
   myDesignatorRemovedHandler=new DtMessageDelegate(this, &DtLaserDesignatorStrategy::handleUnityDesignatorRemoved);
   myDesignatorStateHandler=new DtMessageDelegate(this, &DtLaserDesignatorStrategy::handleUnityDesignatorState);
   myManagedInterface->addHandler(LaserDesignatorDiscoveryMessage::theMessageName(), myDesignatorDiscoveredHandler);
   myManagedInterface->addHandler(LaserDesignatorRemovedMessage::theMessageName(), myDesignatorRemovedHandler);
   myManagedInterface->addHandler(LaserDesignatorStateMessage::theMessageName(), myDesignatorStateHandler);
It is important to remember to remove these delegates from ManagedInterface during shutdown so that they do not get called after the strategy is destroyed.

myManagedInterface->removeHandler(LaserDesignatorDiscoveryMessage::theMessageName(), myDesignatorDiscoveredHandler);
   myManagedInterface->removeHandler(LaserDesignatorRemovedMessage::theMessageName(), myDesignatorRemovedHandler);
   myManagedInterface->removeHandler(LaserDesignatorStateMessage::theMessageName(), myDesignatorStateHandler);
The initialization function of the laser designator strategy finds the exercise connection shared resource, creates a reflected laser designator list, and installs some callbacks on it to listen for laser designators coming from the DIS/HLA network. It also creates a laser designator publisher list to hold publishers that it creates to mirror laser designators being controlled in VR-Link C#.

bool DtLaserDesignatorStrategy::init()
{
   if(myInitalized==true) return true;
   myExconn=findExConnResource();
   if(myExconn!=NULL)
   {
      //radio Designators
      myRelDx=new DtReflectedDesignatorList(myExconn);
      myRelDx->addDesignatorAdditionCallback(&DtLaserDesignatorStrategy::vrlDesignatorDiscovered, this);
      myRelDx->addDesignatorRemovalCallback(&DtLaserDesignatorStrategy::vrlDesignatorRemoved, this);
      myManagedInterface->setResource("REFLECTED_DESIGNATOR_LIST", myRelDx);
      myDxPubs=new DtPublisherList<DtDesignatorPublisher>();
      myManagedInterface->setResource("DESIGNATOR_PUBLISHER_LIST", myDxPubs);
      myInitalized=true;
      DtDebug << "Laser Designator strategy initialized" << std::endl;
   }
   return myInitalized;
}
Since this initialization function will be run more than once, it protects itself against being initialized more than once. In the event it cannot get the shared resource exercise connection, it may return false, causing it to be run again until is able to get the shared resource and fully initialize.

During the tick function, which is called every frame, the Laser Designator strategy updates any laser designator publishers that it created to mirror laser designators from VR-Link C# to the DIS/HLA network.

myDxPubs->tick();
The strategy contains several callbacks for registering with VR-Link as well as with the ManagedInterface message handlers to handle discovery, removal and state update of laser designators from both the DIS/HLA network and within VR-Link C#. These callbacks marshal the data to and from the laser designator messages and VR-Link data structures ensuring to convert entity names and terrain coordinates using the conversion routines in the initialization strategy and terrain strategy respectively.

pub->dsr()->setDesignatedObject(DtInitStrategy::unityToVrlinkId(dxMsg->getTargetId()));
10.9.6 Laser Designators in C#
There are a few things that need to be defined in C# to now receive and send laser designators. The first step is to define a .lua file that will output a state message, a discovery message, and a removed message. This was covered in the message definition section. Here is an example of such:

MESSAGE{
   fileName="laserDesignatorDiscovery";
   className="LaserDesignatorDiscovery";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="designatorId"};
   }
}
MESSAGE{
   fileName="laserDesignatorRemoved";
   className="LaserDesignatorRemoved";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";   
   attributes={
      {type="string", name="entityId"};
      {type="UInt16", name="designatorId"};
   }
}
MESSAGE{
   fileName="laserDesignatorState";
   className="LaserDesignatorState";
   includes={"plugin.h"};
   dllExport="LASER_DESIGNATOR_DLL";
   enums={
      CodeName=[[OTHER]];
      DesignatorCode=[[OTHER]];
   };
   attributes={
      {type="string", name="entityId"};
      {type="enum", name="codeName", enum="CodeName"};
      {type="string", name="targetId"};
      {type="enum", name="designatorCode", enum="DesignatorCode"};
      {type="float", name="power"};
      {type="float", name="wavelength"};
      {type="Vector3d", name="relativeDesignatorSpot", new=true};
      {type="Vector3d", name="worldDesignatorSpot", new=true};
   }
}
Of course, as we have learned from the message definition section, this will output C# files defining the messages we supplied. Next, we must define a state repository class for laser designators. The state repository contains the items that make up the object being reflected, in our case, a laser designator.

To define a laserStateRepository, we derive from the VR-Link C# library class StateRepository. The StateRepository class contains a map of class members to their name. They are stored as C# "object" classes with a string as the key. This allows the StateRepository to remain very flexible in its use. To define and set new variables in our laserDesignator, we use the setAttribute function in the constructor with some initial value to signify the type.

public laserDesignatorStateRepository()
   : base()
{
   setAttribute("entityId", "");
   setAttribute("codeName", CodeName.OTHER);
   setAttribute("targetId", "");
   setAttribute("designatorCode", DesignatorCode.OTHER);
   setAttribute("power", 0.0F);
   setAttribute("wavelength", 0.0F);
   setAttribute("relativeDesignatorSpot", Vector3d.Zero);
   setAttribute("worldDesignatorSpot", Vector3d.Zero);
}
We use the getAttribute function to get an attribute from the repository, casting the return value to the type we used in setAttribute.

public string entityId
{
  get { return (string)getAttribute("entityId"); }
  set { setAttribute("entityId", value); }
}
public CodeName codeName
{
  get { return (CodeName)getAttribute("codeName"); }
  set { setAttribute("codeName", value); }
}
Lastly, we need to provide functions that update from a state message, and output a state message from current values. These will be very simple functions that assign the state repository values to their corresponding state message values, and vice versa.

internal void update(LaserDesignatorStateMessage sm)
      {
         //this shouldn't change
         entityId = sm.entityId;
         codeName = (makVrl.CodeName)sm.codeName;
         targetId = sm.targetId;
         designatorCode = (makVrl.DesignatorCode)sm.designatorCode;
         power = sm.power;
         wavelength = sm.wavelength;
         relativeDesignatorSpot = sm.relativeDesignatorSpot;
         worldDesignatorSpot = sm.worldDesignatorSpot;
      }
      internal LaserDesignatorStateMessage getStateMessage()
      {
         LaserDesignatorStateMessage sm = new LaserDesignatorStateMessage();
         sm.entityId = entityId;
         sm.codeName = (LaserDesignatorStateMessage.CodeName)codeName;
         sm.targetId = targetId;
         sm.designatorCode = (LaserDesignatorStateMessage.DesignatorCode)designatorCode;
         sm.power = power;
         sm.wavelength = wavelength;
         sm.relativeDesignatorSpot = relativeDesignatorSpot;
         sm.worldDesignatorSpot = worldDesignatorSpot;
         return sm;
      }
Next, we will create the reflected object that will be populated when a remote laser designator is discovered. The reflected object class will contain the state repository we just defined, as well as a constructor as well as a few wrappers around some of the state repository functions.

public class ReflectedLaserDesignator
   {
      laserDesignatorStateRepository myLsr = new laserDesignatorStateRepository();
      public ReflectedLaserDesignator(string id)
      {
         myLsr.entityId = id;
      }
      public laserDesignatorStateRepository esr { get { return myLsr; } }
      internal void update(LaserDesignatorStateMessage sm)
      {
         myLsr.update(sm);
      }
   }
Now that we have a reflected object, we can define our reflected object list. The reflected object lists are where the callbacks for discovery, update, and removed are registered and handled. In other words, to receive incoming laser designators, you would construct the ReflectedLaserDesignatorList. The reflected list needs an exercise connection to be constructed, and will also create two maps of strings to reflected objects (entityIds to ReflectedLaserDesignators). These two maps handle undiscovered lasers and discovered lasers.

In the constructor, we will set the exercise connection to what was given, and register our callbacks with that exercise connection.

public class ReflectedLaserDesignatorList
{
   ExerciseConnection myExConn;
   Dictionary<String, ReflectedLaserDesignator> myUnprocessedLasers = new Dictionary<String, ReflectedLaserDesignator>();
   Dictionary<String, ReflectedLaserDesignator> myLasers = new Dictionary<String, ReflectedLaserDesignator>();
   public ReflectedLaserDesignatorList(ExerciseConnection exConn)
   {
      myExConn = exConn;
      myExConn.addMessageHandler(LaserDesignatorDiscoveryMessage.theName, new MessageDelegate(handleLaserDesignatorDiscoveredMessage));
      myExConn.addMessageHandler(LaserDesignatorRemovedMessage.theName, new MessageDelegate(handleLaserDesignatorRemovedMessage));
      myExConn.addMessageHandler(LaserDesignatorStateMessage.theName, new MessageDelegate(handleLaserDesignatorUpdatedMessage));
   }
We then define some delegates to handle anything specific we want to happen when our callbacks are reached.

public delegate void LaserDesignatorDiscoveredCallback(ReflectedLaserDesignator laser);
public delegate void LaserDesignatorRemovedCallback(ReflectedLaserDesignator laser);
public delegate bool DiscoveryCondition(ReflectedLaserDesignator laser);
public LaserDesignatorDiscoveredCallback laserDiscovered;
public LaserDesignatorRemovedCallback laserRemoved;
public DiscoveryCondition discoveryCondition;
Lastly, we define the callback functions that we registered with the exercise connection. Here are a few examples.

internal void handleLaserDesignatorDiscoveredMessage(Message m)
{
   LaserDesignatorDiscoveryMessage dm = m as LaserDesignatorDiscoveryMessage;
   ReflectedLaserDesignator laser = new ReflectedLaserDesignator(dm.entityId);
   myUnprocessedLasers[dm.entityId] = laser;
}
internal void handleLaserDesignatorUpdatedMessage(Message m)
{
   LaserDesignatorStateMessage sm = m as LaserDesignatorStateMessage;
   ReflectedLaserDesignator laser = null;
   if (myLasers.TryGetValue(sm.entityId, out laser) == true)
   {
      laser.update(sm);
   }
   else
   {
     //waiting for an update so we can be discovered
     if (myUnprocessedLasers.ContainsKey(sm.entityId) == true)
     {
         laser = myUnprocessedLasers[sm.entityId];
      }
      else
      {
         //need to discover the entity
         laser = new ReflectedLaserDesignator(sm.entityId);
       }
      laser.update(sm);
      discoverLasers(laser);
   }
}
As you can see, there are some helper functions to do some of the work required after a callback. This is typically how callbacks are handled, but once you have entered your callback, you can handle the information any way you would like. At this point we have all that we need to receive a laser designator from VR-Link, but we have not handled publishing our VR-Link C# laser designators to VR-Link. To achieve this, we define a publisher class � laserDesignatorPublisher.

This class will contain an exercise connection to publish on and a laser state repository that has the information we want to publish.

public class laserDesignatorPublisher
{
   ExerciseConnection myExConn;
   laserDesignatorStateRepository mylsr = new laserDesignatorStateRepository();
   public laserDesignatorPublisher(ExerciseConnection exConn)
   {
      myExConn = exConn;
   }
}
The actual publishing is handled in the tick function. The tick function is typically called on every simulation "tick" or update. Inside our publisher tick function, we will create a state message from the current information in our state repository and then use our exercise connection to send that message.

public void tick(double dt)
{
   LaserDesignatorStateMessage sm = mylsr.getStateMessage();
   myExConn.sendMessage(sm);
}
Lastly, we will add a dispose method that will be used once the entity is destroyed or deleted. To do so we will create a new LaserDesignatorRemovedMessage, assign the entityId value of the message to our state repository entityId, and send the message with the exercise connection.

public void dispose()
{
   LaserDesignatorRemovedMessage lrm = new LaserDesignatorRemovedMessage();
   lrm.entityId = lsr.entityId;
   myExConn.sendMessage(lrm);
}
Now if we define a publisher that uses an existing state repository and call its tick function in our simulation tick, we are able to send a laserDesignator that VR-Link can understand. Since we have already defined our strategy for laser designators, the published information will be formatted into what VR-Link will understand.

11 - Introduction to the Java API
Table of Contents
11.1 Running the examples
11.2 Setting up a Project
11.2.1 Setting up with Bundled Native Libraries
11.2.2 Setting up with External Native Libraries
11.2.3 Setting up with Eclipse
11.3 Exercise Connections
11.3.1 Initializing an Exercise Connection
11.3.2 Using the ExerciseInitializer class
11.3.3 jcommander @Parameter annotation
11.4 Threading
11.5 Publishing Objects
11.6 Reflected Objects
11.7 Callbacks and Interactions
This chapter explains how to develop applications using the VR-Link for Java library.

VR-Link for Java consists of both Java code and native platform-specific code. Because of this dependency on native code, VR-Link for Java is not portable to any Java platform, only platforms supported by VR-Link (C/C++). Both 32- and 64-bit native libraries are provided for the platform corresponding to the VR-Link (C/C++) installation.

The Java API has a version of the F-18 example, which is in the ./java/examples, to illustrate the concepts that are introduced. It is assumed that you know the Java language.

11.1 Running the examples
Assuming you have a Java runtime installed and in your path (try the command 'java -version' to confirm), you must tell the Java Virtual Machine (JVM) two things:

Where is the Java code (jars, class files).
Where are the native libraries
Tell the JVM where the Java code is by using the CLASSPATH environment variable, or the -cp command line option. Remember that JVM command line options come before the class you want to run, and the command line options to the application come last:

java -cp <list of paths> [JVM options] <class to run> [arguments to application]
Tell the vrlj Java application where the native libraries are by using the bundled native libraries, by choosing the working directory, or by using the –loadPath argument to the application.

For an example on Microsoft Windows, if your current working directory contains the jar files f18.jar and vrlj_VC10.jar (which contains bundled native libraries, you could run the F18 example like this:

java -cp f18.jar;vrlj_VC10.jar com.mak.vrlj.example.f18.F18
Remember to use the file and path separators for your platform.

You could use the –loadPath argument to the F18 example application to locate the native libraries:

java -cp f18.jar;vrlj.jar com.mak.vrlj.example.f18.F18 --loadPath c:\mak\vrlink5.2\bin
To use a relative classpath run the listen example application from the VR-Link /bin or /bin64 directory (Windows) or /lib or /lib64 directory (linux):

java -cp ..\java\listen.jar;..\java\vrlj.jar com.mak.vrlj.example.listen.Listen
Or to run the talk example application using bundled native libraries on Windows (VC10):

java -cp talk.jar;vrlj_VC10.jar com.mak.vrlj.example.talk.Talk
Example using the CLASSPATH environment variable:

Set the CLASSPATH environment variable to include the Java jars and classfiles:

set CLASSPATH=<path to VR-Link>\java\f18.jar;<path to VR-Link>\java\listen.jar;<path to VR-Link>\java\talk.jar;<path to VR-Link>\java\vrlj_VC10.jar
Now the JVM can find all the examples and the -cp option is unecessary, and the bundled native libraries are used.

java com.mak.vrlj.example.f18.F18
11.2 Setting up a Project
You need a javac compiler that supports at least Java 8. Add the correct jar file to your Java classpath to build and to run your application.

All Java code is contained in a single JAR file. However, native code might be loaded differently depending upon configuration. The basic vrlj.jar file contains no native libraries; the location of the native libraries must be provided. Other jar files contain native library code for a single platform (with both 32- and 64-bit native code versions) depending on the name of the library.

11.2.1 Setting up with Bundled Native Libraries
If a jar containing native library code is used, you just need to add that jar to your Java classpath. At runtime, the native code will be loaded from the jar. Since each jar contains native code for a different platform, the jar corresponding to the execution platform must be used in the classpath at runtime. For example, vrlj_VC10.jar contains both 32- and 64-bit DLLs for Microsoft Windows compiled using Visual C++ 10.0.

11.2.2 Setting up with External Native Libraries
If the vrlj.jar file is included in the Java classpath, it contains no native code. The path to the shared libraries must be specified by calling the initializer method setLoadPath(). Since shared libraries load their dependent shared libraries automatically, it is good practice to keep all the related shared libraries in the same directory. The load path may also be set via the command line option –loadPath if the Java application uses the ExerciseConnectionInitializer to parse the command line as shown in the example applications.

If no setLoadPath() (or –loadPath) is specified, the current working directory will be used, check System.getProperty("user.dir").

The name of the shared library may be specified using setDynamicLibraryName(). The default is managedInterface. If the environment variable MAK_VRL_USE_DEBUG_FOR_CPLUSPLUS is defined, then the debug version of the native code is loaded.

11.2.3 Setting up with Eclipse
To add vrlj_Xxx.jar (platform specific with bundled native libraries) to an Eclipse project, simply add that jar to the build path.

To add vrlj.jar to an Eclipse project, add the jar to the build path normally. To load the native libraries, there are several ways:

Modify the Run Configurations for the project such that the working directory contains the required native libraries, e.g. /bin or /bin64 in your VR-Link installation.
Copy the native libraries into your working directory
Modify your code to call setLoadPath() or use –loadPath as described above to set the path to load the native libraries.
To load the VR-Link for Java example applications into your workspace, select Import... from the File menu. For the source, select Existing Projects into Workspace (under General), and then press next. Select the root directory as /java/examples directory under your VR-Link installation and eclipse should find all the examples and add them to the Projects shown. If you do not copy the examples into the workspace,the example applications should already be configured to use bundled native libraries and be ready to run.

If you make a copy of the projects in your workspace, you will need to add the vrlj.jar or vrlj_Xxx.jar to the Eclipse build path for each example project.

11.3 Exercise Connections
VR-Link applications connect to an exercise through an exercise connection. Currently only a single exercise connection may be opened at a time; attempting to open a second exercise connection concurrently will result in undefined behaviour.

Exercise connections are implementations of the Java interface ExerciseConnection. Higher level VR-Link classes use the ExerciseConnection to set and receive state information and other data. The member functions of ExerciseConnection allow an application to do the following:

Send interactions to the exercise.
Read input from the network.
Generate event IDs.
Register callback functions that are executed each time VR-Link receives interactions and other input from the network.
Manage the simulation clock.
11.3.1 Initializing an Exercise Connection
ExerciseConnections are created by the ExerciseConnectionFactory class. There is one implementation.

An ExerciseConnection takes responsibility for various resources such as network sockets and managed memory. To simplify its use, ExerciseConnection implements the AutoCloseable interface introduced in Java 7.

try (ExerciseConnection exConn = ExerciseConnectionFactory.createDefault(initializer)) {
   ... use exConn here ...
} catch (Exception e) {
   ...
}
... exConn is automatically closed at this point ...

11.3.2 Using the ExerciseInitializer class
The ExerciseInitializer class should contain all information necessary to initialize an ExerciseConnection (or use default values), and may contain additional information for user application. The method parseCmdLine(String[] args) simplifies parsing command line arguments passed to the user application, to read the configuration information.

VR-Link for Java uses the open source project jcommander to parse command line parameters. The jcommander code is bundled in the same jar as the VR-Link for Java code.

Refer to the F-18 example, to the F18Init.java file for an example of how to create a custom ExerciseInitializer.

11.3.3 jcommander @Parameter annotation
For example, look at the markings member variable:

@Parameter(names = { "--f18Markings" }, description = "hull markings")
private final String markings;
This tells jcommander that the command line parameter –f18Markings should be mapped into the markings member variable. When the command line usage is printed, the hint "hull markings" will be shown next to the –f18Markings option.

11.4 Threading
VR-Link for Java shares a single thread with your application; no extra threads run for background processing such as send DIS heartbeats or HLA housekeeping tasks. Each ExerciseConnection has a drainInput() method which performs background processing and must be called periodically (typically at least once per second).

Note
drainInput() MUST be called even if all input (received interactions, updates, etc.) is ignored. The time spent in drainInput() depends upon the amount of background processing required at that time, and there is no simple rule to make even an approximate prediction of the time required.
VR-Link for Java methods are not thread-safe. User applications may use any threads desired, but must not call any VR-Link for Java methods simultaneously from multiple threads. Strategies such as locking or messaging could be employed to enforce this requirement.

VR-Link for Java will not access or modify simulation objects and interactions other than during the drainInput() call. So a typical way to use parallelism in a Java simulation application is to use multiple threads right after drainInput() finishes, and make sure all those threads finish (join) before the next call to drainInput() begins.

11.5 Publishing Objects
To publish an object to the network, start with a PublisherFactory obtained from an exercise connection, then get an ObjectPublisher for a particular kind of object.

PublisherFactory pubFactory = exConn.getPublisherFactory();
ObjectPublisher myEntity = pubFactory.createEntity("myEntityName");
Entity myEntity = myEntityPublisher.getObject();
Each PublisherFactory creates ObjectPublishers which publish to the same ExerciseConnection. PublisherFactory has methods to create publishers for each type of simulation object such as an Entity.

To update myEntity and publish to the network:

myEntity.setWorldPosition(new Vector3d(1524517.05424356, -4464444.01466548, 4278068.90596911));
myEntityPublisher.tick()();
A common way to write simulation code is to use a time-stepped loop. The example below is taken from the talk example.

double dt = 0.05; // time step in seconds
double simTime = 0.0; // starting simulation time in seconds
while (simTime <= 10.0) {
   // Tell VR-Link the current value of simulation time.
   clock.setSimTime(simTime);
   // Process any incoming messages and perform background processing.
   exConn.drainInput();
   // Update our published entity from our topographic model
   entity.setWorldPosition(toGeoc.transform(topoPos));
   // Publish the updated model
   entityPublisher.tick();
   // topographic equation of motion:
   // newPos = oldPos + vel * dt
   offset.assignFrom(topoVel);
   offset.multiply(dt);
   topoPos.add(offset);
   // Increment the simulation time
   simTime += dt;
   // Sleep till next iteration, in milliseconds.
   Thread.sleep((long) (1000 * dt));
}
First, note that drainInput() MUST be called even though we are ignoring all input (received interactions, updates, etc.). In this example we are calling it every simulation frame, every few milliseconds (depending on the time step dt).

Also note that simply updating the time does not affect the entity position (or anything else about the entity). The entity motion, etc., must be updated by the user application. The above code uses a very simple motion model that updates the position similar to dead reckoning. Other, more detailed motion models are possible, for example a vehicle that follows roads or a ship affected by ocean currents.

11.6 Reflected Objects
A reflected object is a class used to store information about an object that has been discovered, updated and deleted by the exercise connection.

Each exercise connection tracks all reflected objects in a ReflectedObjectCollection, accessed from <>exConn.getReflectedCollection(). This collection implements the Map interface where the map key is some implementation ObjectIdentifier (for Entity it is an EntityName). ReflectedObjectCollection also extends the ObjectDispatcher interface, allowing registration for callbacks when objects are created, updated, or deleted.

To define a collection which is a particular subset of objects, you can define a ReflectedMap for a particular class of object, and a particular selection criteria. A selection criteria defines a test for inclusion: when the criteria is applied to an object it passes (criteria returns true) and is included in the ReflectedMap, or else it fails and is removed. Once a collection is created with a specified criteria, the criteria may not be changed. Instead, create a new collection with a different criteria. For convenience, a ReflectedMap is pre-defined for each type of object, for example, ReflectedEntityMap.

The example below shows a ReflectedEntityMap which is automatically updated and maintained by the ExerciseConnection exConn:

// print out all the reflected Entity objects
ReflectedEntityMap rem = new ReflectedEntityMap(exConn);
Iterator<Entity> iter = rem.values().iterator();
while (iter.hasNext())
{
   Entity first = iter.next();
   System.out.println(iter.toString());
}
Alternatively, you could iterate through all objects and check which are Entity objects as follows:

Iterator<BaseObject<? extends ObjectIdentifier>> objIter = exConn.getReflectedCollection().values().iterator();
while(objIter.hasNext())
{
   BaseObject<? extends ObjectIdentifier> obj = objIter.next();
   if(obj instanceof Entity)
   {
      Entity e = (Entity) obj;
      System.out.println(e.toString());
   }
}
11.7 Callbacks and Interactions
Interactions are handled differently than objects. Typically, interactions are created and sent one time, then received and reacted to appropriately. An example of such interaction is the FireInteraction. The f18 example has the ability to fire at other entities, and it does so with fire interactions.

Sending an interaction is as simple as creating one, setting its data, then sending it using the exercise connection.

FireInteraction fire = new FireInteraction();
fire.setFiringId(myId);
... set other interaction fields as required ... 
exConn.send(fire);
To illustrate receiving an interaction, consider the code fragment below from the Listen example. Note the Java 8 lambda syntax for the callback method definition.

FireInteraction.addListener(exConn, fire -> {
   System.out.print("Fire Interaction from ");
   System.out.println(fire.getFiringId());
});
Each Interaction class contains convenience member methods addListener and removeListener for adding and removing InteractionListener callbacks. InteractionListener defines a single method process(intr) which takes an interaction as its only argument. In the previous example, the handler method for incoming fire interactions is defined using the Java 8 lambda syntax, where 'fire' is the argument which receives the fire interaction.

The same example in older syntax using an anonymous inner class looks like this:

FireInteraction.addListener(exConn, new InteractionListener<FireInteraction>() {
   public void process(FireInteraction fire)
   {
      System.out.print("Fire Interaction from ");
      System.out.println(fire.getFiringId());
   }
});

12 - Example and Utility Applications
VR-Link includes a set of supporting applications that can help you develop and troubleshoot your own applications.

There is additional information about some of these applications on the Examples page.

12.1 - About the Applications
12.2 - The f18 Program
12.3 - Calling VR-Link from Other Languages
12.4 - Launcher
12.5 - netdumpDIS
12.6 - netdumpHLA
12.7 - talk and listen

12.1 - About the Applications
VR-Link's example and utility applications are provided to make your development and troubleshooting tasks easier, and to demonstrate how VR-Link's classes and functions are used in practice.

The executables for these programs are in the ./bin directories. Source code for the example applications is in subdirectories under ./examples.

12.1.1 License Enforcement for the Example Applications
You do not need a VR-Link license to run the example applications that MAK delivers. However, if you rebuild the example applications, be careful not to overwrite the original versions, because the versions that you build require VR-Link licenses.

12.2 - The f18 Program
Table of Contents
12.2.1 The f18 Configuration File
12.2.2 Firing Munitions
12.2.3 Reactions to Detonate Messages
12.2.4 Absolute Timestamping
12.2.5 Using a Modified FOM
The f18 program simulates a simple HLA or DIS vehicle.

By default, that vehicle is an F/A18, flying in a circle, just off the coast of California, USA, but you can control the entity type, location and route.

f18 generates predictable HLA entity update messages (or DIS entity state PDUs), so it is a useful tool for debugging applications that receive and interpret these messages. It can also fire munitions and react to detonations.

The f18 syntax is:

f18 -h

f18 [options...]

To exit f18, press q followed by Enter or Return.

The following table summarizes f18's command-line options.

f18 Command-Line Options
Option	Description
Protocol Independent Options
-a ID	For DIS, sets the second component of the entity ID to ID. By default, the entity ID is 1:2:1, however if you want to run multiple f18s at once, each needs a unique entity ID.For HLA specifies an entity ID.
-d seconds	Set the delay (in seconds) between the time f18 receives a detonation interaction (or PDU), and the time it broadcasts its final message and exits.
-D algorithm	Specifes the dead reckoning algorithm, where algorithm can be:
0 – Other
1 – Static
2 – Fixed rotation, positional DR, world coordinates
3 – Rotational DR, positional DR, world coordinates
4 – Rotational DR, velocital DR, world coordinates
5 – Fixed rotation, velocital DR, world coordinates.
-h	Displays a summary of command-line options, then exits.
-H degrees	Specifies the initial heading of the f18, in degrees.
-l file	Loads the specified MTL configuration file.
-L x,y,z	Specifies the initial position, as in topographic coordinates.
-M markings	Specifies the markings.
-n notify_level	Specifies the notification level for warnings.
-O lat,long	Specifies the reference latitude and longitude for the topographic coordinate system.
-r radius	Specifies the turn radius of the f18, in meters. Setting the radius to 0.0 causes the f18 to move in a straight line.
-s mps	Specifies the initial speed of the f18, in meters per second.
-T type	Specifies the entity type, as a string of the form: kind:domain:country:category:subcategory:specific:extra
-W x,y,z	Specifies the initial position in geocentric coordinates.
HLA Only Options
(-f | –fomMapperLib) libname
Specifies a FOM Mapper library name.
–fomMapperInitData data
Specifies FOM Mapper initialization data, if required.
–rprFomVersion version_number
Specifies the RPR FOM version. (0.5, 0.7, 0.8, 1.0, 2.0006, 2.0014, or 2.0017)
-F FED_file	Specifies the FED file. Default: federation_name.fed.
-N name	Specifies the HLA object name.
-n federate_name	Specifies the name of the federate.
-x ex-name	Sets the federation execution name. Default: .
DIS Only Options
-A address	Specifies the default destination IP address for outgoing PDUs.
-I	Use asynchronous IO.
-P portnum	Specifies the UDP port. Default: 3000.
–recvBufferSize size	Specifies the receive buffer size.
–sendBufferSize size	Specifies the send buffer size.
–siteId ID	Specifies the site ID.
-S address	Subscribes to the specified multicast addresses. Multiple -Ss can appear on a command line. Multicast is not supported on all platforms.
–mcastTtl ttl	Specifies the multicast time to live. This is the number of routers that a message can pass through.
-V version	Specifies the DIS protocol version contained in outgoing PDUs, where the version can be 4, 5,6 or 6.
-x ex-name	Specifies the exercise ID for DIS. Default: 1.
12.2.1 The f18 Configuration File
By default, f18 does not load the configuration file f18.mtl, instead relying on command line arguments for configurations. However, you may use the -l command line to specify a configuration from a file. For this still include f18.mtl as an example. This file sets many of the f18's default parameters, including notify level, dead-reckoning algorithm, and initial heading, position, and speed.

To change default parameters:

Use command-line options to override parameters.
Use the -l option to specify an alternate configuration file, such as "-l f18.mtl".
You can rebuild the f18 program or create a new application based on f18 that does not use a configuration file.

To write a variation of f18 that does not use a configuration file, remove the initMtl() call.

You can also specify a different configuration file in your code, at the DtcLoadLispFile() function call.

12.2.2 Firing Munitions
To cause the f18 to fire at another entity, press Enter or Return.

If other entities exist in the exercise, f18 issues a fire message directed at the closest one. Though there is no tracked munition, f18 issues a detonate message three seconds later to indicate that the target was hit.

To change the delay, edit the munitionFlightTime parameter in the f18.mtl file.

12.2.3 Reactions to Detonate Messages
The f18 reacts to detonation PDUs or RPR FOM detonation interactions. If a detonation occurs within the lethalDetonationRange, or if the detonation result is entity impact or entity proximate, the f18 is destroyed. Updates reflect a damage state of DamageDestroyed for a period of destroyedToFinalDelay seconds, at which point the entity leaves the exercise and f18 exits.

LethalDetonationRange defaults to 20 meters, and destroyedToFinalDelay defaults to zero. You can change these parameters in f18.mtl.

12.2.4 Absolute Timestamping
The value of the timeStampType flag in f18.mtl determines whether absolute or relative timestamps are used in f18's outgoing state update messages. The flag defaults to relative (0), but can be set to absolute (1). When the timeStampType is absolute, f18 dead-reckons remote entities based on their absolute timestamps, when applicable. Absolute timestamping should be used only when the local machine's clock is synchronized with the clock being used by other applications in the exercise for their absolute timestamps.

For more information about timestamps, please see 2.7.6 Timestamps.

12.2.5 Using a Modified FOM
The f18 example has a source file called config.cxx that shows how you can configure VR-Link to use a modified FOM. It shows how you can instruct VR-Link to represent position on the network as Z, Y, X, rather than X, Y, Z. For this purpose, we use a new attribute of the BaseEntity object class called ReversePosition instead of the default Position attribute, and a new parameter of the WeaponFire interaction class called ReverseFiringLocation instead of the default FiringLocation.

By default, this functionality is #ifdef'd out. But if you include the definition REVERSE=1 on your make line, when building f18, for example:

make REVERSE=1 f18
it will be compiled in. If you want to try this out, remember to modify the .fed file to reflect the expected changes before running the executable.

12.3 - Calling VR-Link from Other Languages
The simpleC example demonstrates how to use VR-Link from within a C language application.

It is in ./examples/simpleC. Since most other languages can interact with C, this should also serve as a starting point for applications written in other languages that use VR-Link.

12.4 - Launcher
The launcher example demonstrates use of articulated and attached parts in VR-Link for both DIS and HLA.

It is in the ./examples/test directory.

12.5 - netdumpDIS
netdumpDIS is a DIS debugging tool that displays the contents of arriving DIS PDUs in an easy-to-read format.

(Its HLA counterpart is 12.6 - netdumpHLA.)

netdumpDIS writes its output to stdout. For each PDU, netdumpDIS prints the number of PDUs it has received and the PDU's arrival time (relative to netdumpDIS's initialization).

netdumpDIS's usage is:

netdumpDIS [-c -errorChecking -h -v -r –verbose -A address -P port -S address –ignore_rest]

The following table describes the command-line options:

netdumpDIS Command-line Options
Option	Description
(– | –ignore_rest)	Ignore any remaining arguments on the command line. This is useful if you want to maintain a complete command-line syntax, but occasionally want to disable some of the options.
(-A | –destAddrString) address	Specifies a broadcast address from which netdumpDIS can listen for packets. This can be useful if you have two network cards on your computer, because you can tell netdumpDIS to use the secondary card.
-c	Clears the screen between PDUs. This option is especially useful for debugging single-entity applications. The screen is cleared between PDUs, so corresponding fields of successive PDUs appear in the same place. This makes changes in various parameters easily visible.
–errorChecking	Specifies that netdumpDIS does not try to print PDUs when the size indicated in the DIS header does not match the size of the packet received.
(-h | –help)	Displays a summary of command-line options, then exits.
(-P | –disPort) portnum	Specifies the UDP port. Default: 3000.
(-r | –raw)	Print raw data.
-S address	Subscribes to the specified multicast addresses. You can specify multiple addresses on a command line. Multicast is not supported on all platforms.
(-v | –version)	Display version information and exit.
–verbose	Specifies verbose mode for message output.
If netdumpDIS has been linked with libvl in the ./binDIS directory, it prints all fields of DIS 4, 5, and 6 PDUs.
When it receives PDUs of the wrong DIS version, netdumpDIS prints the DIS header information and a hex dump of the rest of the PDU.
netdumpDIS prints version information.

12.6 - netdumpHLA
netdumpHLA listens to an HLA federation execution, subscribes to all object and interaction classes in the FOM, and prints out data whenever it receives an attribute update or interaction.

netdumpHLA handles interactions similarly to netdumpDIS (netdumpDIS) – it interprets and prints out the data in the interaction.

When netdumpHLA receives an attribute update message, it is decoded into a DtEntityStateRepository, then the state repository is printed.

Note
netdumpHLA prints default values (usually zero or false) for attributes not contained in the update. A list appears above the state information, showing the names of attributes actually contained in the update.
The usage for netdumpHLA is:

{netdumpHLA13 | netdumpHLA1516 | netdumpHLA15161e} [– -c -F -f libname –fomMapperInitData data –rprFomVersion version_number -h -M -m -n -r -R -v -x exec-name –ignore_rest]

The following table describes the command-line options:

netdumpHLA Command-line Options
Option	Description
(– | –ignore_rest)	Ignore any remaining arguments on the command line. This is useful if you want to maintain a complete command-line syntax, but occasionally want to disable some of the options.
(-c | –clearScreen)	Clears the screen between messages (updates or interactions). This option is especially useful for debugging single entity applications. The screen is cleared between messages, so corresponding fields of successive messages appear in the same place. This makes changes in various parameters easily visible.
(-f | –fomMapperLib) libname	Specifies a FOM Mapper library name
–fomMapperInitData data	Specifies FOM Mapper initialization data, if required.
-F fed_file_name	Specifies the FED file to use. Default: federation_execution.fed.
(-h | –help)	Displays a summary of command-line options, then exits.
(-m | –printMom)	Subscribes to MOM classes.
(-M | –noFullReport)	Disable printing of update specifics.
-n	Prints only the objects that have changed.
(-r | –raw)	Runs netdumpHLA in raw mode. For more information, please see the paragraph following this table.
(-R | –rprFomVersion) version_number	Specifies the RPR FOM version. (0.5, 0.7, 0.8, 1.0, 2.0006, 2.0014, or 2.0017)
(-v | –version)	Display version information and exit.
(-x | –execName) exec-name	Specifies the name of the federation execution to be monitored. Default: VR-Link.
When you run netdumpHLA with the -r option, for each attribute update or interaction received, it prints the name of the attribute, the size of the value of that attribute, and a hexadecimal dump of the value of the attribute.

netdumpHLA can print incoming HLA data in a completely FOM-independent manner. It subscribes to every class in the FED file (including MOM classes if you use the -m argument). If an update or interaction represents a class that VR-Link "knows" how to decode, (includes all BaseEntity subclasses, Aggregates, Fire, Detonate and Collision Interactions) the data is printed as the correct data types (unless you are using raw mode). If the message represents a class that VR-Link cannot decode, netdumpHLA prints the name of the class, and the name, size and hex value of all attributes and parameters.

12.7 - talk and listen
talk and listen are simple send-only and receive-only programs.

They demonstrate many VR-Link fundamentals.

talk simulates the flight of an F18 aircraft. listen repeatedly prints an entity's updated position, and if a fire PDU or interaction occurs, prints the entity ID of the attacker. Both programs are written for protocol-independence.

For detailed descriptions, please see 2.9.1 A Listen-Only Example, and 2.9.2 A Send-Only Example.

2.9 - Basic VR-Link Examples
Table of Contents
2.9.1 A Listen-Only Example
2.9.2.1 Connecting to An Exercise
2.9.1.2 Managing State and Interaction Information
2.9.1.3 Tracking Entities
2.9.1.4 Managing Time
2.9.1.5 Listening to the Network
2.9.2 A Send-Only Example
2.9.2.2 Managing Entities
2.9.2.3 Sending Interactions
2.9.2.4 Sending State Messages
This section lists and describes two simple VR-Link applications. The first is a listen-only application that observes an exercise without simulating any entity on the network. The second is a write-only program that does not process information about remote entities.

Note
The source code for both examples is included with VR-Link.
2.9.1 A Listen-Only Example
The Listen-Only is an application that just listens to the network. This application can be compiled for either DIS or HLA. The only protocol-specific code is contained in the #if statement that starts at line 27.

With each iteration of the loop, the program prints an entity's updated, dead-reckoned position in topographic coordinates. In addition, if a fire PDU or interaction is detected on the network, the program prints a message showing the entity ID of the attacker.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vlutil/vlProcessControl.h>
4  #include <vl/reflectedEntityList.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/reflectedEntity.h>
7  #include <vl/fireInteraction.h>
8  #include <vl/topoView.h>
9  #include <iostream>
10 
11 int keybrdTick(void);
12 
13 // Define a callback to process fire interactions.
14 void fireCb(DtFireInteraction* fire, void* /*usr*/)
15 {
16    std::cout << "Fire Interaction from " 
17          <<  fire->attackerId().string() << std::endl;
18 }
19 
20 int main(int argc, char** argv)
21 {
22    try
23    {
24       // Create a connection to the exercise or federation execution.
25       DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
26 
27       #if DtDIS
28       appInit.setUseAsynchIO(true);
29       #endif
30 
31       appInit.parseCmdLine();
32 
33       DtExerciseConn exConn(appInit);
34 
35       // Register a callback to handle fire interactions.
36       DtFireInteraction::addCallback(&exConn, fireCb, NULL);
37 
38       // Create an object to manage entities that we hear about 
39       // on the network.
40       DtReflectedEntityList rel(&exConn);
41     
42       // Initialize VR-Link time.
43       DtClock* clock = exConn.clock();
44 
45       int forever = 1;
46       while (forever)
47       {
48          // Check if user hit 'q' to quit.
49          if (keybrdTick() == -1)
50             break;
51 
52          // Tell VR-Link the current value of simulation time.
53          clock->setSimTime(clock->elapsedRealTime());
54 
55          // Process any incoming messages
56          exConn.drainInput();
57 
58          // Find the first entity in the reflected entity list
59          DtReflectedEntity *first = rel.first();
60 
61          if (first)
62          {
63             // Grab its state repository, where we can inspect its data.
64             DtEntityStateRepository *esr = first->entityStateRep();
65 
66             // Create a topographic view on the state repository, so we 
67             // can look at position information in topographic
68             // coordinates.
69             double refLatitude  = DtDeg2Rad(  35.699760);
70             double refLongitude = DtDeg2Rad(-121.326577);
71             DtTopoView topoView(esr, refLatitude, refLongitude);
72    
73             // Print the position.
74             // Since it returns a DtString, we need to force it to 
75             // const char* with a cast.
76             std::cout << "Position of first entity: "
77                <<  topoView.location().string() << std::endl;
78          }
79       
80          // Sleep till next iteration.
81          DtSleep(0.1);
82       }
83       return 0;
84    }
85    DtCATCH_AND_WARN(std::cout);
86 }
87 
88 int keybrdTick()
89 {
90    char *keyPtr = DtPollBlockingInputLine();
91    if (keyPtr && (*keyPtr == 'q' || *keyPtr == 'Q')) 
92       return -1;  
93    else
94       return 0;
95 }
2.9.2.1 Connecting to An Exercise
In lines 22-25, the program creates an exercise connection (DtExerciseConn). This connection serves as the program's interface to an exercise. DtExerciseConn has several constructors. In this example, we create a DtVrlApplicationInitializer and pass it to the DtExerciseConn. Use of a DtVrlApplicationInitializer provides support for command line arguments. The default protocol-specific initialization values are set in the

DtVrlApplicationInitializer and its base class, DtExerciseConnInitializer. This is the only protocol-specific part of the code.

If you want to specify initialization values in the DtExerciseConn, you would use code similar to the following:

int main()
{
   // Create a connection to the exercise or federation execution
#if DtHLA
   DtString execName("VR-Link");
   DtString fedName("VR-Link listen"); 
   DtExerciseConn exConn(execName, fedName, new DtSimpleRprFomMapper);
#elif DtDIS
   int port           = 3000;
   int exerciseId     = 1; 
   int siteId         = 1;
   int applicationNum = 15;
   DtExerciseConn exConn(port, exerciseId, siteId, applicationNum,
                              0,             // No Status, any error will be fatal
                              true);            // use Async IO
#endif 
2.9.1.2 Managing State and Interaction Information
Applications based on VR-Link typically use callbacks to handle incoming interactions such as fire, detonations, and collisions. For example, a callback named fireCb is registered with the DtFireInteraction class at line 36. This callback (defined at line 14) prints a message containing the attacker ID. It executes whenever the exercise connection receives a Fire PDU or interaction during a call to drainInput().

2.9.1.3 Tracking Entities
We create a reflected entity list in line 40 to keep track of entities found on the network. The entity list tracks the arrival and departure of entities, performs dead reckoning, manages time outs, and performs other entity-tracking tasks.

2.9.1.4 Managing Time
On line 43 we obtain a pointer to the simulation clock from the exercise connection.

2.9.1.5 Listening to the Network
At the start of each iteration, the program sets VR-Link simulation time (line 53) to provide a common time value for use by time-related operations that occur within an iteration of the loop (such as the dead-reckoning of multiple entities).

The drainInput() call (line 56) reads and processes any messages arriving through the exercise connection. This call triggers the execution, if needed, of any callbacks you have registered for that exercise connection.

In line 59, the program finds the first entity in the entity list, then in line 64, retrieves the pointer to the entity's entity state repository. Line 71 creates a topographic view of that entity state repository, allowing us to retrieve its position data in topographic coordinates rather than geocentric. (Lines 69 and 70 hard code the coordinates for this example.)

Line 76 obtains and prints the dead-reckoned entity location.

2.9.2 A Send-Only Example
The Send-Only application simulates the flight of an F18 aircraft. The program begins by sending a fire PDU or HLA fire interaction. Thereafter, the F18 flies north for 10 seconds, updating its position by sending DIS entity state PDUs or HLA attribute updates.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vl/topoView.h>
4  #include <vl/entityPublisher.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/fireInteraction.h>
7  #include <vl/iffPublisher.h>
8  #include <vlpi/EntityTypes.h>
9   #include <vlutil/vlProcessControl.h>
10 #include <iostream>
11 
12 int main(int argc, char** argv)
13 {
14 
15    try
16    {
17       // Create a connection to the exercise or federation execution.
18       DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");
19 
20       // Change some defaults
21       #if DtDIS
22       appInit.setUseAsynchIO(true);
23       #endif
24 
25       appInit.parseCmdLine();
26 
27       DtExerciseConn exConn(appInit);
28 
29       DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
30          DtUnitedStates, DtFighter, DtF18, 0, 0);
31 
32       // Create an entity publisher for the entity we are simulating.
33       DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
34          DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 
35 
36       // Hold on to the entity's state repository, where we can set data.
37       DtEntityStateRepository *esr = entityPub.entityStateRep();
38 
39       // Create a topographic view on the state repository, so we 
40       // can set position information in topographic coordinates.
41       double refLatitude  = DtDeg2Rad(  35.699760);
42       double refLongitude = DtDeg2Rad(-121.326577);
43       DtTopoView topoView(esr, refLatitude, refLongitude);
44    
45       // We can use the ESR to set state.
46       esr->setMarkingText("VR-Link");
47       topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));
48 
49       // Initialize VR-Link time.
50       DtClock* clock = exConn.clock();
51    
52       DtVector position(0, 0, -100);
53       DtVector velocity(20, 0, 0);
54 
55       // Send a Fire Interaction.
56       DtFireInteraction fire;
57       fire.setAttackerId(entityPub.globalId());
58       exConn.sendStamped(fire);
59    
60       // Main loop
61       DtTime dt = 0.05;
62       DtTime simTime = 0;
63       while (simTime <= 10.0)
64       {
65          // Tell VR-Link the current value of simulation time.
66          clock->setSimTime(simTime);
67 
68          // Process any incoming messages.
69          exConn.drainInput();
70 
71          // Set the current position information.
72          topoView.setLocation(position);
73          topoView.setVelocity(velocity);
74 
75          // Call tick, which insures that any data that needs to be 
76          // updated is sent.
77          entityPub.tick();
78       
79          // Set up for next iteration.
80          position[0] += velocity[0] * dt;
81          simTime     += dt;
82       
83          // Wait till real time equals simulation time of next step
84          DtSleep(simTime - clock->elapsedRealTime()); 
85       }
86    
87    }
88    DtCATCH_AND_WARN(std::cout);
89    return 0;
90 }
2.9.2.1 Connecting to An Exercise
Like the listen-only example, this program creates a DtExerciseConn to provide an interface to the RTI or DIS network (lines 17 through 27).

2.9.2.2 Managing Entities
Line 29 defines the entity type the F18 will use.

To be visible to other applications in the exercise, each locally-simulated entity requires a DtEntityPublisher, created in line 33. The entity publisher manages the generation of messages for this particular entity. It provides an entity state repository where you can set state values, and a tick() function, which causes state information to be sent to the network if necessary.

Line 37 sets up a pointer to the entity state repository, then line 43 creates a topographic view on that repository. This lets us set the entity's positional data using topographic coordinates, rather than the default geocentric coordinates. (Lines 41 and 42 hard code the coordinates for this example.) Line 46 shows an example of storing a non-positional state value in the repository.

2.9.2.3 Sending Interactions
An example of sending an interaction appears in lines 56-58. You can send the interaction using the exercise connection's sendStamped() function.

Note
You can use sendStamped() to send state updates, but it is preferable to let the entity publisher send state updates for you, using data in the entity state repository, as shown in lines 72 through 77.
2.9.2.4 Sending State Messages
The main loop executes twenty times per second for ten seconds. As in the listen-only example, this program sets simulation time at the start of each iteration (line 66).

Note
While this program's main purpose is to demonstrate the sending of data to the network, it is not a true send-only application. Incoming data is also processed with the drainInput() call on line 69. This call is required for HLA, because this is where we tick the RTI.
The program updates the F18's positional data in its entity state repository in lines 72 and 73, and ticks the entity publisher in line 77 to send the updated data onto the network. Lines 72 and 73 set topographic coordinates through a view, which VR-Link converts to geocentric coordinates.

Thereafter, the only remaining tasks are to increment the F18's position, increment the simulation time, and sleep until it is time to begin the next iteration.

2.9 - Basic VR-Link Examples
Table of Contents
2.9.1 A Listen-Only Example
2.9.2.1 Connecting to An Exercise
2.9.1.2 Managing State and Interaction Information
2.9.1.3 Tracking Entities
2.9.1.4 Managing Time
2.9.1.5 Listening to the Network
2.9.2 A Send-Only Example
2.9.2.2 Managing Entities
2.9.2.3 Sending Interactions
2.9.2.4 Sending State Messages
This section lists and describes two simple VR-Link applications. The first is a listen-only application that observes an exercise without simulating any entity on the network. The second is a write-only program that does not process information about remote entities.

Note
The source code for both examples is included with VR-Link.
2.9.1 A Listen-Only Example
The Listen-Only is an application that just listens to the network. This application can be compiled for either DIS or HLA. The only protocol-specific code is contained in the #if statement that starts at line 27.

With each iteration of the loop, the program prints an entity's updated, dead-reckoned position in topographic coordinates. In addition, if a fire PDU or interaction is detected on the network, the program prints a message showing the entity ID of the attacker.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vlutil/vlProcessControl.h>
4  #include <vl/reflectedEntityList.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/reflectedEntity.h>
7  #include <vl/fireInteraction.h>
8  #include <vl/topoView.h>
9  #include <iostream>
10 
11 int keybrdTick(void);
12 
13 // Define a callback to process fire interactions.
14 void fireCb(DtFireInteraction* fire, void* /*usr*/)
15 {
16    std::cout << "Fire Interaction from " 
17          <<  fire->attackerId().string() << std::endl;
18 }
19 
20 int main(int argc, char** argv)
21 {
22    try
23    {
24       // Create a connection to the exercise or federation execution.
25       DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
26 
27       #if DtDIS
28       appInit.setUseAsynchIO(true);
29       #endif
30 
31       appInit.parseCmdLine();
32 
33       DtExerciseConn exConn(appInit);
34 
35       // Register a callback to handle fire interactions.
36       DtFireInteraction::addCallback(&exConn, fireCb, NULL);
37 
38       // Create an object to manage entities that we hear about 
39       // on the network.
40       DtReflectedEntityList rel(&exConn);
41     
42       // Initialize VR-Link time.
43       DtClock* clock = exConn.clock();
44 
45       int forever = 1;
46       while (forever)
47       {
48          // Check if user hit 'q' to quit.
49          if (keybrdTick() == -1)
50             break;
51 
52          // Tell VR-Link the current value of simulation time.
53          clock->setSimTime(clock->elapsedRealTime());
54 
55          // Process any incoming messages
56          exConn.drainInput();
57 
58          // Find the first entity in the reflected entity list
59          DtReflectedEntity *first = rel.first();
60 
61          if (first)
62          {
63             // Grab its state repository, where we can inspect its data.
64             DtEntityStateRepository *esr = first->entityStateRep();
65 
66             // Create a topographic view on the state repository, so we 
67             // can look at position information in topographic
68             // coordinates.
69             double refLatitude  = DtDeg2Rad(  35.699760);
70             double refLongitude = DtDeg2Rad(-121.326577);
71             DtTopoView topoView(esr, refLatitude, refLongitude);
72    
73             // Print the position.
74             // Since it returns a DtString, we need to force it to 
75             // const char* with a cast.
76             std::cout << "Position of first entity: "
77                <<  topoView.location().string() << std::endl;
78          }
79       
80          // Sleep till next iteration.
81          DtSleep(0.1);
82       }
83       return 0;
84    }
85    DtCATCH_AND_WARN(std::cout);
86 }
87 
88 int keybrdTick()
89 {
90    char *keyPtr = DtPollBlockingInputLine();
91    if (keyPtr && (*keyPtr == 'q' || *keyPtr == 'Q')) 
92       return -1;  
93    else
94       return 0;
95 }
2.9.2.1 Connecting to An Exercise
In lines 22-25, the program creates an exercise connection (DtExerciseConn). This connection serves as the program's interface to an exercise. DtExerciseConn has several constructors. In this example, we create a DtVrlApplicationInitializer and pass it to the DtExerciseConn. Use of a DtVrlApplicationInitializer provides support for command line arguments. The default protocol-specific initialization values are set in the

DtVrlApplicationInitializer and its base class, DtExerciseConnInitializer. This is the only protocol-specific part of the code.

If you want to specify initialization values in the DtExerciseConn, you would use code similar to the following:

int main()
{
   // Create a connection to the exercise or federation execution
#if DtHLA
   DtString execName("VR-Link");
   DtString fedName("VR-Link listen"); 
   DtExerciseConn exConn(execName, fedName, new DtSimpleRprFomMapper);
#elif DtDIS
   int port           = 3000;
   int exerciseId     = 1; 
   int siteId         = 1;
   int applicationNum = 15;
   DtExerciseConn exConn(port, exerciseId, siteId, applicationNum,
                              0,             // No Status, any error will be fatal
                              true);            // use Async IO
#endif 
2.9.1.2 Managing State and Interaction Information
Applications based on VR-Link typically use callbacks to handle incoming interactions such as fire, detonations, and collisions. For example, a callback named fireCb is registered with the DtFireInteraction class at line 36. This callback (defined at line 14) prints a message containing the attacker ID. It executes whenever the exercise connection receives a Fire PDU or interaction during a call to drainInput().

2.9.1.3 Tracking Entities
We create a reflected entity list in line 40 to keep track of entities found on the network. The entity list tracks the arrival and departure of entities, performs dead reckoning, manages time outs, and performs other entity-tracking tasks.

2.9.1.4 Managing Time
On line 43 we obtain a pointer to the simulation clock from the exercise connection.

2.9.1.5 Listening to the Network
At the start of each iteration, the program sets VR-Link simulation time (line 53) to provide a common time value for use by time-related operations that occur within an iteration of the loop (such as the dead-reckoning of multiple entities).

The drainInput() call (line 56) reads and processes any messages arriving through the exercise connection. This call triggers the execution, if needed, of any callbacks you have registered for that exercise connection.

In line 59, the program finds the first entity in the entity list, then in line 64, retrieves the pointer to the entity's entity state repository. Line 71 creates a topographic view of that entity state repository, allowing us to retrieve its position data in topographic coordinates rather than geocentric. (Lines 69 and 70 hard code the coordinates for this example.)

Line 76 obtains and prints the dead-reckoned entity location.

2.9.2 A Send-Only Example
The Send-Only application simulates the flight of an F18 aircraft. The program begins by sending a fire PDU or HLA fire interaction. Thereafter, the F18 flies north for 10 seconds, updating its position by sending DIS entity state PDUs or HLA attribute updates.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vl/topoView.h>
4  #include <vl/entityPublisher.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/fireInteraction.h>
7  #include <vl/iffPublisher.h>
8  #include <vlpi/EntityTypes.h>
9  #include <vlutil/vlProcessControl.h>
10 #include <iostream>
11 
12 int main(int argc, char** argv)
13 {
14 
15    try
16    {
17       // Create a connection to the exercise or federation execution.
18       DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");
19 
20       // Change some defaults
21       #if DtDIS
22       appInit.setUseAsynchIO(true);
23       #endif
24 
25       appInit.parseCmdLine();
26 
27       DtExerciseConn exConn(appInit);
28 
29       DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
30          DtUnitedStates, DtFighter, DtF18, 0, 0);
31 
32       // Create an entity publisher for the entity we are simulating.
33       DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
34          DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 
35 
36       // Hold on to the entity's state repository, where we can set data.
37       DtEntityStateRepository *esr = entityPub.entityStateRep();
38 
39       // Create a topographic view on the state repository, so we 
40       // can set position information in topographic coordinates.
41       double refLatitude  = DtDeg2Rad(  35.699760);
42       double refLongitude = DtDeg2Rad(-121.326577);
43       DtTopoView topoView(esr, refLatitude, refLongitude);
44    
45       // We can use the ESR to set state.
46       esr->setMarkingText("VR-Link");
47       topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));
48 
49       // Initialize VR-Link time.
50       DtClock* clock = exConn.clock();
51    
52       DtVector position(0, 0, -100);
53       DtVector velocity(20, 0, 0);
54 
55       // Send a Fire Interaction.
56       DtFireInteraction fire;
57       fire.setAttackerId(entityPub.globalId());
58       exConn.sendStamped(fire);
59    
60       // Main loop
61       DtTime dt = 0.05;
62       DtTime simTime = 0;
63       while (simTime <= 10.0)
64       {
65          // Tell VR-Link the current value of simulation time.
66          clock->setSimTime(simTime);
67 
68          // Process any incoming messages.
69          exConn.drainInput();
70 
71          // Set the current position information.
72          topoView.setLocation(position);
73          topoView.setVelocity(velocity);
74 
75          // Call tick, which insures that any data that needs to be 
76          // updated is sent.
77          entityPub.tick();
78       
79          // Set up for next iteration.
80          position[0] += velocity[0] * dt;
81          simTime     += dt;
82       
83          // Wait till real time equals simulation time of next step
84          DtSleep(simTime - clock->elapsedRealTime()); 
85       }
86    
87    }
88    DtCATCH_AND_WARN(std::cout);
89    return 0;
90 }
2.9.2.1 Connecting to An Exercise
Like the listen-only example, this program creates a DtExerciseConn to provide an interface to the RTI or DIS network (lines 17 through 27).

2.9.2.2 Managing Entities
Line 29 defines the entity type the F18 will use.

To be visible to other applications in the exercise, each locally-simulated entity requires a DtEntityPublisher, created in line 33. The entity publisher manages the generation of messages for this particular entity. It provides an entity state repository where you can set state values, and a tick() function, which causes state information to be sent to the network if necessary.

Line 37 sets up a pointer to the entity state repository, then line 43 creates a topographic view on that repository. This lets us set the entity's positional data using topographic coordinates, rather than the default geocentric coordinates. (Lines 41 and 42 hard code the coordinates for this example.) Line 46 shows an example of storing a non-positional state value in the repository.

2.9.2.3 Sending Interactions
An example of sending an interaction appears in lines 56-58. You can send the interaction using the exercise connection's sendStamped() function.

Note
You can use sendStamped() to send state updates, but it is preferable to let the entity publisher send state updates for you, using data in the entity state repository, as shown in lines 72 through 77.
2.9.2.4 Sending State Messages
The main loop executes twenty times per second for ten seconds. As in the listen-only example, this program sets simulation time at the start of each iteration (line 66).

Note
While this program's main purpose is to demonstrate the sending of data to the network, it is not a true send-only application. Incoming data is also processed with the drainInput() call on line 69. This call is required for HLA, because this is where we tick the RTI.
The program updates the F18's positional data in its entity state repository in lines 72 and 73, and ticks the entity publisher in line 77 to send the updated data onto the network. Lines 72 and 73 set topographic coordinates through a view, which VR-Link converts to geocentric coordinates.

Thereafter, the only remaining tasks are to increment the F18's position, increment the simulation time, and sleep until it is time to begin the next iteration.

13 - VR-Link Utility Classes
VR-Link has utility classes that help make it easier to write a simulation application.

These utilities include coordinate conversion routines, matrix and vector classes and functions, and time-related functions.

13.1 - Vector and Matrix Classes
13.2 - Orientation, Euler Angles, and DtTaitBryan
13.3 - Coordinate Conversions
13.4 - Creating Linked Lists with DtList
13.5 - Diagnostic Utilities
13.6 - The DtException Class
13.7 - Functions for Manipulating IP Addresses
13.8 - Miscellaneous Global Functions

13.1 - Vector and Matrix Classes
Table of Contents
13.1.1 Using the DtVector Class
13.1.2 Using the DtDcm Class
13.1.3 DtVector and DtDcm Semantics
13.1.4 Vector and Matrix Manipulation Functions
This section describes the classes that you use for vectors and matrices, DtVector and DtDcm.

13.1.1 Using the DtVector Class
You can use the DtVector class (defined in vlVector.h) to represent vectors in three dimensional space.

You can initialize DtVectors with their three components, as in:

DtVector vec(10.0, 20.0, 30.0);
The default constructor, which takes no arguments, constructs a vector containing three zeros.

The copy constructor, assignment operator, equivalence, and subscripting operators are defined, so you can do things like:

DtVector vec(10.0, 20.0, 30.0);
DtVector vec2(vec);
DtVector vec3 = vec;
DtVector vec4;
vec4 = vec;
if (vec == vec2) {...}
and:

double x = vec[0];
double y = vec[1];
double z = vec[2];
or:

vec[0] = x;
vec[1] = y;
vec[2] = z;
DtVector also has a string() member function that returns a text representation of the contents of the vector, for example:

{          10.000,          20.000,          30.000}
The following static member functions of DtVector return some commonly used vectors:

zero()         {0,0,0}
i()         {1,0,0}
j()         {0,1,0}
k()         {0,0,1}
ones()         {1,1,1}
13.1.2 Using the DtDcm Class
DtDcm (defined in vlDcm.h) is used to represent 3x3 matrices. The name DCM stands for direction cosine matrix, and reflects the fact that we often use the class to store that particular type of matrix to represent an orientation. (Alternatively, you can represent orientation as a set of three Euler angles in the Tait Bryan sequence, using the DtTaitBryan class. For more information, please see 13.2 - Orientation, Euler Angles, and DtTaitBryan.)

A DtDcm can be constructed from its components, as in:

DtDcm mat(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);
or from three component vectors:

DtDcm ident(DtVector::i(), DtVector::j(), DtVector::k());
If the constructor is used with no arguments, a matrix containing nine zeros is constructed.

The copy constructor and assignment operators are defined, so you can do things like:

DtDcm mat(1,2,3,4,5,6,7,8,9);
DtDcm mat2(mat);
DtDcm mat3 = mat;
DtDcm mat4;
mat4 = mat;
The subscripting operator is defined as well, so you can obtain any of the three vectors that make up the matrix:

DtVector firstRow = mat[0];
In conjunction with DtVector's subscripting operator, the familiar double subscript syntax is supported:

double upperLeft = mat[0][0];
double lowerRight = mat[2][2];
or:

mat[0][0] = 10.0;
mat[2][2] = 20.0;
DtDcm has static member functions, zero() and identity(), that return the zero matrix and identity matrix respectively.

13.1.3 DtVector and DtDcm Semantics
Although VR-Link functions usually employ pass-by-pointer semantics when expecting objects that they will modify, functions that operate on DtVectors and DtDcms are exceptions. These objects are usually passed to VR-Link functions by reference, so that the subscripting operator can be used without the awkwardness of having to dereference a pointer. In functions that do not change DtVectors and DtDcms, they are passed by const reference, just like other VR-Link classes. The table lists typedefs used to make this explicit.

DtVector and DtDcm typedefs
Function	Equivalent function
DtVectorRef	DtVector&
DtDcmRef	DtDcm&
DtConstVector	const DtVector&
DtConstDcm	const DtDcm&
DtVector can be passed to a function that takes a DtVectorRef or DtConstVector, while a DtDcm can be passed to a function that takes a DtDcmRef or DtConstDcm.

13.1.4 Vector and Matrix Manipulation Functions
LibMatrix.h contains C-style functions that operate on DtVector and DtDcm. The standard operations are included, such as:

addition
subtraction
multiplication
scaling
dot products
cross products
negation
normalization
determinant calculation
transpose
inverse.

13.2 - Orientation, Euler Angles, and DtTaitBryan
Table of Contents
13.2.1 Converting Between Euler Angles and Matrix Representation
Although direction cosine matrices are often used in VR-Link to represent orientation, an alternative representation is a set of three Euler angles.

Euler angles represent the orientation of a body in space with respect to a certain coordinate system as three ordered rotations needed to go from the reference coordinate system to the body coordinate system.

DIS and the HLA RPR FOM use Euler angles to represent the orientation of an entity with respect to the geocentric coordinate axes. (The body coordinate system is defined by X out the front, Y out the right side, Z out the bottom of the entity.)

There are many possible ways to order the three rotations, but the one used by DIS and the RPR FOM, and hence VR-Link, is known as the Tait-Bryan sequence. The first rotation is about the Z axis, the second about the new Y axis, and the third about the newest X axis. The three angles are usually denoted by psi, theta, and phi respectively.

Note
These three angles do not necessarily correspond to the familiar heading, pitch, and roll of an entity. Euler angles correspond to heading, pitch, and roll only when the reference coordinate system is a topographic system. The Euler angles sent in DIS entity state PDUs or RPR FOM entity updates use the geocentric coordinate system as a reference, and thus do not correspond to heading, pitch, and roll. (For information about converting between geocentric-reference Euler angles and topographic-reference Euler angles, please see 13.3 - Coordinate Conversions.)
VR-Link's DtTaitBryan class (defined in vlTaitBryan.h) is used to represent a set of Euler angles. A DtTaitBryan can be constructed from its three component angles, specified in radians, for example:

DtTaitBryan angles(3.14, 0.0, 1.57);
The class has the following inspector and mutator functions that provide access to the individual angles:

psi(), setPsi()
theta(), setTheta()
phi(), setPhi().
The assignment operator, equality operators, and copy constructor are implemented for DtTaitBryan as well. The string() member function provides a string representation of the contents of the object, in a similar fashion to DtVector::string().

13.2.1 Converting Between Euler Angles and Matrix Representation
Euler.h contains functions that convert between the two representations of orientation.

Note
These functions are not converting orientations from one coordinate system to another; they are converting between two ways of expressing an orientation within a given coordinate system.
Given a set of Euler angles that represent the orientation of a body with respect to some reference frame (for example, the geocentric frame, or a topographic frame), DtEuler_to_BodyToRef() produces a rotation matrix (or DtDcm) that can rotate from body coordinates to reference coordinates, while DtEuler_to_RefToBody() produces its inverse – a matrix that can rotate from reference to body coordinates.

For example:

DtTaitBryan geocEulerAngles(...);
DtDcm bodyToGeoc;
DtEuler_to_BodyToRef(geocEulerAngles, bodyToGeoc);
The functions DtBodyToRef_to_Euler(), and DtRefToBody_to_Euler() go the other way – producing Euler angles from the matrix representation.

13.3 - Coordinate Conversions
Table of Contents
13.3.1 Geocentric Coordinates
13.3.2 Geodetic Coordinates
13.3.2.1 Choosing a Reference Ellipsoid
13.3.3 Topographic Coordinates
13.3.3.1 DtCoordTransform
13.3.3.2 Heading, Pitch, and Roll
13.3.4 UTM Coordinates
13.3.4.1 Using DtUtmInit()
13.3.5 Differences Between UTM and Topographic Coordinates
13.3.6 Lower Level Coordinate Conversion Functions
VR-Link supports several coordinate systems and provides classes and functions for converting locations, vectors, and orientations from one system to another.

13.3.1 Geocentric Coordinates
DIS and the RPR FOM in HLA specify that world locations, velocities, accelerations and orientations be represented with respect to a right-hand geocentric Cartesian coordinate system. The origin of this geocentric coordinate system is the center of the earth. The positive X-axis passes through the prime meridian at the equator; the positive Y-axis passes through 90 degrees east longitude at the equator; and the positive Z-axis passes though the north pole (as illustrated below.)

The DtVector class is typically used to represent locations and vectors in geocentric coordinates, while DtTaitBryan or DtDcm is used to represent orientation.


geocentriccoordinatesystem.png
Geocentric Coordinate System
13.3.2 Geodetic Coordinates
Geodetic coordinates are another means of specifying location in the world. VR-Link geodetic coordinates consist of latitude and longitude in radians, and altitude in meters above a certain reference ellipsoid, for example, the surface of the earth at sea level.

VR-Link uses the class DtGeodeticCoord (defined in geodeticCoord.h) to represent geodetic coordinates. A DtGeodeticCoord can be initialized from a latitude, longitude, and altitude. Negative latitudes are south latitudes; negative longitudes are west longitudes.

DtGeodeticCoord myLoc(DtDeg2Rad(45.0), DtDeg2Rad(30.0), 1000.0);
If the default constructor is used, the resulting object represents a latitude, longitude, and altitude of zero.

DtGeodeticCoord has the following inspectors and mutators to get and set values for the individual components of a geodetic coordinate:

lat(), setLat()
lon(), setLon()
alt(), setAlt().
DtGeodeticCoord also has member functions that enable you to convert to and from geocentric coordinates. DtGeodeticCoord::geocentric() returns the geocentric equivalent of a geodetic coordinate. For example:

DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0);
DtVector geoc = geod.geocentric();
After these lines of code, geoc will contain the coordinate:

{-960122.075, 5445122.868, 3170873.735}

which represents the same point in space as 30 degrees north latitude, 100 degrees east longitude, 1000 meters altitude.

A similar function is DtGeodeticCoord::getGeocentric(), which, rather than returning a geocentric coordinate, sets the value of an existing DtVector, for example:

DtGeodeticCoord geod(DtDeg2Rad(30.0), DtDeg2Rad(100.0), 1000.0);
DtVector geoc;
geod.getGeocentric(geoc);
Going in the other direction, DtGeodeticCoord::setGeocentric() sets the value of a DtGeodeticCoord to the latitude/longitude/altitude equivalent of a given geocentric coordinate:

DtVector geoc(-960122.075, 5445122.868, 3170873.735);
DtGeodeticCoord geod;
geod.setGeocentric(geoc);
Also in geodeticCoord.h, are the C-style functions DtGeocToGeod() and DtGeocToGeod(), which you can use instead of the member functions described previously, to convert between geocentric and geodetic coordinates, although their use is discouraged in favor of the member functions.

13.3.2.1 Choosing a Reference Ellipsoid
The default reference ellipsoid used for geocentric to geodetic conversions is WGS84, but this is configurable through the function DtUseMapDatum(), declared in geodeticCoord.h. Any DtMapDatum can be passed to this function. DtMapDatum is defined as:

typedef struct DtSpheroid
{
DtFloat64 semiMajor; // semimajor axis of the ellipsoid, in meters
DtFloat64 semiMinor; // semiminor axis of the ellipsoid, in meters
} DtSpheroid;
typedef struct DtMapDatum
{
   DtSpheroid spheroid;
   DtFloat64 datumShift[3]; // added to WGS84 to get GCC in this datum
} DtMapDatum;
VR-Link has the following DtMapDatums pre-defined in mapDatum.h:

DtWGS84, DtED50, DtNASANAD27, DtNASBNAD27, DtCONUSNAD27.
If you want to use the ED50 reference, for example, try:

DtUseMapDatum(&DtED50);
13.3.3 Topographic Coordinates
VR-Link defines a topographic coordinate system as a right-handed Cartesian coordinate system whose X-Y plane is tangent to the earth's surface at the origin, with the positive X-axis pointing north, the positive Y-axis pointing east, and the positive Z-axis pointing down (as illustrated below). Obviously, there are an infinite number of topographic coordinate systems – one for each point on the earth's surface.

topographiccoordinatesystem.png
Topographic coordinate system
A DtVector is usually used in VR-Link to represent a topographic coordinate.

13.3.3.1 DtCoordTransform
The easiest way to convert between geocentric and topographic coordinates is by using a DtCoordTransform object (defined in LibMatrix.h). A DtCoordTransform is an object that can transform locations, vectors, or orientations from one Cartesian coordinate system to another.

In general, a DtCoordTransform can be constructed by passing to its constructor the origin of one system with respect to the other, and a rotation matrix that indicates the orientation of one system with respect to the other. However, in the case of a geocentric to topographic transformation, VR-Link provides the function DtGeocToTopoTransform() to initialize a DtCoordTransform for you. This function, declared in topoCoord.h, does the following:

Takes the latitude and longitude of a point on the earth and computes the rotation matrix that expresses the orientation of the topographic system defined by that point.
Initializes a DtCoordTransform using this matrix along with the geocentric representation of the chosen point.
For example, to create a DtCoordTransform that can convert between geocentric coordinates and the topographic coordinate system whose origin is at 30 degrees north latitude, 100 degrees east longitude, you can do the following:

DtCoordTransform geocToTopo;
DtGeocToTopoTransform(DtDeg2Rad(30.0), DtDeg2Rad(100.0),
&geocToTopo);
Now, this transform can be used to convert from geocentric to topographic coordinates. For example, if we have a geocentric location in a DtEntityStateRepository, and we want to convert it to our topographic frame, we can use DtCoordTransform::coordTrans():

DtEntityStateRepository *esr = ...;
DtVector topoLocation;
geocToTopo.coordTrans(esr->location(), topoLocation);
If we want to do the reverse, we can initialize a second DtCoordTransform to convert from topographic to geocentric using the member function setByInverse():

DtCoordTransform topoToGeoc;
topoToGeoc.setByInverse(geocToTopo);
Now, we can use topoToGeoc() to convert to geocentric, say, for filling in a locally simulated entity's entity state repository:

DtEntityStateRepository *esr = ...;
DtVector geocLocation;
topoToGeoc.coordTrans(topoLocation, geocLocation);
esr->setLocation(geocLocation);
In addition to coordTrans(), DtCoordTransform also has vecTrans() and eulerTrans() member functions for converting vectors (such as velocity and acceleration), and orientations (expressed as Euler angles) between two different Cartesian coordinate systems.

13.3.3.2 Heading, Pitch, and Roll
Converting Euler angles from geocentric to topographic coordinates (or vice versa) is often particularly useful, because topographic-referenced Euler angles correspond to heading, pitch and roll.

Using a DtCoordTransform that can convert from geocentric to topographic coordinates, we can obtain an entity's heading, pitch, and roll as follows:

DtTaitBryan topoEuler;
geocToTopo.eulerTrans(esr->orientation, &topoEuler);
double heading = topoEuler.psi();
double pitch = topoEuler.theta();
double roll = topoEuler.phi();
13.3.4 UTM Coordinates
Locations in the world can be specified using a UTM coordinate system. UTM coordinates are mapped to a reference ellipsoid approximating the surface of the earth using a Universal Transverse Mercator projection. The coordinates consist of easting and northing from an origin or reference location, and an altitude above a reference ellipsoid, all in meters.

In a true UTM coordinate system, the origin or reference point (0,0,0) is often a point on the equator at the center of a particular UTM zone. (The world is longitudinally divided into 60 UTM zones, each centered on an odd multiple of 3 degrees.) However, VR-Link lets you define an "offset UTM" coordinate system by passing any arbitrary reference point, to the function DtUtmInit().

You must call DtUtmInit() to establish the world location of the origin of your UTM attribute system before you use any of the UTM coordinate conversion functions. Currently, VR-Link supports the use of only one UTM reference point at a time. However, you can call DtUtmInit() multiple times in your application to define the UTM origin you want to use for the next set of conversions.

13.3.4.1 Using DtUtmInit()
The first two arguments to DtUtmInit() are DtDegMinSec structures, representing the latitude and longitude of the reference point. DtDegMinSec has the following definition:

enum DtPolarDirection { DtEast, DtWest, DtNorth, DtSouth };
typedef struct 
{
   double deg, min, sec;
   DtPolarDirection direction;
} DtDegMinSec;
The following code initializes VR-Link's UTM conversion routines so that they use 35° north latitude and 122° west longitude as the reference point:

DtDegMinSec latRef = {35.0, 0.0, 0.0, DtNorth};
DtDegMinSec lonRef = {122.0, 0.0, 0.0, DtWest};
DtUtmInit(latRef, lonRef, 0);
The optional (and rarely used) third argument to DtUtmInit() indicates that a particular convention should be used, whereby 500,000 meters are added to all easting values and 10,000,000 meters are added to all north values, in order to eliminate the use of negative numbers in UTM coordinates. Applications that need to use this convention should pass a value of 1 for this argument as opposed to the more common 0.

The optional fourth argument (not shown) sets the UTM Reference zone. If you do not specify this parameter, VR-Link chooses it for you.

A UTM coordinate is represented using DtUtmCoord (defined in utmCoord.h). You can construct a DtUtmCoord by passing its three components (in meters) to the constructor:

DtUtmCoord utmLoc(50.0, 100.0, 70.0);
Assuming that DtUtmInit() was called as above, this DtUtmCoord would represent a point of altitude 70 meters, that is 50 meters east and 100 meters north of the reference point of 35 degrees north by 122 degrees west.

The class has a copy constructor and assignment operator defined, and has the following inspectors and mutators to access the various components: east, setEast, north, setNorth, up, setUp.

DtUtmCoord also has member functions that enable you to convert to and from geocentric or geodetic coordinates. DtUtmCoord::geocentric() and DtUtmCoord::geodetic() return the geodetic and geocentric equivalents of a UTM coordinate respectively. For example:

DtUtmInit(...);
...
DtUtmCoord utm(50.0, 60.0, 70.0);
DtGeodeticCoord geod = utm.geodetic();
The member functions getGeocentric() and getGeodetic() work similarly, but fill in an existing object passed by reference to the function, rather than returning the desired object.

Alternatively, the C-style functions DtGeodToUtm(), DtUtmToGeod(), DtGeocToUtm(), and DtUtmToGeoc() can also convert locations in UTM coordinates to geocentric or geodetic coordinates, and vice-versa. However their use is discouraged in favor of the member functions.

13.3.5 Differences Between UTM and Topographic Coordinates
Trouble often arises when programmers do not understand the differences between a UTM coordinate system and a topographic coordinate system that share the same origin.

Although the coordinates of a point near the origin may be similar in the two systems, they are different in several ways.

In a UTM system, Z represents altitude above the earth's surface. In the topographic frame, -Z represents height above a plane tangent to the earth's surface, which deviates from altitude above the earth's surface itself as one moves away from the origin (as illustrated below).

comparisonofutmzandtopographicz.png
Comparison of UTM Z and topographic -Z
Neglecting the small angle between northing and north, UTM coordinates X, Y, and Z correspond to east, north, and up, while the topographic X, Y, and Z correspond to north, east, and down.

topographiccomparedtoutm.png
Topographic X, Y, and Z compared to UTM
Although lines of constant easting in UTM coordinates run very close to north/south, they do not run truly north/south as lines of longitude do. This means that two points with equal easting values in their UTM coordinates, such as {100, 100, 0} and {200, 100, 0} do not lie exactly on the same line of longitude. The second point is not due north of the first. Depending on location within a UTM zone, the deviation can be plus or minus a couple of degrees. The function DtUtmCoord::gridDeclination() returns the magnitude (in radians) of the angle between northing and true north at a particular UTM location.
13.3.6 Lower Level Coordinate Conversion Functions
If you want a greater level of control over your coordinate conversions than that offered by the DtCoordTransform class described in 13.3.3.1 DtCoordTransform, there are several lower-level functions that can help.

If you have a rotation matrix that expresses a rotation between two coordinate systems, you can multiply that matrix by a vector, such as velocity, or acceleration using DtDcmVecMul() in order to convert that vector between the coordinate systems.

For geocentric/topographic conversions, the needed rotation matrix can be obtained using DtLatLon_to_GeocToTopo() or DtLatLon_to_TopoToGeoc(), declared in topoCoord.h. These functions take a latitude and longitude and return rotation matrices to convert between the geocentric frame and the topographic frame defined by that point on earth.

For example:

DtGeodeticCoord myOriginInGeod(35.0, -122.0, 0.0);
// Obtain a rotation matrix for the topo frame in question
DtDcm geoc2Topo;
DtLatLon_to_GeocToTopo(myOriginInGeod, geoc2Topo);
DtEntityStateRepository* esr = ...;
DtVector topoVel;
// Perform the vector rotation, using the matrix.
DtDcmVecMul(geoc2Topo, esr->velocity(), topoVel);
You can also use a rotation matrix to rotate a set of Euler angles from one coordinate system to another, using the function DtEulerToEuler(), declared in Euler.h, for example:

DtTaitBryan topoOrient;
DtEulerToEuler(esr->orientation(), geoc2Topo, topoOrient);
But if your goal is to obtain an entity's orientation as topographic Euler angles (heading, pitch, and roll), a more efficient way would be:

Use esr->bodyToGeoc() rather than orientation.
Multiply this returned matrix by geoc2Topo or by a geocentric to topographic rotation matrix obtained using DtLatLon_to_GeocToTopo() as described in the example above.
Convert the result to Euler angles using DtBodyToRef_to_Euler() as follows:

DtDcm bodyToTopo;
DtDcmDcmMul(geoc2Topo, esr->bodyToGeoc(), bodyToTopo);
DtTaitBryan topoEuler;
DtBodyToRef_to_Euler(bodyToTopo, topoEuler);
Coordinate locations cannot be transformed using only a rotation matrix. The translational offset between the two coordinate systems is also required. To transform from one cartesian system to another:

Subtract the origin of the second system from the point being transformed.
Perform the rotation as above.
For example, to transform a location from geocentric to a topographic coordinate:

// Find the local origin expressed in geocentric coordinates
DtVector myOriginInGeoc = myOriginInGeod.geocentric();
// Subtract the local origin from the point being transformed
DtVector tmp;
DtVecSub(esr->location(), myOriginInGeoc, tmp);
// Rotate the result
DtVector topoLoc;
DtDcmVecMul(geoc2Topo, tmp, topoLoc);

13.4 - Creating Linked Lists with DtList
Note
Use of DtList has been superceded by use of std:list<>. MAK strongly recommends that you use std::list<> in all new code. DtList will continue to be supported for backwards compatibility.
DtList (defined in vlList.h) provides a general linked-list capability in VR-Link. To enable DtList to be used to represent a list of any type of object, pointers to the objects being listed are represented by void*, and must be explicitly cast back to the data type you are listing when you want to inspect data in the list.

Within VR-Link, a DtList is used to represent the list of articulated parts that an entity possesses, the list of HLA objects in the exercise, and other such lists. For these reasons, you may need to work with DtLists even if you do not choose to use them to represent your own lists.

A DtList is constructed as follows:

DtList list;
Elements can be added to a DtList using:

addToStart()
addToEnd()
addBefore()
addAfter()
add() – which is equivalent to addToEnd().
These functions return a pointer to a DtListItem – an envelope in which your data gets wrapped before insertion into the list.

These functions also take a pointer to the element to be added. (As an exception, we sometimes store simple data types that are <=32 bits directly in the list rather than by using pointers.) These pointers must remain valid for the duration of the time they are in the list. For example, the address of automatic variables should not be put in a list if the list remains beyond the scope of the automatic variables. As a result, in general, the pointers in a list should typically be from new'ed data.

DtList's first() and last() functions return pointers to DtListItems that hold the first and last elements of the list.

You can use DtListItem::data() to get back the pointer you added to the list.

The functions first() and last() return NULL when the list is empty.

The DtListItem prev() and next() member functions facilitate iterating through a list. These functions return NULL when the beginning and end of the list have been reached, respectively. Thus, you can iterate through the elements in a list as follows:

DtList list;
   ...
for (DtListItem* item = list.first(); item; item = item->next());
The following example adds several items to a list (in this case instances of class A), and pulls them out of the list later:

// Definition of class A
class A
{
public:
   A(int num) { a = num; }
   int a;
};
// Create the list
DtList list;
// Create three instances of class A
A* a1 = new A(1);
A* a2 = new A(2);
A* a3 = new A(3);
// Add the instances to the list
list.add(a1);
list.add(a2);
list.add(a3);
// Iterate through the list, inspect the data
for (DtListItem* item = list.first(); item; item = item->next())
{
   // Use DtListItem::data to get back the pointer you added.
   // You must cast the pointer back to an A* from a void*
   A* current = (A*) item->data();   
   printf("%d\n", current->a);
}

13.5 - Diagnostic Utilities
Table of Contents
13.5.1 Using DtOutputStream for Printing
13.5.2 Printing Diagnostic Messages in Windows
You can control the amount of diagnostic information printed by VR-Link by setting the global variable DtNotifyLevel, declared in vlPrint.h.

You can set DtNotifyLevel to any of the following values:

DtNlFatal Only fatal messages are printed.
DtNlWarn Warning messages and fatal messages are printed.
DtNlInfo Some diagnostic information is printed with warnings and fatal messages.
DtNlVerbose Extra diagnostic information is printed.
DtNlDebug The maximum information is printed.
The default is DtNlInfo.

You can use the notify level to control messages generated by your own application as well, if you use VR-Link's printing functions rather than printf() or cout() directly. These printing functions are also declared in vlPrint.h, and have the same prototype as printf(). They include:

DtFatalPerror() and DtWarnPerror(), which print perror information in addition to the information you pass to the function
DtFatalError()
DtWarn()
DtInfo()
DtVerbose()
DtDebug().
The fatal functions call DtAbort() after printing their messages.

13.5.1 Using DtOutputStream for Printing
DtOutputStream lets you send debug and informational messages in VR-Link. It uses a buffer and allows you to redirect messages. It works very much like any std::ostream class.

DtInfo, DtWarn, DtVerbose, DtFatal, and DtDebug are all DtOutputStream objects. As such, you can write to them just like any standard C++ output stream, for example:

DtInfo << "something bad just happened, the error is " << error << "\n";
DtOutputStream can attach to one or more DtPrinters. A DtPrinter can print to an output device. VR-Link includes the following DtPrinter subclasses:

DtFilePrinter. Prints to the specified file.
DtStdoutPrinter. Prints to stdout
DtStderrPrinter. Prints to stderr
DtWindowsConsolePrinter. Prints to a Windows console (Windows only).
By default the DtStdoutPrinter is attached to DtInfo, DtWarn, DtDebug, DtVerbose and DtFatal. You can add any of these subclasses, or your own subclass, to all, or just one of these streams to make DtInfo print to a file, for example:

DtFilePrinter info_log("myInfo.log");
DtInfo.attachPrinter(&info_log);
To print to a console, do the following:

DtInfo.attachPrinter(&DtStandardWindowsConsole)
13.5.2 Printing Diagnostic Messages in Windows
Windows applications that are not console-based do not define STDOUT in the usual way. For example, if you try to use cout or printf to debug a MAK plug-in or to debug VR-Link in an MFC application, it will not work unless you take special care to set up a console and write to it.

To avoid this problem, call the VR-Link function setFileOutput() (defined in vlPrint.h) to enable either writing to a console window or writing to a file. Then, to ensure that diagnostic output gets printed to either the console window or to the file, use VR-Link's printing functions: DtWarn(), DtWarnPerror(), DtInfo(), DtDebug(), and DtVerbose().

13.6 - The DtException Class
DtException is the VR-Link exception class.

Member functions may throw exceptions under certain conditions, for example, if an object cannot be properly constructed or unexpected input is passed into a member function as a parameter. Any member function or constructor that throws an exception will state so in the header file and class documentation. The ostream operator, <<, is used to print exceptions, and the message() member function returns a string that describes the exception.

Example:

// DtDDMRegion may throw exception on creation
try
{
   region = new DtDDMRegion(spaceName, dimensionVector);
}
catch (const DtException& regionException)
{
   DtWarn << "Caught exception: " << regionException << std::endl;
}

13.7 - Functions for Manipulating IP Addresses
The header file vlutil.h, has a set of functions for obtaining and manipulating IP addresses.

These functions are often useful for generating addresses to use in initializing a DIS exercise connection.

VR-Link represents IP addresses with the DtInetAddr type, which is equivalent to an unsigned 32 bit integer.

DtStringToInetAddr() constructs a DtInetAddr from a string containing the common dot notation for an IP address. For example:

DtInetAddr myAddr = DtStringToInetAddr("207.86.232.1");
DtInetAddrString() goes the other way, returning a string representation of a DtInetAddr.

DtInetAddrOfDevice() returns the IP address of a particular device, specified by its device name. Device names are typically something like le0 or ec0. Similarly, DtNetMaskOfDevice() returns the netmask of a device.

DtInetBroadcastOfDevice() computes and returns the broadcast address of a device, by using those portions of the device's IP address that are covered by the netmask, and setting the lower order bits to 1's. For example, if the IP address of a device is 207.86.232.1, and the netmask is 0xffffff00 (class C network), then the broadcast address will be 207.86.232.255.

Note
On some UNIX platforms, this does not match the erroneous broadcast address reported by ifconfig.
DtFirstHostInetAddr() returns the IP address of the host's primary network device.

DtIsMulticastAddr() returns 1 if the address passed to it is a valid multicast address, that is, one between 224.0.0.0 and 239.255.255.255.

13.8 - Miscellaneous Global Functions
The following table lists additional miscellaneous global functions:

Miscellaneous Functions
Function	Description
DtSleep()	Provides a machine-independent way to halt program execution for some period of time. It's argument is the time, in seconds, for which to "sleep". The implementation of DtSleep() is machine-dependent, but it uses system calls such as UNIX's select, rather than a CPU-intensive busy loop. (For more information, please see vlProcessControl.h.)
DtSelect()	Provides a machine-independent interface to the UNIX select system call, which takes different arguments on different platforms. DtSelect()'s arguments are a number of file descriptors, three arrays of file descriptors to monitor for presence of data to read, availability for writing, and pending exceptional conditions, respectively, and a timeout in seconds. On Windows, DtSelect() interprets a file descriptor of 0 as stdin. (For more information, please see vlutil.h.)
DtAbort()	Called whenever VR-Link generates a fatal error, it makes the abort system call. If you need to modify VR-Link's abort behavior, you can write your own definition for DtAbort(). Because VR-Link's definition for DtAbort() resides in its own object file, your definition will merely supersede ours with no other effects. If your definition is linked into your application through a library that you create (rather than through an object file on your link line), make sure that your library appears before vlutil on your link line. (For more information, please see vlPrint.h.)