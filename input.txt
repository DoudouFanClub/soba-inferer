Here is a summarized version of the text data:

**Introduction**

This guide is meant for C programmers who want to learn about networking. The author has updated the guide to include information on IPv6.

**Audience and Platform**

The guide is intended for beginners in socket programming. It was compiled on a Linux PC using Gnu's gcc compiler, but should work on other platforms that use gcc. Windows users may need to make some adjustments.

**Official Homepage and Books For Sale**

The official location of the document is https://beej.us/guide/bgnet/. You can also find example code and translations in various languages there. To buy a printed copy, visit https://beej.us/guide/url/bgbuy.

**Platform-Specific Notes**

* Solaris/SunOS programmers: Add -lnsl -lsocket -lresolv to the compile command.
* Windows programmers: You can use the Windows Subsystem for Linux or Cygwin to run these programs. Alternatively, you can modify your code to work with Windows-specific system header files.

The original text has been condensed to retain its core information while reducing the word count. Here's a summarized version of the text data:

**Stream Sockets**

Stream sockets are used in applications like telnet, ssh, and web browsers. They ensure that data is transmitted in the correct order and error-free using the Transmission Control Protocol (TCP). This protocol ensures that packets arrive sequentially and intact.

**Datagram Sockets**

Datagram sockets are connectionless and unreliable. They use the User Datagram Protocol (UDP) for routing. Although UDP doesn't guarantee delivery or ordering, it's faster than TCP. Applications like multiplayer games, streaming audio, and video conferencing often use datagram sockets because a few dropped packets don't matter.

**Reliability**

Some applications that require reliable transmission, like tftp and dhcpcd, use their own protocols on top of UDP to ensure delivery. For example, the tftp protocol requires acknowledgment packets for each transmitted packet. In unreliable applications, dropped packets are ignored or cleverly compensated for.

Overall, stream sockets prioritize reliability over speed, while datagram sockets trade off reliability for speed. Here's a summarized version of the text data:

We're discussing host 12 on network 192.0.2.0, specifically IP addresses and how they work.

In the past, there were "classes" of subnets with fixed numbers of bytes for the network part (1-3) and host part (4). This led to limitations, especially with Class C networks. To overcome this, the netmask was introduced, allowing for arbitrary numbers of bits. The netmask is usually a string of 1s followed by 0s.

To make it more readable, the "slash notation" was introduced, where the IP address is followed by a slash and the number of network bits in decimal (e.g., 192.0.2.12/30).

Port numbers are also important, as they allow multiple services to share an IP address. For example, HTTP uses port 80, while telnet uses port 23. Ports under 1024 require special OS privileges.

Finally, there's the matter of byte order, which is crucial for data transfer. The text jokingly introduces "Lame" and "Magnificent" byte orders but ultimately refers to the two common byte orders: Big Endian (most significant byte first) and Little Endian (least significant byte first). Here's a summarized version of the text, retaining its original meaning while reducing the word count:

In C programming, converting IP addresses between string and binary representations is crucial. The `inet_pton()` function converts a string to a binary representation (e.g., IPv6), while `inet_ntop()` converts a binary representation back to a string.

The `inet_pton()` function returns -1 on error or 0 if the address is invalid, so it's essential to check the result before using it. On the other hand, `inet_ntop()` requires specifying the address type (IPv4 or IPv6), the address itself, and a pointer to a string to hold the result.

Private networks, also known as disconnected networks, often use Network Address Translation (NAT) to hide internal IP addresses from the outside world. This allows multiple devices on a network to share the same public IP address. The `inet_ntop()` function can handle both IPv4 and IPv6 addresses, but it won't perform DNS lookups for hostnames like "www.example.com". Here is a summarized version of the text data:

**Chapter 4: Jumping from IPv4 to IPv6**

To convert your code to IPv6:

1. Use `getaddrinfo()` instead of packing structures by hand.
2. Wrap IP version-specific code in helper functions.
3-5. Replace `AF_INET` with `AF_INET6`, `PF_INET` with `PF_INET6`, and use `in6addr_any` instead of `INADDR_ANY`.
6-8. Use `struct sockaddr_in6` instead of `struct sockaddr_in`, and `struct in6_addr` instead of `struct in_addr`.
9-10. Replace `inet_aton()`/`inet_addr()` with `inet_pton()` and `inet_ntoa()` with `inet_ntop()`.
11. Replace `gethostbyname()` with `getaddrinfo()`.
12. Use IPv6 multicast instead of `INADDR_BROADCAST`.

**Chapter 5: System Calls or Bust**

`getaddrinfo()` is a powerful function that performs DNS lookups and fills out structs for you.

Example usage:
```c
int status;
struct addrinfo hints;
struct addrinfo *servinfo;

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // don't care about IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE; // fill in my IP for me

if ((status = getaddrinfo(NULL, "3490", &hints, &servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1);
}

// servinfo now points to a linked list of struct addrinfos
freeaddrinfo(servinfo); // free the linked list
``` Here's a summarized version of the text while retaining its original meaning:

To make a socket, use `socket(res->ai_family, res->ai_socktype, res->ai_protocol)` and bind it to a port using `bind(sockfd, res->ai_addr, res->ai_addrlen)`. The AI_PASSIVE flag binds the socket to the host's IP address. You can also manually pack the struct sockaddr_in for IPv4-specific code.

When calling `bind()`, be aware that ports below 1024 are reserved and may require superuser privileges. If you encounter "Address already in use" errors, add code to reuse the port or wait for the existing socket to clear.

`connect()` is used to connect to a remote host. You can call it with the results of `getaddrinfo()`, which returns the destination port and IP address. For example: `connect(sockfd, serv_addr, addrlen)` where `sockfd` is the socket file descriptor, `serv_addr` is the struct sockaddr containing the destination port and IP address, and `addrlen` is the length in bytes of the server address structure.

Note that you may not always need to call `bind()` if you're only connecting to a remote machine and don't care about your local port. Here's a summarized version of the text, retaining its original meaning while reducing the word count:

When working with datagram sockets, we need to consider the destination address. We use `sendto()` instead of `send()`, providing the destination IP address and port as parameters.

`recvfrom()` is similar to `recv()`, but it also returns the originator's IP address and port in a struct sockaddr_storage.

We use `struct sockaddr_storage` as the socket type because it's big enough for both IPv4 and IPv6 addresses, allowing us to avoid tying ourselves down to a specific protocol.

If we connect a datagram socket, we can use `send()` and `recv()` without worrying about destination addresses. The socket interface will automatically add the necessary information.

To close a connection on a socket descriptor, we can use the `close()` function or the more flexible `shutdown()` function. `shutdown()` allows us to control which direction of communication is blocked (receive-only, send-only, or both).

Finally, `getpeername()` is used to retrieve the peer's address and port from a connected socket.

The text has been condensed while maintaining its original meaning and structure. Here is a summarized version of the text, retaining its original meaning while reducing the word count:

Chapter 6: Client-Server Background

In today's network world, everything revolves around client-server interactions. Telnet and FTP are examples of this concept. A client sends a request to a server, which responds accordingly.

The diagram in Figure 6.1 illustrates the exchange between a client and a server. They can communicate using various protocols like SOCK_STREAM or SOCK_DGRAM as long as they agree on one.

A simple stream server is demonstrated in Section 6.1. It sends "Hello, world!" over a stream connection. To test this server, run it in one window and use telnet to connect to it from another window.

The server code is provided below:

[Code snippet removed for brevity]

This server waits for connections, accepts them, and forks child processes to handle each request. The client can be found in Section 6.2.

Note: I did not remove any essential information or add any additional words that are not related to the original text data. Here is a summarized version of the text data that retains its original meaning while reducing the word count:

**Client-Server Background**

The code for a datagram socket client-server demo is provided. The server, listener.c, listens on port 4950 and waits for incoming packets from the client, talker.c.

The client sends a packet to the server using IPv6. If the connection is refused, the client will not retry.

**listener.c**

* Creates a datagram socket
* Binds it to port 4950
* Waits for an incoming packet and prints its contents

**talker.c**

* Sends a packet to the server using IPv6
* Takes two command-line arguments: hostname and message
* Sends the message to the server at the specified hostname on port 4950

Note that both client and server use getaddrinfo() with SOCK_DGRAM to create a datagram socket, and there is no need for listen() or accept(). Here is a summarized version of the text data while retaining its original meaning and reducing the word count:

The code demonstrates using the `poll` function to monitor file descriptors (e.g., standard input, sockets) for events. The `struct pollfd` array stores the file descriptors and event types to watch.

In this example, we create a simple chat server that listens on port 9034. When a connection is established, it adds the socket to the `poll` set. When a connection closes or becomes ready-to-read, the server detects the event and handles it accordingly.

To add new file descriptors, allocate more space in the array or use `realloc`. To remove items from the set, copy the last element over the one being deleted or set the `fd` field to a negative number. Here's a summarized version of the text, retaining its original meaning while reducing the word count:

Synchronous I/O Multiplexing with `select()`

When handling multiple connections, you may need to listen for incoming connections and read from existing ones simultaneously. However, blocking on an accept call makes it difficult to recv data at the same time. `select()` allows you to monitor multiple sockets at once, detecting which are ready for reading, writing, or have exceptions.

Use `select()` with caution, as it's slow with a large number of connections. For better performance, consider using event libraries like libevent.

The `select()` function takes five parameters: `numfds`, `readfds`, `writefds`, `exceptfds`, and `timeout`. It monitors sets of file descriptors and returns modified `readfds` indicating which are ready for reading.

To manipulate these sets, use the following macros: `FD_SET`, `FD_CLR`, `FD_ISSET`, and `FD_ZERO`.

The `struct timeval` allows you to specify a timeout period. Set `tv_sec` to seconds and `tv_usec` to microseconds. If the time is exceeded and no file descriptors are ready, `select()` returns.

Additional notes:

* Setting `timeout` to 0 makes `select()` poll all file descriptors immediately.
* Setting `timeout` to NULL makes it wait indefinitely for a file descriptor to become ready.
* You can set specific sets to NULL if you don't care about waiting for them.

Here's an example code snippet that waits 2.5 seconds for something to appear on standard input:
```c
#include <stdio.h>

int main() {
    struct timeval tv;
    tv.tv_sec = 2; // 2 seconds
    tv.tv_usec = 500000; // 500 milliseconds

    select(0, NULL, NULL, NULL, &tv);
    return 0;
}
```
This code snippet demonstrates the basic usage of `select()` with a timeout. Here is a summarized version of the text data while retaining its original meaning and reducing the word count:

The code uses two file descriptor sets: `master` and `read_fds`. `master` holds all connected socket descriptors, including the listener. The reason for using `master` is to store the set of sockets that are ready to read after calling `select()`. When a new connection is established, it's added to `master`, and when a connection closes, it's removed.

The code checks if the listener socket is ready to read, which indicates a new connection. It accepts the connection and adds it to `master`. When a client connection is ready to read, it receives data using `recv()`. If `recv()` returns 0, it means the client has closed the connection, so it's removed from `master`.

If `recv()` returns non-zero, some data was received, so it's sent to all connected clients. The `select()` function is used to determine which sockets are ready to read.

Additionally, there's a note about Linux's `select()` function sometimes returning "ready-to-read" but not actually being ready, and a workaround solution using the `O_NONBLOCK` flag. Finally, an alternative function called `poll()` is mentioned, which behaves similarly to `select()`. Here is a summarized version of the text data, retaining its original meaning while reducing the word count:

**pack754 and unpack754 Functions**

These functions implement the IEEE 754 floating-point packing and unpacking algorithms.

**Pack Function (pack754)**

* Takes three arguments: `long double` value, number of bits (`bits`), and exponent bits (`expbits`)
* Returns a `uint64_t` packed representation
* Normalizes the input value by shifting it to have 1.0 <= |x| < 2.0
* Calculates the biased exponent and significand (mantissa) values
* Returns the packed result as a `uint64_t`

**Unpack Function (unpack754)**

* Takes three arguments: `uint64_t` packed value, number of bits (`bits`), and exponent bits (`expbits`)
* Returns a `long double` unpacked representation
* Extracts the significand and biased exponent values from the packed input
* Calculates the normalized floating-point value by adjusting the significand and exponent
* Applies the sign bit to the result

**Sample Usage**

The provided code demonstrates how to use the `pack754` and `unpack754` functions to pack and unpack 32-bit and 64-bit floating-point values. Here is the summarized text data:

**Slightly Advanced Techniques**

`packi64()` stores a 64-bit int into a char buffer.

`unpacki16()`, `unpacku16()`, `unpacki32()`, and `unpacku32()` unpack 16-bit, 32-bit signed/unsigned integers from a char buffer.

`unpacki64()` and `unpacku64()` unpack 64-bit signed/unsigned integers from a char buffer.

`pack()` stores data dictated by the format string in the buffer. It supports various types: 8-bit signed/unsigned (`c`, `C`), 16-bit signed/unsigned (`h`, `H`), 32-bit signed/unsigned (`l`, `L`), 64-bit signed/unsigned (`q`, `Q`), float (`f`), and string (`s`). Strings are prepended with a 16-bit unsigned length.

Let me know if you'd like me to summarize anything further! Here is a summarized version of the text, retaining its original meaning while reducing the word count:

The code snippet provided demonstrates data packing and unpacking using the `unpack` function. This technique is useful for keeping bugs in check when working with binary data.

RFC 4506 defines standard binary formats for various types, including floating point numbers, integers, arrays, and raw data. While conforming to this standard is recommended, it's not required. The important thing is to encode the data before sending it.

Data encapsulation involves adding a header to the data with identifying information or packet length. A simple example of encapsulation is a multi-user chat program that sends user messages to the server. To handle varying message lengths, a header and packet structure can be used, which includes the user name (fixed length) and chat data (variable length).

Here's an example packet structure:

1. len (1 byte): total packet length
2. name (8 bytes): user name, padded with '\0'
3. chatdata (n-bytes): variable-length chat data

The code snippet provided shows how to pack and unpack this data using the `unpack` function.

Note that I removed unnecessary details and simplified some of the language while still maintaining the original meaning. Here is a summarized version of the text data:

**UDP Broadcast**

* Run `broadcaster` on one machine and `listener` on another to send broadcast packets.
* `broadcaster` sends packets to a specified IP address, and `listener` receives them.
* If `listener` doesn't respond, check if it's bound to an IPv6 address; try changing to AF_INET for IPv4.

**Firewall Blocking**

* If `listener` receives data sent directly but not broadcast packets, check if your local machine has a firewall blocking the packets.

**Broadcast Considerations**

* Broadcast packets can present a load on the entire computing network and should be used sparingly.
* Be careful when using broadcast packets.

**Common Questions**

* Where to find header files: Check manual for your platform or #include <winsock.h> for Windows.
* What to do when `bind()` reports "Address already in use": Use `setsockopt()` with SO_REUSEADDR option on the listening socket.
* How to get a list of open sockets: Use `netstat`.
* How to view routing table: Run `route` or `netstat -r` or `ip route`.
* Running client and server programs on one machine: Use loopback network device; run client in one window and server in another.

**Miscellaneous**

* Check if remote side has closed connection by checking if `recv()` returns 0.
* Implementing a "ping" utility: Use ICMP. For more information, see raw sockets and SOCK_RAW. Here's a summarized version of the text data, retaining its original meaning while reducing the word count:

**Windows-specific questions**

* How to use multiple calls to `recv()` to receive complete packets of data? Look for POSIX libraries shipped with your compiler or search the help that came with VC++ for "fork" or "POSIX".
* Alternative: Use CreateProcess() instead of fork().

**Firewall and IP address issues**

* How to allow external connections through a firewall? Design programs to initiate connections, use NAT or proxy forwarding, or ask sysadmins to create a hole in the firewall.
* Be cautious when creating holes in firewalls to prevent security breaches.

**Packet sniffer and promiscuous mode**

* How to write a packet sniffer and put an Ethernet interface into promiscuous mode? Search for "windows promiscuous ioctl" or use Linux-specific solutions like Stack Overflow threads.

**Socket timeouts and available ports**

* How to set custom timeout values for TCP/UDP sockets? Check if your system supports SO_RCVTIMEO and SO_SNDTIMEO, or use alarm() or setitimer() as alternatives.
* How to tell which ports are available to use? Choose a random port above 1023, check for availability, and allow users to specify alternate ports. Use IANA's list of official port numbers if needed.

Let me know if you'd like me to further condense the summary! Here is a summarized version of the text data:

**Chapter 9: Man Pages**

**Accept()**
Accept an incoming connection and get a new socket descriptor.

* Parameters: `s` (listen socket), `serv_addr` (server address), `addrlen` (address length)
* Return value: 0 on success, -1 on error
* Example: Use `getaddrinfo()` to resolve the server's address, then call `accept()` with the listen socket and the resolved address.

**Bind()**
Bind a socket to an address and port.

* Parameters: `s` (socket), `serv_addr` (server address), `addrlen` (address length)
* Return value: 0 on success, -1 on error
* Example: Use `getaddrinfo()` to resolve the server's address, then call `bind()` with the socket and the resolved address.

**Connect()**
Connect a socket to a remote server.

* Parameters: `s` (socket), `serv_addr` (server address), `addrlen` (address length)
* Return value: 0 on success, -1 on error
* Example: Use `getaddrinfo()` to resolve the server's address, then call `connect()` with the socket and the resolved address.

Note that I removed some of the explanatory text and focused on the key points about each function. Let me know if you'd like me to add anything back in! Here is a summarized version of the text data with reduced word count:

**Client Code**

Connect to www.example.com on port 80 using stream socket.

```c
int sockfd;
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM;

if ((rv = getaddrinfo("www.example.com", "http", &hints, &servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    exit(1);
}

for (p = servinfo; p != NULL; p = p->ai_next) {
    sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if (sockfd == -1) {
        perror("socket");
        continue;
    }
    if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
        perror("connect");
        close(sockfd);
        continue;
    }
    break;
}

if (p == NULL) {
    fprintf(stderr, "failed to connect\n");
    exit(2);
}
freeaddrinfo(servinfo);
```

**Server Code**

Listen for connections on port 3490 using stream socket.

```c
int sockfd;
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE; // use my IP address

if ((rv = getaddrinfo(NULL, "3490", &hints, &servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    exit(1);
}

for (p = servinfo; p != NULL; p = p->ai_next) {
    sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if (sockfd == -1) {
        perror("socket");
        continue;
    }
    if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
        close(sockfd);
        perror("bind");
        continue;
    }
    break;
}

if (p == NULL) {
    fprintf(stderr, "failed to bind socket\n");
    exit(2);
}
freeaddrinfo(servinfo);
```

**gethostname()**

Returns the system's hostname.

```c
#include <sys/unistd.h>
int gethostname(char *name, size_t len);

Returns zero on success or -1 on error (errno is set accordingly).
```

Note that I removed some redundant comments and code blocks to reduce the word count while still retaining the original meaning. Here is a summarized version of the text data, reducing the word count while retaining its original meaning:

**Chapter 9: Man Pages**

**1. gethostbyname()**

* Returns a struct hostent with host information and IP addresses.
* Error reporting uses h_errno instead of perror().

**Example**
```c
#include <stdio.h>
#include <netdb.h>

int main() {
    struct hostent *he;
    char **addr_list;

    if ((he = gethostbyname(argv[1])) == NULL) {
        herror("gethostbyname");
        return 2;
    }

    printf("Official name: %s\n", he->h_name);
    printf("IP addresses: ");
    for (int i = 0; addr_list[i] != NULL; i++) {
        printf("%s ", inet_ntoa(*addr_list[i]));
    }
    printf("\n");
    return 0;
}
```

**2. getnameinfo()**

* Returns host and service names from a struct sockaddr.
* Flags: NI_NOFQDN (only host name), NI_NAMEREQD (fail if DNS lookup fails).

**Example**
```c
struct sockaddr_in6 sa;
char host[1024];
char service[20];

getnameinfo(&sa, sizeof sa, host, sizeof host, service, sizeof service, 0);
printf("host: %s\n", host);
printf("service: %s\n", service);
```

**3. getpeername()**

* Returns address information about the remote side of a connection.
* Preload len with the size of addr.

**Example**
```c
socklen_t len;
struct sockaddr_storage addr;

len = sizeof addr;
getpeername(s, (struct sockaddr*)&addr, &len);

// deal with IPv4 and IPv6
if (addr.ss_family == AF_INET) {
    // ...
} else { // AF_INET6
    // ...
}
printf("Peer IP address: %s\n", ipstr);
printf("Peer port: %d\n", port);
```

**errno**

* Holds the error code for the last system call. Here is a summarized version of the text, retaining its original meaning while reducing the word count:

**Deprecated Functions**

`inet_ntoa()`, `inet_aton()`, and `inet_addr()` convert IP addresses between strings (e.g. "192.168.5.10") and struct in_addr format.

**Synopsis**

These functions are deprecated due to lack of IPv6 support. Use `inet_ntop()` or `inet_pton()` instead.

**Description**

`inet_ntoa()` converts a struct in_addr to a string, while `inet_aton()` does the reverse. `inet_addr()` is an older function that does the same as `inet_aton()`, but is theoretically deprecated.

**Return Value**

`inet_aton()` returns 1 for valid addresses and 0 for invalid ones. `inet_ntoa()` overwrites a static buffer with each call. `inet_addr()` returns the address as in_addr_t or -1 if there's an error.

**Example**

Convert an IP address from string to struct in_addr and back:
```c
struct sockaddr_in antelope;
char *some_addr;

inet_aton("10.0.0.1", &antelope.sin_addr);
some_addr = inet_ntoa(antelope.sin_addr);
printf("%s\n", some_addr); // prints "10.0.0.1"
```
**See Also**

`inet_ntop()`, `inet_pton()`, `gethostbyname()`, and `gethostbyaddr()` Here is a summarized version of the text data:

**get_ip_str**

* Converts an IP address from a struct sockaddr to a string
* Returns the string or NULL on error
* See Also: getaddrinfo()

**listen**

* Tells a socket to listen for incoming connections
* Parameters: socket descriptor, backlog (number of pending connections)
* Return Value: 0 on success, -1 on error
* Example: Create a server that listens for incoming connections

**perror**, **strerror**

* Print an error message as a human-readable string
* perror() prints the error message with additional text if specified
* strerror() returns a pointer to the error message string
* Return Value: string or NULL on error
* Example: Use perror() and strerror() to print error messages

**poll**

* Tests for events on multiple sockets simultaneously
* Parameters: array of struct pollfds, number of file descriptors, timeout
* Return Value: number of elements with event occur on them, -1 on error
* Example: Monitor multiple socket connections for incoming data Here is a summarized version of the text while retaining its original meaning and reducing the word count:

The `select()` function allows you to check multiple sockets simultaneously for readiness to receive data, send data, or detect exceptions. You create sets using macros like `FD_SET()`, `FD_CLR()`, and `FD_ISSET()`. Pass these sets as parameters to `select()`, along with a timeout value in the `struct timeval` format.

The function returns the number of descriptors ready for action, 0 if the timeout is reached, or -1 on error. The sets are modified to show which sockets are ready.

Example:
```
fd_set readfds;
char buf1[256], buf2[256];

FD_ZERO(&readfds);
FD_SET(s1, &readfds);
FD_SET(s2, &readfds);

n = s2 + 1; // n is the highest-numbered socket descriptor plus one
tv.tv_sec = 10; tv.tv_usec = 500000;

rv = select(n, &readfds, NULL, NULL, &tv);

if (rv == -1) {
    perror("select");
} else if (rv == 0) {
    printf("Timeout occurred! No data after 10.5 seconds.\n");
} else {
    // one or both of the descriptors have data
    if (FD_ISSET(s1, &readfds)) {
        recv(s1, buf1, sizeof buf1, 0);
    }
    if (FD_ISSET(s2, &readfds)) {
        recv(s2, buf2, sizeof buf2, 0);
    }
}
```
The `select()` function is useful for managing multiple socket connections simultaneously. Here is a summarized version of the text data:

**Man Pages**

* `setsockopt()`: sets options on a socket
	+ Example: set SO_REUSEADDR to true (1) and bind a socket to a device name ("eth1")
	+ See Also: `fcntl()`, `send()`, `sendto()`
* `send()` and `sendto()`: send data over a socket
	+ Parameters: socket, buffer, length, flags
	+ Flags: MSG_OOB (out-of-band), MSG_DONTROUTE (local routing), MSG_DONTWAIT (non-blocking), MSG_NOSIGNAL (no signal on pipe error)
	+ Return Value: number of bytes sent or -1 on error
* `shutdown()`: stops further sends and receives on a socket
	+ Parameters: socket, how (SHUT_RD, SHUT_WR, SHUT_RDWR)
	+ Return Value: 0 on success or -1 on error
* `socket()`: allocates a new socket descriptor
	+ Parameters: domain, type, protocol
	+ Example: creates a new IPv4 TCP socket (`PF_INET`, `SOCK_STREAM`, 0)

**Summary**

The man pages document various system calls related to sockets:

* `setsockopt()` sets options on a socket, such as reusing an address or binding to a device name.
* `send()` and `sendto()` send data over a socket, with optional flags for out-of-band transmission, local routing, non-blocking, and no signal on pipe error.
* `shutdown()` stops further sends and receives on a socket, allowing control over which side of the connection is closed.
* `socket()` allocates a new socket descriptor, specifying the domain (IPv4 or IPv6), type (TCP or UDP), and protocol.

Note: I removed some details and examples to condense the text while retaining its original meaning. Here is a summarized version of the text data, retaining its original meaning while reducing the word count:

**Man Pages**

The `struct sockaddr_in` and `struct sockaddr_in6` structures are used to represent IPv4 and IPv6 addresses, respectively. They share the same beginning structure as `struct sockaddr`. The `struct sockaddr_storage` structure is a general-purpose socket address holder that can hold either an IPv4 or IPv6 address.

**Description**

These structures are used in system calls and functions that deal with internet addresses. You often use `getaddrinfo()` to fill these structures out, and then read them when needed.

**Example**

Here's how to create an IPv4 and IPv6 socket address:

```c
// IPv4:
struct sockaddr_in ip4addr;
ip4addr.sin_family = AF_INET;
ip4addr.sin_port = htons(12345);
inet_pton(AF_INET, "192.168.1.100", &ip4addr.sin_addr);

// IPv6:
struct sockaddr_in6 ip6addr;
ip6addr.sin6_family = AF_INET6;
ip6addr.sin6_port = htons(12345);
inet_pton(AF_INET6, "2001:0db8:85a3:0000:0000:8a2e:0370:7334", &ip6addr.sin6_addr);
```

**References**

For further reading and learning:

* Web references:
	+ BSD Sockets: A Quick And Dirty Primer
	+ The Unix Socket FAQ
	+ TCP/IP FAQ
	+ Winsock FAQ
* Wikipedia pages:
	+ Berkeley Sockets
	+ Internet Protocol (IP)
	+ Transmission Control Protocol (TCP)
	+ User Datagram Protocol (UDP)
	+ Client-Server
	+ Serialization
* RFCs:
	+ RFC 121: The First RFC
	+ RFC 768: The User Datagram Protocol (UDP)
	+ RFC 791: The Internet Protocol (IP)
	+ RFC 793: The Transmission Control Protocol (TCP)
	+ RFC 854: The Telnet Protocol
	+ RFC 959: File Transfer Protocol (FTP)

Note that the original text had many links and references, but I have removed them for brevity. 