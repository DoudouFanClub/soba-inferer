# RyRy Lang
RyRy Lang is a high level programming language with syntax inspired by Python, Go and C

## Types
RyRy Lang has the standard primitives available in most languages.

int (32bit signed integer)

char (8bit unsigned integer)

long (64 bit signed integer)

uint (32 bit unsigned integer)

float (32 bit floating point number)

double (64 bit floating point number)

boolean (8 bit true or false)

## Syntax
Variables are declared like this
```
int x;
char y;
// you assign values like this
x = 0;
// or pass it in during declaration
int z = 0;
// the type can also be deduced
auto t = 0; // t is an int
```

Functions are defined as follows
```
fn functionName(arg : argtype) : returntype {
    // function body
}
```
So a simple addition function would look like this
```
fn add(x : int, y : int) : int {
    return x + y;
}
```

Structs are defined as such
```
MyStruct struct {
    int memberInt;
    char memberChar;
}
```
The default access qualifier is public in RyRy Lang, if you wish to hide member variables use the `[private]` annotation
```
PrivateStruct struct {
    [private] int memberInt;
    // or to declare multiple private members
    [private] (
        char priv1;
        char priv2;
    );
}
```
If you wish to structure your code in an object oriented fashion, RyRy Lang provides the following syntax
```
MyStruct struct {
    int x;
}

// this explicitly passes in a pointer like setZero(MyStruct* anyName)
fn MyStruct anyName | setZero() : void {
    // this way you can use it like member functions in traditional OO languages
    anyName.x = 0;
}

fn otherFunction() : MyStruct {
    MyStruct myStruct;
    // this way you can invoke the function with the object
    myStruct.setZero();
    // prints 0
    print(myStruct.x);
}
```
If and Else statements are similar to other languages
```
if x == 0 {
    return true;
}
else if x == 1 {
    return false;
}
else {
    print("noob");
}
```
For loops can be written in the following ways
```
for int i = (0, 10) {
    // 10 is non inclusive
    print(i);
}

// we have variable sized lists too
list<int> myList = {0, 1, 2};
myList.append(3);
for auto element in myList {
    // prints 1 to 3
    print(element);
}
```
## Finer details
By default in RyRy Lang, everything is allocated into the stack unless explicitly defined otherwise with the `new` operator
```
MyStruct x; // lives for the scope which its defined in
MyStruct* y = new MyStruct; // lives arbitrarily
```
All pointers initialized with the `new` keyword are reference counted pointers by default, this means after the ownership of the object reaches 0 the object will be cleaned up. If you wish to have more explicit control over the lifetime of your objects in memeory, raw pointers can be initialized with the `raw` keyword are traditional C style raw pointers
```
MyStruct* y = raw MyStruct;
```