1 - Introduction
The VR-Link toolkit is an object-oriented library of C++ classes, functions, and definitions that minimize the effort required to create networked simulators and virtual reality applications.

VR-Link's powerful, easy-to-use programmer's interface greatly reduces development cost, time, and risk.

1.1 - The Protocol-Independent API
With VR-Link's protocol-independent API, you can simulate local entities, set their state, and automatically send entity information to other applications over a network using Distributed Interactive Simulation (DIS) or the High-Level Architecture (HLA) Run-Time Infrastructure (RTI).

VR-Link also simplifies receiving and processing information from other applications, providing easy access to the state of remote entities. VR-Link handles dead reckoning, thresholding, responding to attribute requests, filtering, and many other tasks.

Because VR-Link supports both DIS and HLA through very similar APIs, you can often switch your applications between the two by changing just a few lines of initialization code, and recompiling. This means that your VR-Link-based applications can maintain the DIS compliance vital to ongoing projects, while migrating to HLA.

VR-Link implements all DIS PDUs and you can add support for user-defined PDUs.

1.2 - VR-Link Features
Table of Contents
1.2.1 Files and Executables in VR-Link
VR-Link provides a range of features to help you create and maintain HLA and DIS applications:

Exercise Connection: An exercise connection is a VR-Link application's interface to an HLA or DIS exercise. It provides a protocol-independent interface through which to exchange simulation information with other applications, either through the DIS network, or the HLA RTI.
Object tracking: A VR-Link application uses a reflected entity list to keep track of remote participants in your virtual world by processing incoming attribute updates (through either DIS or HLA), and provides a protocol-independent1 interface to their state. It submits update requests as needed, provides notice when an entity enters or leaves an exercise, and performs dead-reckoning, trajectory smoothing, and filtering, as desired. Reflected object lists are available for other types of objects, such as emitters, transmitters, and so on.
Object publishing: A VR-Link application uses an Entity Publisher to keep remote applications informed about the state of entities that you simulate locally. You periodically set the current state of your objects through its protocol-independent interface, and the Entity Publisher automatically sends state updates when data changes or exceeds configurable thresholds. Object publishers are available for other types of objects, such as emitters, transmitters, and so on.
Interaction classes: VR-Link provides a protocol-independent1 interface to the sending and receiving of interaction messages that describe simulation events such as weapon fires, detonations, and radio signal transmissions. C++ classes representing DIS PDUs and HLA interactions usually provide mutator and inspector functions to access each field. Variable length PDUs and parameters are resized transparently. Functions are provided to print human-readable representations of interaction data.
FOM-Agility: While VR-Link comes with built-in support for the RPR FOM, the FOM Mapper class lets you map VR-Link's existing protocol-independent API to another FOM's parameters, attributes, and object or interaction classes. In this way, code that uses the API does not need to change when the FOM changes.
User extensibility: VR-Link's C++ API and implementation allow you to override most of its default functionality through subclassing. You can extend the toolkit to work with new types of HLA object or interaction classes and with new user-defined DIS PDUs. The VR-Link Code Generator can automatically generate the files needed to create new objects and interactions for HLA based on an XML or OMT data definition file.
Access to low-level details: For developers who want to work below the level of abstraction provided by our top-level API, VR-Link provides protocol-specific classes and functions. Low-level access includes direct access to the HLA RTI and to the details of network configuration in DIS.
Utility functions: VR-Link includes a rich set of utility functions, including vector and matrix manipulation functions, a platform-independent interface to the system clock, and support for discreet simulation time. Coordinate conversion utilities for geocentric coordinates, geodetic coordinates, topographic coordinates, and UTM coordinates are included as well.
Example applications: VR-Link comes with a set of HLA and DIS utility programs. For example, the netdump utility prints data received from remote simulations in an easy-to-read format. The f18 utility is a simple networked simulator that serves as a flexible debugging tool. Source code for the examples is provided to demonstrate the use of much of VR-Link's functionality.
You can use VR-Link's C++ interface from C applications.
1.2.1 Files and Executables in VR-Link
VR-Link includes the header files and libraries necessary to build applications based on VR-Link, plus executables and source code for the following utility applications:

F18
DIS Netdump
Talk
Listen.
VR-Link includes source code and executables for the sample applications. The "test" applications show how to extend the features of VR-Link by creating your own PDUs, interactions, encoders, and decoders.

1.3 - Simulation Standards Supported
Table of Contents
1.3.1 Support for the HLA RTI 1.3 and RTI 1516 Specifications
1.3.1.1 Compatibility of RTI 1.3 and RTI 1516 Applications
1.3.1.2 Support for FED and FDD (XML) Files
1.3.2 HLA FOM Support
1.3.2.1 RPR FOM Versions Supported
1.3.2.2 Support for FOM Agility
VR-Link supports HLA and DIS.

For a list of the versions of the simulation standards supported by your release of VR-Link, please refer to your release documentation. You can also check the MAK web site for platform support updates at: http://www.mak.com/support/product-versions.html.

For a brief discussion of DIS and HLA, please see 2.2 - HLA, DIS, and Protocol Independence.

1.3.1 Support for the HLA RTI 1.3 and RTI 1516 Specifications
VR-Link supports the HLA 1.3 specification, the HLA 1516 specification (SISO DLC HLA API), and the HLA Evolved (IEEE 1516-2010) specification. VR-Link's protocol independent interface lets you create applications for use with any version of the HLA largely without regard to the details of the RTI. Any code that you have written for use with the RTI 1.3 specification should be usable with RTI 1516 or HLA Evolved with very few, if any, changes.

VR-Link supports the SISO DLC HLA API 1516 (SISO-STD-004.1-2004). This API supports dynamic link compatibility, which was problematic with the original IEEE 1516 API. The IEEE 1516 API only supports compile time compatibility (uses C++ templates and implementation-specific header files). VR-Link is compatible with any RTI written to the SISO DLC HLA API 1516.

HLA Evolved is the latest version of HLA. It builds on the work done by the SISO DLC HLA API group to provide a dynamic link compatible API. It includes additional features such as FOM modules and update rate reduction.

Note
In most cases, VR-Link's implementation of HLA Evolved is identical to HLA 1516. Therefore, any references to HLA 1516 in this manual should be considered to apply to HLA Evolved as well, unless noted otherwise.
1.3.1.1 Compatibility of RTI 1.3 and RTI 1516 Applications
If you use the MAK RTI, applications built using the VR-Link 1516 APIs can interoperate with applications built with the VR-Link 1.3 API. For example, if you build the listen example with the 1516 API and the talk example with the 1.3 API, they can interoperate. For more information, please see 5.11 - Interoperability Between HLA 1.3 and IEEE 1516 Federates.

1.3.1.2 Support for FED and FDD (XML) Files
VR-Link supports HLA configuration files in both the FED and FDD (XML) formats. When you create an exercise connection, you can specify a .fed file, .fdd file, or .xml file. You can use any of these formats with RTI 1516, HLA Evolved, and RTI 1.3.

If you do not pass a filename to the exercise connection, VR-Link uses the federation execution name as the filename. If you are building for RTI 1516, VR-Link looks for a file name federation_execution.xml. If it cannot find a file with this name, it looks for a file named federation_execution.fdd, then for federation_execution.fed. If you are building for RTI 1.3, VR-Link looks for a .fed file first, then an .xml or .fdd file.

1.3.2 HLA FOM Support
VR-Link provides extensive built-in support for the Real- Time Platform Reference FOM (RPR FOM). (For version information, please see release documentation.) The RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group, which consists of representatives from many companies that used the DIS protocol in the pre-HLA era.

The goal of the RPR FOM is to facilitate a priori interoperability (to about the extent we had in DIS) among HLA simulations that choose to use it. In other words, if you use the RPR FOM (either as is, or with your own extensions), then you know that you will be able to interoperate with anyone else who chooses to use this FOM. Another advantage of using the RPR FOM is that many simulation tools, including those offered by VT MAK, support this FOM.

1.3.2.1 RPR FOM Versions Supported
VR-Link 5.4.1 has built-in support for:

RPR FOM 0.5, 0.7, 0.8, 1.0
RPR FOM 2.0, drafts 6, 14, 17, and 20
RPR FOM 2.
By default, all VR-Link examples use RPR FOM 2.0. The DtVrlApplicationInitializer class, however, still defaults to using RPR FOM 1.0.

VR-Link does not officially support RPR FOM 2 Draft 18. However, the draft appears to be similar enough to RPR FOM 2 Draft 17 that the 2.0017 FOM Mapper may be used for federates wishing to interoperate with RPR FOM 2 Draft 18.

If you want to use a version of the RPR FOM other than 1.0, pass the version number (0.5, 0.7, 0.8, 2.0006, 2.0014, 2.0017, 2.0020, 2.0) to the DtRprFomMapper constructor and pass the resulting object to the DtExerciseConn constructor. Also, make sure you are using a federation execution name that corresponds to the right FED file. For example:

DtExerciseConn conn("MAK-RPR20017-1-1.fed", "MyApp", new DtRprFomMapper(2.0017-1));
VR-Link examples like f18 and hlaNetdump have a command line option, –rprFomVersion, that you can use to choose a RPR FOM version, using one of the version numbers listed in the previous paragraph.

1.3.2.2 Support for FOM Agility
In addition to its built-in support for the RPR FOM, VR-Link can be configured to work with other FOMs, by using its FOM Mapper to define mappings between VR-Link's protocol-independent interface and the objects, interactions, parameters, and attributes defined in your FOM. For more information about VR-Link's FOM Agility, please see 6 - FOM Agility.

VR-Link has a FOM Mapper for the MATREX FOM. For details, please contact your MAK salesperson.

2 - VR-Link Concepts
These pages provide a general explanation of how VR-Link works.

2.1 - VR-Link is a Multi-Layered Toolkit
2.2 - HLA, DIS, and Protocol Independence
2.3 - A Conceptual Overview of VR-Link
2.4 - Connecting to an Exercise
2.5 - Managing State Information
2.6 - Managing Information about Events
2.7 - Other Simulation Concepts
2.8 - Big and Little Endian Wire Formats
2.9 - Basic VR-Link Examples

2.1 - VR-Link is a Multi-Layered Toolkit
Table of Contents
2.1.1 Multiple Layers of Access
VR-Link is a toolkit.

It supplies you with the classes, functions, and utilities you need to write a simulation application, but unlike a framework, it does not provide a structure that you are required to use. For example, you will probably want to check the state of a locally-simulated entity at periodic intervals, but VR-Link does not care whether you do that using a loop (as the Listen example does (Basic VR-Link Examples)), or by using a timer or some other mechanism.

2.1.1 Multiple Layers of Access
As a VR-Link developer, you have several options for approaching application development:

Work through the protocol-independent interface, which with minimal modifications, lets you create applications that work with both HLA and DIS and shields you from many of the intricacies of the underlying protocol-specific classes and functions. Most VR-Link users take this approach.
Go below the protocol-independent interface and take advantage of the protocol-specific classes. Do this if you want to tailor your application to HLA or DIS.
Fully realize the potential of VR-Link and meet your most demanding simulation needs:
Extend VR-Link by creating new classes for HLA objects and interactions or DIS PDUs.
Use the FOM Mapper to support additional FOMs.
Regardless of how you use VR-Link, read VR-Link Concepts, The Protocol Independent Interface, and study the VR-Link Examples. If you focus on a specific simulation standard, read the protocol-specific chapters for that standard. If you want to extend VR-Link, read chapters that describe how to subclass and create your own objects and interactions.

2.2 - HLA, DIS, and Protocol Independence
Table of Contents
2.2.1 The High Level Architecture (HLA)
2.2.1.1 The Federation Object Model (FOM)
2.2.1.2 The Run-Time Infrastructure (RTI)
2.2.2 The DIS Protocol
2.2.3 Protocol Independence
2.2.4 Obtaining Further Information about HLA and DIS
It is beyond the scope of the developers guide to fully describe DIS and HLA.

However, in this section we briefly describe them as a foundation for the concepts and terms discussed in the rest of this chapter.

2.2.1 The High Level Architecture (HLA)
HLA is required by the Department of Defense for use in all DoD simulations. In HLA, the types and formats of data to be exchanged among simulators are not standardized, as they are in DIS. Groups of simulators that want to play together must use the same Federation Object Model (FOM) and Run-Time Infrastructure (RTI). FOMs and RTIs are described in the next two sections.

2.2.1.1 The Federation Object Model (FOM)
Every federation execution requires a Federation Object Model (FOM), which defines the data model for the federation execution. Members of a federation execution can develop a FOM themselves, use an existing reference FOM, or build a FOM by starting with a reference FOM and modifying it.

A FOM is implemented through a Federation Execution Data (FED) file, which contains a subset of the FOM that is required by the RTI. VR-Link has extensive built-in support for the Real Time Platform Reference FOM (RPR FOM). More specifically, VR-Link supports the FOM defined within the FED file called VR-Link.fed, which is stored in the ./bin directory. VR-Link.fed represents the RPR FOM, plus a few extra classes that we have added.

The RPR FOM is a reference FOM developed by the SISO-sanctioned RPR FOM Standards Development Group, which consists of representatives from many companies that used the DIS protocol in the pre-HLA era.

The goal of the RPR FOM is to facilitate a priori interoperability (to about the extent available in DIS) among HLA simulations that choose to use it. In other words, if you use the RPR FOM (either as is, or with your own extensions), then you know that you will be able to interoperate with anyone else who chooses to use this FOM. An advantage of using the RPR FOM is that many simulation tools, including most VT MAK products, support this FOM.

Although VR-Link builds-in support only for the RPR FOM, it has features that allow you to work with new or modified FOMs and you can extend FOMs to meet your needs. The ability to work with a variety of FOMs is called FOM-agility.

You can configure VR-Link to work with other FOMs by using the VR-Link FOM Mapper to define mappings between VR-Link's protocol-independent interface and the objects, interactions, parameters, and attributes defined in the FOM.

For information about how VR-Link implements FOM-agility, please see 6 - FOM Agility. For a list of the RPR FOM versions supported by your version of VR-Link, please see VR-Link Release Notes. You can also view product version information on the MAK web site at http://www.mak.com/support/product-versions.html.

2.2.1.2 The Run-Time Infrastructure (RTI)
An RTI is an implementation of the HLA interface specification, that is, the services that make up the standard RTI application programmer's interface (API). An application can call the functions in the RTI's API either directly or through VR-Link. The HLA rules specify that federates must use the RTI to exchange all simulation data.

2.2.2 The DIS Protocol
The DIS protocol is a set of standards that govern how participating applications share information about a virtual world. The protocol specifies a set of packets, called Protocol Data Units (PDUs), that communicate this information. Each PDU identifies the sender and contains other information, depending on the PDU type. The DIS protocol also specifies when, and how frequently, PDUs are sent.

The table lists the DIS version numbers and their corresponding formal specifications.


DIS Versions
Version	Specification
0	Other
1	DIS PDU version 1.0 (May 1992)
2	IEEE 1278-1993
3	DIS PDU version 2.0 third draft (May 1993)
4	DIS PDU version 2.0 fourth draft (revised) (March16, 1994)
5	IEEE 1278.1-1995
6	IEEE 1278.1A-1998
7	IEEE 1278.1-2012 (DIS Evolved)
2.2.3 Protocol Independence
In this manual, the Protocol-Independent API refers to a set of classes that encompass most of the features of VR-Link and allow you to create applications that will work in both DIS and HLA without significant modification.

When you create a protocol-independent application, you do not create one executable that works with both protocols; you write one application and compile it for each protocol by specifying the protocol at compile time. In cases where a class uses different constructors or functions depending on the protocol, such as creating an exercise connection, you need to use #ifdef(s) so that your application compiles using the correct constructors.

2.2.4 Obtaining Further Information about HLA and DIS
The HLA 1.3 and IEEE 1516 specifications are copyrighted by their owners and MAK cannot distribute them to customers. You can get documentation for the RTI 1.3 and 1516 interface specifications at:

http://shop.ieee.org/store/ (IEEE 1516 specifications)
http://www.sisostds.org (SISO DLC HLA API 1516).
You can find general DIS information in the document library at the Simulation Interoperability Standards Organization (SISO) home page: http://www.sisostds.org/ProductsPublications/Standards.aspx

For the IEEE documentation of DIS, you can obtain the publications, IEEE Standard for Distributed Interactive Simulation, Application Protocols and Enumeration and Bit Encoded Values for Use with Protocols for DIS Applications at the IEEE World Wide Web site: http://shop.ieee.org/store/

Reference for Enumerations for Simulation Interoperability (SISO enumerations document) is also available at the SISO site.

Note
The URLs listed in this section were accurate at the time the manual was released. We cannot guarantee that they will be maintained in the future.

2.3 - A Conceptual Overview of VR-Link
Table of Contents
2.3.1 VR-Link's Protocol-Independent Classes
2.3.1.1 Protocol-Independent Object Management Classes
A simulator or other HLA/DIS application performs several tasks in order to interact with other players in a virtual world.

These tasks typically include:

Connecting to an exercise. The application must create an object through which it can send and receive simulation data. That object should provide an efficient way to direct incoming data to other parts of the application.
Managing state information. The application must inform other exercise participants about the states of its locally generated objects, such as entities, aggregates, transmitters, and so on. The application typically must receive, process, and manage state information about remote objects.
Managing information about events. The application must inform other participants about interactions such as collisions or fire/detonations involving a locally simulated entity, and receive and process events and interactions sent by other applications.
VR-Link provides classes that facilitate these tasks.

2.3.1 VR-Link's Protocol-Independent Classes
VR-Link provides the following categories of protocol-independent classes:

Exercise Connection – A class that serves as the application's interface to the RTI or to the DIS network.
Object management classes – Classes that maintain state information of local and remote objects, and handle the sending and receiving of state updates.
Interaction classes – Classes that provide a protocol-independent API to either HLA interactions or DIS PDUs that represent events.
VR-Link also provides protocol-specific classes and features. However, in most cases, your code does not need to interact directly with them.

To make the job of writing an application easier, VR-Link includes conversion routines, mathematical functions, and other useful functions. These are described in 13 - VR-Link Utility Classes and the vrlExamples page.

The figure shows how classes in a VR-Link application interact. Your application code can interact with classes at any level, and with the RTI or DIS network directly. However, for most applications, you can rely on the protocol-independent classes, which are generally easier to use. VR-Link utilities, such as the coordinate conversion utilities are also available to application code and VR-Link classes.

vrlinkappstructure.png
Structure of a typical VR-Link application
2.3.1.1 Protocol-Independent Object Management Classes
VR-Link provides a protocol-independent interface to various logical types of objects that are typically simulated in real-time platform-level simulations. For each logical type of object (entities, aggregates, transmitters, and so on), the following classes provide this interface:

An object publisher class, for example, DtEntityPublisher, which manages the sending of updates for a locally simulated object to the exercise through its DtExerciseConn. Object publishers are derived from DtObjectPublisher.
A reflected object class, for example, DtReflectedEntity, which represents a remote object. A DtReflectedEntity maintains the current state of the object based on updates received from the exercise through its DtExerciseConn. Reflected objects are derived from DtReflectedObject.
A reflected object list class, for example, DtReflectedEntityList, which keeps track of remote objects. It creates and destroys reflected objects based on information received from the exercise through its DtExerciseConn. Reflected object lists are derived from DtReflectedObjectList.
A state repository class, for example, DtEntityStateRepository, which is used by both publishers and reflected objects to store the state of the object they represent. State repositories are derived from DtStateRepository. DtEntityStateRepository and DtAggregateStateRepository are derived from a common class DtBaseEntityStateRepository. DtBaseEntityStateRepository is derived from the general base class DtStateRepository.
Below the protocol-independent interface are many lower-level objects that help manage objects in HLA. The lower-level objects are for the most part hidden by the higher-level interface and do not typically need to be used by application code directly. These lower-level objects are described in 5 - The HLA-Specific Interface.

2.4 - Connecting to an Exercise
VR-Link applications connect to an exercise through an exercise connection.

Exercise connections are implemented through the class DtExerciseConn. Higher level VR-Link classes use the DtExerciseConn to set and receive state information and other data. The member functions of DtExerciseConn allow an application to do the following:

Send interactions to the exercise
Read input from the network
Generate event IDs
Register callback functions that are executed each time VR-Link receives interactions and other input from the network
Manage the simulation clock.
For more information about exercise connections, please see 4.2 - Connecting to Exercises.

2.5 - Managing State Information
Table of Contents
2.5.1 Managing Locally Simulated Entities
2.5.2 Managing Remote Entities
A VR-Link application usually must maintain information about objects being simulated locally and communicate this information to other participants in an exercise.

The application must also obtain information about remote objects and represent them locally.

The figure illustrates how a VR-Link application manages state information. The elements of the figure are described in the remainder of this section. In a DIS exercise, locally simulated entities are included in the reflected entity list.

Note
In the remainder of this chapter, we talk about concepts primarily in the context of entities. However, most aspects of entity management apply to other objects, such as aggregates and transmitters, as well.

managingstateinformation.png
Managing State Information
2.5.1 Managing Locally Simulated Entities
Each locally simulated entity is represented by a DtEntityPublisher, which maintains state information in a DtEntityStateRepository. The DtEntityPublisher sends state update messages to the other exercise participants through the exercise connection. The previous figure illustrates a DtEntityPublisher sending information through an exercise connection. The DtEntityStateRepository class has functions that let you inspect the components of an entity's state and change its state.

The frequency with which your application sends updates to the exercise depends on your protocol.

In a DIS exercise, state updates are sent when the state of an entity changes and at regular intervals (heartbeats), regardless of whether there are any changes to the entity.

The HLA seeks to minimize unnecessary network traffic. Therefore in an HLA federation execution, state updates are sent only under the following conditions:

When update conditions (as specified by the FOM) have been met and a federate has subscribed to the entity attribute that changed. (Subscription is the process by which a federate tells the RTI that it wants to be notified about changes to an object.) The update condition for most attributes is any change since the attribute was last sent.
When a specific request for an update is received from another federate or the RTI.
For more information about managing local entities, please see 4.4 - Working with Entities.

2.5.2 Managing Remote Entities
A VR-Link application receives information about remote entities through the exercise connection. The function DtExerciseConn::drainInput() causes VR-Link to read and process input. VR-Link maintains a list of remote entities in a DtReflectedEntityList. Each entity known to the DtReflectedEntityList has a DtReflectedEntity to represent it. The DtReflectedEntity maintains the state of the entity in a DtEntityStateRepository. As with locally simulated entities, you can inspect the components of an entity's state. VR-Link also provides functions to track when entities join or leave an exercise.

The previous figure illustrates a DtReflectedEntityList and DtReflectedEntities.

For more information about remote entities, please see 4.6 - Working with Remote Entities.

Note
You may have noticed that the class names we use for managing entities reflect the terminology used by HLA, that is, publishing and reflecting. Although we use this terminology for our protocol-independent classes, for DIS, VR-Link sends the proper PDUs for state updates or interactions.

2.6 - Managing Information about Events
Table of Contents
2.6.1 Sending Local Interactions
2.6.2 Receiving Remote Interactions
We use the term interaction to refer to events such as the firing of a munition, detonation of a munition, or collision of entities.

VR-Link manages interactions through classes derived from DtInteraction. Usually, the name of an interaction class is based on the interaction type, for example, the class for a fire interaction is DtFireInteraction.

2.6.1 Sending Local Interactions
For locally-defined interactions, such as firing a munition from a locally simulated entity, you create an instance of the appropriate interaction class, set its values, and send it through the exercise connection. For more information, please see 4.3.1 Sending Interactions.

2.6.2 Receiving Remote Interactions
A VR-Link application receives notification of a remote interaction through its exercise connection. The function DtExerciseConn::drainInput() causes VR-Link to read and process input. The local application reacts through the use of callback functions.

There are no built-in functions for reacting to remote interactions. You must write a callback function for each type of interaction that you want to respond to and register the callback function with the interaction class. When your application is notified that an interaction event has occurred, it passes the interaction type and affected object to your callback function, which executes whatever code you have written. For information about callbacks, please see 2.7.3 Using Callbacks.

Note
Interactions are transient, that is, they are deleted by VR-Link immediately after the last callback function registered for the interaction is called.

2.7 - Other Simulation Concepts
Table of Contents
2.7.1 Managing Time
2.7.2 Identifying Objects
2.7.3 Using Callbacks
2.7.4 Coordinate Systems
2.7.5 Dead-Reckoning and Smoothing
2.7.6 Timestamps
This section describes how VR-Link implements the following simulation and programming concepts:

Time
Object identification
Callbacks
Coordinate systems
Dead-reckoning and smoothing
Time stamps.
2.7.1 Managing Time
The VR-Link toolkit maintains the concept of VR-Link simulation time for use in dead-reckoning of remote entities and thresholding of local entities. Typically, VR-Link simulation time is set once during each iteration of the application's main simulation loop so that all entities are dead-reckoned based on the same value of current time.

Usually, you will want to advance VR-Link simulation time each frame, in proportion to the amount of real time that has elapsed since the previous frame, so that it becomes a discrete approximation to (possibly scaled or offset) real time.

The class DtClock (defined in vlTime.h) implements a VR-Link simulation clock. DtClock has member functions such as setSimTime(), simTime(), and absRealTime(). Typically, you do not have to explicitly create an instance of DtClock, because the DtExerciseConn constructor creates one for you. A pointer to DtExerciseConn's clock is available through the clock() member function.

In a fixed frame rate application, like VR-Link's f18 example, VR-Link simulation time can be managed as follows:

DtTime dt = .05;                                // Each time step is .05 seconds
DtTime simTime = 0.0;                                 // Represents current time
DtClock* clock = exConn.clock();
...
// Main simulation loop
while(...)
{
// Tell VR-Link the current value of simulation time
   clock->setSimTime(simTime);
   ...
   // Do stuff
   ...
   // Advance simTime by dt
   simTime = simTime + dt;
   // Sleep till the next multiple of .05 seconds
   DtTime timeTillNextFrame = simTime - clock->elapsedRealTime();
   DtSleep(timeTillNextFrame);
}
In a floating frame rate application – where you go on to the next frame as soon as you are done with the previous one – you can pass the current time to setSimTime() each frame:

DtClock* clock = exConn.clock();
...
// Main simulation loop
while(...)
{
   clock -> setSimTime(clock -> absRealTime());
   ...
   // Do stuff
   ...
}
DtObjectPublishers and DtReflectedObjects use their DtExerciseConn's clock when performing dead-reckoning, thresholding, and so on. In rare cases where you are creating an instance of an entity or aggregate state repository yourself outside of the context of a publisher or reflected object, you will need to tell the repository what clock to use if you want dead-reckoning to occur properly. Do this using the repository's setClock() function.

For more information, please see 2.7.6 Timestamps.

2.7.2 Identifying Objects
One concept that HLA and DIS handle fairly differently is object identification.

In DIS, entities are identified by a triplet (site, application, entity) known as an Entity Identifier. Other types of objects are usually identified using the IDs of their host entities plus a single additional ID number.

In HLA, objects have several different identifiers, including:

An Object Handle, which is used within a federate to identify a particular object in an RTI service invocation
An Object Name, which is used within interactions and attribute updates exchanged among federates for the RPR FOM.
For more information about the various types of identifiers, and to see how VR-Link accounts for these differences, please see 4.7 - Identifying Objects.

2.7.3 Using Callbacks
Callback functions are functions that you write that enable your application to respond to events. You register a callback with VR-Link by passing a pointer to the function as an argument to a callback registration function. VR-Link calls your function in response to a specified event.

There are several places in VR-Link where callback functions are necessary to take advantage of certain functionality. For example, in order to process incoming interactions or DIS PDUs of a certain kind, a user registers an interaction callback or PDU callback with the appropriate VR-Link interaction class or PDU class. This is accomplished using the class's addCallback() static member function. Subsequently, whenever VR-Link reads that type of interaction or PDU from the RTI or DIS network, VR-Link calls your callback function, passing it a copy of the relevant interaction or PDU. In most cases, including this one, the callback gets called from within DtExerciseConn::drainInput() – the VR-Link function that causes input to be read from the exercise.

Other ways that callback functions are used in VR-Link include the following:

To respond to entity addition or removal: You can register an entity addition or entity removal callback with a DtReflectedEntityList. These functions will be called, also from within drainInput(), whenever we receive word from the exercise that a remote entity has joined or left the exercise.
For general purposes: A post-drain callback is a general callback function that can be registered with a DtExerciseConn. It is called from within drainInput(), regardless of what data has been read from the RTI or DIS network. These callbacks are executed after VR-Link finishes reading data and executes other, more specific callbacks.
Because callback functions are passed as regular function pointers to VR-Link's callback registration functions, the callback functions themselves cannot be non-static member functions of a class. They can be global (C-style) functions, or static class members. In order to have a non-static member function of a class be executed as a result of some VR-Link event, you can call the member function from within your callback.

VR-Link callback functions have strict function signatures, but most types of VR-Link callback functions have a trailing void* argument that is usually called usr. Corresponding callback registration functions also have a trailing usr argument. This lets you register an arbitrary pointer with VR-Link along with your callback function. When VR-Link executes your callback function, the pointer that you registered is passed to your function as usr.

Often, the usr argument passes a pointer to an object on which you want to call a member function. Simply cast usr back to the object's type within the callback. For example:

class MyObj
{
public:
   // The function we want to call.
   void someFunc();
   // A static member function to be registered as an interaction
   // callback with the DtFireInteraction class. When this function
   // is called by VR-Link, usr will contain a pointer to the object
   // passed to addCallback.
   static void theCallback(DtFireInteraction* inter, void* usr)
   {
      MyObjType* obj = static_cast<MyObjType *>(usr);
      obj->someFunc();
   }
};
int main()
{
   DtExerciseConn exConn(...);
   ...
   MyObj obj;
   // Register our callback function, passing a pointer to obj as usr.
   DtFireInteraction::addCallback(&exConn, MyObj::theCallback, &obj);
   ...
}
In cases where you want to pass more than one object to your callback, you must create a simple structure consisting of pointers to your objects, then pass a pointer to the structure as usr.

Note
Any pointer you pass as usr must be the address of a variable whose lifetime is at least as long as the period for which the callback function is registered.
2.7.4 Coordinate Systems
By default, DtEntityStateRepository works with geocentric coordinates. VR-Link has coordinate conversion routines that let you convert incoming and outgoing entity information to other coordinates systems. VR-Link also has coordinate views that allow you to use various coordinate systems without explicitly calling coordinate conversion routines. The view classes support:

UTM coordinates
Cartesian coordinates
Topographic coordinates.
For more information about views and coordinate conversion, please see 4.9 - Coordinate Views, and 13.3 - Coordinate Conversions.

2.7.5 Dead-Reckoning and Smoothing
To represent the behavior of entities in between state updates, VR-Link uses dead-reckoning, a process of estimating the location of an entity based on its acceleration and velocity. When updated location information arrives, VR-Link must move the simulated entity to its actual position. To ensure that transitions from an entity's dead-reckoned position to its actual position are not so abrupt as to be visually disconcerting, VR-Link implements smoothing. The figure illustrates the difference between a smoothed transition and a non-smoothed transition.

deadreckoning.png
Dead-reckoning and smoothing
For more information, please see 4.6.5 Dead-Reckoning.

2.7.6 Timestamps
When interactions or object state updates are sent through a DtExerciseConn using sendStamped(), a timestamp is sent with (or within) the message.

A DIS or RPR FOM timestamp indicates only a time (in seconds) past a particular hour at which the data in the message is supposed to be valid. However, it contains no information about what particular hour the sender had in mind. (DtPdu, DtInteraction, and DtStateMessage all have a member function called guessTimeValid() that makes a guess at the full time the sender had in mind by returning the time closest to a reference time such that the number of seconds past the hour equals the value specified in the timestamp.)

In addition to the timestamp, DIS and HLA RPR FOM messages contain a timestamp type indicator, which indicates a type of either "relative" or "absolute". Despite the confusion that these terms have generated in the DIS/HLA world, these terms only indicate whether or not the clock the sender used to obtain its timestamp is synchronized to some global exercise clock. A timestamp type of "absolute" means that the sender's clock is synchronized with the clocks of any other applications that claim to be using absolute timestamping. A timestamp type of "relative" means that the sender's clock is not necessarily synchronized with anyone else's clock.

Participants in a DIS or HLA exercise do not have to synchronize their clocks. In fact, in most exercises, clocks are not synchronized. If participants choose to synchronize their clocks, they do so using a method outside the scope of both DIS and HLA. (The HLA RTI has a set of time management services, but synchronizing clocks is not what they do.)

When a sender and a receiver are both using absolute timestamping, that is, their clocks are synchronized, the receiver can immediately make sense of the sender's timestamp. In this case, VR-Link uses the timestamp of incoming entity state updates in dead-reckoning calculations. If one or both are using relative timestamping, then the sender's timestamp is meaningless to the receiver unless he can determine the time difference between the two clocks (which is again, outside the context of DIS and HLA). In this case, like most DIS/HLA applications, we ignore the timestamp, and use the time of receipt in dead-reckoning calculations.

2.8 - Big and Little Endian Wire Formats
In rare cases, simulations may be forced to communicate with applications that use little endian rather than big endian wire formats.

VR-Link provides a mechanism for setting and inspecting the current wire format at runtime using the functions DtSetNetworkByteOrdering() and DtNetworkByteOrdering() (defined in vlNetTypes.h). Big endian is the default.

To use little endian byte ordering, call:

DtSetNetworkByteOrdering(DtLittleEndian);
To change it back to the default, call:

DtSetNetworkByteOrdering(DtBigEndian);

2.9 - Basic VR-Link Examples
Table of Contents
2.9.1 A Listen-Only Example
2.9.2.1 Connecting to An Exercise
2.9.1.2 Managing State and Interaction Information
2.9.1.3 Tracking Entities
2.9.1.4 Managing Time
2.9.1.5 Listening to the Network
2.9.2 A Send-Only Example
2.9.2.2 Managing Entities
2.9.2.3 Sending Interactions
2.9.2.4 Sending State Messages
This section lists and describes two simple VR-Link applications. The first is a listen-only application that observes an exercise without simulating any entity on the network. The second is a write-only program that does not process information about remote entities.

Note
The source code for both examples is included with VR-Link.
2.9.1 A Listen-Only Example
The Listen-Only is an application that just listens to the network. This application can be compiled for either DIS or HLA. The only protocol-specific code is contained in the #if statement that starts at line 27.

With each iteration of the loop, the program prints an entity's updated, dead-reckoned position in topographic coordinates. In addition, if a fire PDU or interaction is detected on the network, the program prints a message showing the entity ID of the attacker.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vlutil/vlProcessControl.h>
4  #include <vl/reflectedEntityList.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/reflectedEntity.h>
7  #include <vl/fireInteraction.h>
8  #include <vl/topoView.h>
9  #include <iostream>
10 
11 int keybrdTick(void);
12 
13 // Define a callback to process fire interactions.
14 void fireCb(DtFireInteraction* fire, void* /*usr*/)
15 {
16    std::cout << "Fire Interaction from " 
17          <<  fire->attackerId().string() << std::endl;
18 }
19 
20 int main(int argc, char** argv)
21 {
22    try
23    {
24       // Create a connection to the exercise or federation execution.
25       DtVrlApplicationInitializer appInit(argc, argv, "VR-Link Listen");
26 
27       #if DtDIS
28       appInit.setUseAsynchIO(true);
29       #endif
30 
31       appInit.parseCmdLine();
32 
33       DtExerciseConn exConn(appInit);
34 
35       // Register a callback to handle fire interactions.
36       DtFireInteraction::addCallback(&exConn, fireCb, NULL);
37 
38       // Create an object to manage entities that we hear about 
39       // on the network.
40       DtReflectedEntityList rel(&exConn);
41     
42       // Initialize VR-Link time.
43       DtClock* clock = exConn.clock();
44 
45       int forever = 1;
46       while (forever)
47       {
48          // Check if user hit 'q' to quit.
49          if (keybrdTick() == -1)
50             break;
51 
52          // Tell VR-Link the current value of simulation time.
53          clock->setSimTime(clock->elapsedRealTime());
54 
55          // Process any incoming messages
56          exConn.drainInput();
57 
58          // Find the first entity in the reflected entity list
59          DtReflectedEntity *first = rel.first();
60 
61          if (first)
62          {
63             // Grab its state repository, where we can inspect its data.
64             DtEntityStateRepository *esr = first->entityStateRep();
65 
66             // Create a topographic view on the state repository, so we 
67             // can look at position information in topographic
68             // coordinates.
69             double refLatitude  = DtDeg2Rad(  35.699760);
70             double refLongitude = DtDeg2Rad(-121.326577);
71             DtTopoView topoView(esr, refLatitude, refLongitude);
72    
73             // Print the position.
74             // Since it returns a DtString, we need to force it to 
75             // const char* with a cast.
76             std::cout << "Position of first entity: "
77                <<  topoView.location().string() << std::endl;
78          }
79       
80          // Sleep till next iteration.
81          DtSleep(0.1);
82       }
83       return 0;
84    }
85    DtCATCH_AND_WARN(std::cout);
86 }
87 
88 int keybrdTick()
89 {
90    char *keyPtr = DtPollBlockingInputLine();
91    if (keyPtr && (*keyPtr == 'q' || *keyPtr == 'Q')) 
92       return -1;  
93    else
94       return 0;
95 }
2.9.2.1 Connecting to An Exercise
In lines 22-25, the program creates an exercise connection (DtExerciseConn). This connection serves as the program's interface to an exercise. DtExerciseConn has several constructors. In this example, we create a DtVrlApplicationInitializer and pass it to the DtExerciseConn. Use of a DtVrlApplicationInitializer provides support for command line arguments. The default protocol-specific initialization values are set in the

DtVrlApplicationInitializer and its base class, DtExerciseConnInitializer. This is the only protocol-specific part of the code.

If you want to specify initialization values in the DtExerciseConn, you would use code similar to the following:

int main()
{
   // Create a connection to the exercise or federation execution
#if DtHLA
   DtString execName("VR-Link");
   DtString fedName("VR-Link listen"); 
   DtExerciseConn exConn(execName, fedName, new DtSimpleRprFomMapper);
#elif DtDIS
   int port           = 3000;
   int exerciseId     = 1; 
   int siteId         = 1;
   int applicationNum = 15;
   DtExerciseConn exConn(port, exerciseId, siteId, applicationNum,
                              0,             // No Status, any error will be fatal
                              true);            // use Async IO
#endif 
2.9.1.2 Managing State and Interaction Information
Applications based on VR-Link typically use callbacks to handle incoming interactions such as fire, detonations, and collisions. For example, a callback named fireCb is registered with the DtFireInteraction class at line 36. This callback (defined at line 14) prints a message containing the attacker ID. It executes whenever the exercise connection receives a Fire PDU or interaction during a call to drainInput().

2.9.1.3 Tracking Entities
We create a reflected entity list in line 40 to keep track of entities found on the network. The entity list tracks the arrival and departure of entities, performs dead reckoning, manages time outs, and performs other entity-tracking tasks.

2.9.1.4 Managing Time
On line 43 we obtain a pointer to the simulation clock from the exercise connection.

2.9.1.5 Listening to the Network
At the start of each iteration, the program sets VR-Link simulation time (line 53) to provide a common time value for use by time-related operations that occur within an iteration of the loop (such as the dead-reckoning of multiple entities).

The drainInput() call (line 56) reads and processes any messages arriving through the exercise connection. This call triggers the execution, if needed, of any callbacks you have registered for that exercise connection.

In line 59, the program finds the first entity in the entity list, then in line 64, retrieves the pointer to the entity's entity state repository. Line 71 creates a topographic view of that entity state repository, allowing us to retrieve its position data in topographic coordinates rather than geocentric. (Lines 69 and 70 hard code the coordinates for this example.)

Line 76 obtains and prints the dead-reckoned entity location.

2.9.2 A Send-Only Example
The Send-Only application simulates the flight of an F18 aircraft. The program begins by sending a fire PDU or HLA fire interaction. Thereafter, the F18 flies north for 10 seconds, updating its position by sending DIS entity state PDUs or HLA attribute updates.

1  #include <vl/exerciseConn.h>
2  #include <vl/exerciseConnInitializer.h>
3  #include <vl/topoView.h>
4  #include <vl/entityPublisher.h>
5  #include <vl/entityStateRepository.h>
6  #include <vl/fireInteraction.h>
7  #include <vl/iffPublisher.h>
8  #include <vlpi/EntityTypes.h>
9   #include <vlutil/vlProcessControl.h>
10 #include <iostream>
11 
12 int main(int argc, char** argv)
13 {
14 
15    try
16    {
17       // Create a connection to the exercise or federation execution.
18       DtVrlApplicationInitializer appInit(argc, argv "VR-Link talk");
19 
20       // Change some defaults
21       #if DtDIS
22       appInit.setUseAsynchIO(true);
23       #endif
24 
25       appInit.parseCmdLine();
26 
27       DtExerciseConn exConn(appInit);
28 
29       DtEntityType f18Type(DtPlatform, DtPlatformDomainAir,
30          DtUnitedStates, DtFighter, DtF18, 0, 0);
31 
32       // Create an entity publisher for the entity we are simulating.
33       DtEntityPublisher entityPub(f18Type, &exConn, DtDrDrmRvw,
34          DtForceFriendly, DtEntityPublisher::guiseSameAsType()); 
35 
36       // Hold on to the entity's state repository, where we can set data.
37       DtEntityStateRepository *esr = entityPub.entityStateRep();
38 
39       // Create a topographic view on the state repository, so we 
40       // can set position information in topographic coordinates.
41       double refLatitude  = DtDeg2Rad(  35.699760);
42       double refLongitude = DtDeg2Rad(-121.326577);
43       DtTopoView topoView(esr, refLatitude, refLongitude);
44    
45       // We can use the ESR to set state.
46       esr->setMarkingText("VR-Link");
47       topoView.setOrientation(DtTaitBryan(0.0, 0.0, 0.0));
48 
49       // Initialize VR-Link time.
50       DtClock* clock = exConn.clock();
51    
52       DtVector position(0, 0, -100);
53       DtVector velocity(20, 0, 0);
54 
55       // Send a Fire Interaction.
56       DtFireInteraction fire;
57       fire.setAttackerId(entityPub.globalId());
58       exConn.sendStamped(fire);
59    
60       // Main loop
61       DtTime dt = 0.05;
62       DtTime simTime = 0;
63       while (simTime <= 10.0)
64       {
65          // Tell VR-Link the current value of simulation time.
66          clock->setSimTime(simTime);
67 
68          // Process any incoming messages.
69          exConn.drainInput();
70 
71          // Set the current position information.
72          topoView.setLocation(position);
73          topoView.setVelocity(velocity);
74 
75          // Call tick, which insures that any data that needs to be 
76          // updated is sent.
77          entityPub.tick();
78       
79          // Set up for next iteration.
80          position[0] += velocity[0] * dt;
81          simTime     += dt;
82       
83          // Wait till real time equals simulation time of next step
84          DtSleep(simTime - clock->elapsedRealTime()); 
85       }
86    
87    }
88    DtCATCH_AND_WARN(std::cout);
89    return 0;
90 }
2.9.2.1 Connecting to An Exercise
Like the listen-only example, this program creates a DtExerciseConn to provide an interface to the RTI or DIS network (lines 17 through 27).

2.9.2.2 Managing Entities
Line 29 defines the entity type the F18 will use.

To be visible to other applications in the exercise, each locally-simulated entity requires a DtEntityPublisher, created in line 33. The entity publisher manages the generation of messages for this particular entity. It provides an entity state repository where you can set state values, and a tick() function, which causes state information to be sent to the network if necessary.

Line 37 sets up a pointer to the entity state repository, then line 43 creates a topographic view on that repository. This lets us set the entity's positional data using topographic coordinates, rather than the default geocentric coordinates. (Lines 41 and 42 hard code the coordinates for this example.) Line 46 shows an example of storing a non-positional state value in the repository.

2.9.2.3 Sending Interactions
An example of sending an interaction appears in lines 56-58. You can send the interaction using the exercise connection's sendStamped() function.

Note
You can use sendStamped() to send state updates, but it is preferable to let the entity publisher send state updates for you, using data in the entity state repository, as shown in lines 72 through 77.
2.9.2.4 Sending State Messages
The main loop executes twenty times per second for ten seconds. As in the listen-only example, this program sets simulation time at the start of each iteration (line 66).

Note
While this program's main purpose is to demonstrate the sending of data to the network, it is not a true send-only application. Incoming data is also processed with the drainInput() call on line 69. This call is required for HLA, because this is where we tick the RTI.
The program updates the F18's positional data in its entity state repository in lines 72 and 73, and ticks the entity publisher in line 77 to send the updated data onto the network. Lines 72 and 73 set topographic coordinates through a view, which VR-Link converts to geocentric coordinates.

Thereafter, the only remaining tasks are to increment the F18's position, increment the simulation time, and sleep until it is time to begin the next iteration.

3.1 - Compiling and Linking a VR-Link Application
Table of Contents
3.1.1 Libraries and Header Files
3.1.1.1 Using Microsoft Visual C++ 8 Express Edition
3.1.2 Third-Party Libraries
3.1.3 Compiling for a Particular Simulation Standard Under Linux
3.1.3.1 HLA
Compile Flags
Link Flags for HLA 1.3
Link Flags for HLA 1516
Link Flags for HLA Evolved
3.1.3.2 DIS
Compile Flags
Link Flags
3.1.4 Compiling for a Particular Protocol Version under Windows
3.1.4.1 When Compiling for HLA
3.1.4.2 Compiling for DIS
To build a VR-Link application, you must tell the compiler where to find the VR-Link header files (and for HLA, the RTI header files).

In addition, you must link with VR-Link's libraries (and for HLA, the RTI's libraries). If you are not using a C++ linker to link, you must explicitly link with C++ system libraries such as libC.so.

3.1.1 Libraries and Header Files
VR-Link consists of four libraries: mtl, vl, matrix, vlpi, and vlutil. The following versions of the vl library are provided:

Versions of the vl Library
Simulation standard	UNIX	Windows
HLA	libvlHLA13.so, libvlHLA1516.so, libvlHLA1516e.so	vlHLA13.lib, vlHLA1516.lib, vlHLA1516e.lib
DIS	libvlDIS.so	vlDIS.lib
On Windows:

The DLLs must be in your path.
You must add the C preprocessor definition: #DEFINE DT_USE_DLL = 1
3.1.1.1 Using Microsoft Visual C++ 8 Express Edition
Microsoft Visual C++ 8 Express Edition links against a different set of default libraries than Microsoft Visual Studio 2005 Professional does. Therefore, you might experience linking problems if you use Express Edition. If you have linking problems, add the following libraries to your link line:

user32.lib
gdi32.lib
winspool.lib
comdlg32.lib
advapi32.lib
shell32.lib
ole32.lib
oleaut32.lib
uuid.lib
odbc32.lib
odbccp32.lib.
3.1.2 Third-Party Libraries
VR-Link uses the third-party libraries libXml2, boost, and iconv. If you are building a VR-Link application, you must include them on your link line. The libXml2 library is part of the Red Hat Linux distribution. It is distributed with VR-Link for all other operating systems. For details about boost, please go to http://www.boost.org.

3.1.3 Compiling for a Particular Simulation Standard Under Linux
To build a VR-Link application for Linux using MAK's build system, you must use gmake 3.81 or later. You can download it from http://savannah.gnu.org/projects/make/

You can select DIS or HLA at compile time by using the flags described in the following sections. vlhome represents your VR-Link home directory.

The order of the libraries in the link line is significant. For more information, please see the Makefiles in ./examples.
Other flags may be required on some platforms. For more information, please see the example makefiles and release notes.
3.1.3.1 HLA
After you install VR-Link, create a symbolic link called RTI in the top level VR-Link directory. Point the link to the RTI distribution that you are using.

Compile Flags
-I{VLHOME}/include (VR-Link headers)

-I{VLHOME}/RTI/include (path to MAK RTI include directory)

-DDtHLA=1 for conditional compilation)

-DDtHLA_1516=1 Use only if compiling for IEEE 1516 - 2000.

-DDtHLA_1516_EVOLVED=1 Use only if compiling for IEEE 1516 - 2010 (HLA Evolved).

Link Flags for HLA 1.3
-lvrhome/lib -lvl -lvlHLA13 -lmatrix -lmtl -lvlutil -lxml2 -lRTI-NG -lfedtime
Link Flags for HLA 1516
-Lvrhome/lib -lvl -lvlHLA1516 -lmatrix -lmtl -lvlutil -lxml2 -lrti1516 -lfedtime1516
Link Flags for HLA Evolved
-Lvrhome/lib -lvl -lvlHLA1516e -lmatrix -lmtl -lvlutil -lxml2 -lrti1516e -lfedtime1516e
3.1.3.2 DIS
The compile and link flags for DIS are:

Compile Flags
-Ivlhome/include (VR-Link headers)

-DDtDIS=1 (for conditional compilation)

Link Flags
-Lvlhome/lib -lvl -lmtl -lvlDIS -lmatrix -lvlutil -lxml2
3.1.4 Compiling for a Particular Protocol Version under Windows
Under Windows, you can set your program's protocol following the procedures in this section. You need to provide build settings in Microsoft Developer Studio to define constants and specify paths for header files and RTI libraries.

VR-Link includes project files for DIS and the three HLA versions. If you are building for HLA, make sure to point to the correct location of the RTI include and library directories. The default is to use the value in the MAK_RTIDIR environment variable.

Note
In addition to linking with netapi.lib and WS2_32.lib, you must link with comctl32.lib, libxml2.lib, iphlpapi.lib, and iconv.lib. For details, please see the sample project files.
3.1.4.1 When Compiling for HLA
Choose Project -> Properties, then select the C/C++ folder.
Enter the following #define symbols in the space provided for preprocessor definitions:

DtHLA=1, DtHLA_1516=1, RTI_USES_STD_FSTREAM=1
In the C/C++ -> General section, in the space provided for additional include libraries, enter your VR-Link include path and the path to your RTI include directory, for example:

../../include, "c:/MAK/MakRti4.0.1/include"
or:

$(MAK_VRLDIR)/include, $(MAK_RTIDIR)/include
Note
The relative pathnames in this procedure (for example, ../../include) are relative to the project .vcproj file in the ./examples/f18 directory of the default VR-Link installation. The full path would be similar to C://MAK/VR-Linkx.x/include.
Select the Linker folder.
In the Linker -> Input section, in the space provided for additional dependencies, enter the appropriate RTI, VR-Link and Visual C++ library files, for example:

{libRTI-NG.lib | librti1516.lib | librti1516e.lib} {libfedtime.lib | libfedtime1516.lib | libfedtime1516e.lib} vl.lib vlutil.lib 
mtl.lib matrix.lib {vlHLA13.lib | vlHLA1516.lib | vlHLA1516e.lib} netapi32.lib WS2_32.lib comctl32.lib iphlpapi.lib 
libxml2.lib iconv.lib
Also, make sure you list the appropriate paths to these files in the "Additional Library Directories" box in the Linker -> General section, for example:

$(MAK_VRLDIR)/lib, $(MAK_RTIDIR)/lib
3.1.4.2 Compiling for DIS
In the C/C++ -> General section, in the space provided for additional include libraries, enter your VR-Link include path, for example:

../../include
In the Linker -> Input section, enter the appropriate VR-Link and Visual C++ library files, for example:

vlutil.lib mtl.lib matrix.lib vl.lib vlDIS.lib netapi32.lib WS2_32.lib iphlpapi.lib comctl32.lib
Also, make sure you list the appropriate paths to these files in the "Additional Library Directories" box in the Linker -> General section, for example:

../../lib

3.2 - Using VR-Link from C
Table of Contents
3.2.1 Calling C++ from C
3.2.2 Calling C from C++
3.2.3 Header Files that are Included by C and C++
The directory .

/examples/simpleC contains an example of using VR-Link with an application written in C. The example is a C version of the listen-only program described in 2.9.1 A Listen-Only Example. For details, please see the header files interface.h and simpleC.h.

3.2.1 Calling C++ from C
Since VR-Link is a C++ toolkit, any code that directly calls a VR-Link function must be compiled by a C++ compiler. You can compile this code in such a way that it may be called from C. To do so, you need at least one C++ file from which all calls to VR-Link functions can be made. In our example, the file interface.cxx serves this purpose. It contains several functions that interact with VR- Link code: initVRLink(), tickVRLink(), and firstEntityPosition().

To alert the C++ compiler that these functions should be compiled to be callable from C, their declarations are surrounded by the following keywords, as seen by the C++ compiler:

extern "C" {
}
The file listenC.c represents the rest of the application. It is compiled by a C compiler, and does not directly call any VR-Link functions. It does, however, call the functions defined in interface.cxx that were compiled to be called from C.

3.2.2 Calling C from C++
You can create a C++ function that interfaces with VR-Link code and can also call C functions. For example, in interface.cxx, the callback on Fire PDUs (fireCb) is a C++ function which calls the C function firePrint().

To alert the C++ compiler that an external function is a C function, its declaration is surrounded by the following keywords, as seen by the C++ compiler:

extern "C" {
}
3.2.3 Header Files that are Included by C and C++
When C and C++ code interact, the declarations of many of the same functions must be included by both C and C++ code. As described above, these declarations need to be surrounded by:

extern "C" {
}
when presented to the C++ compiler. However, these keywords are meaningless to a C compiler, so that they should always be surrounded by:

#ifdef __cplusplus
#endif
For example, listenC.h reads as follows:

#ifdef __cplusplus
extern "C" {
#endif
void firePrint(const char *attacker);
#ifdef __cplusplus
}
#endif

3.3 - Delivering VR-Link Applications to Users
A VR-Link developer's license allows you to compile applications using the VR-Link libraries and run one such application.

After you have developed an application that uses the VR-Link libraries, you may need to deliver that application to an internal or external customer. The end user of the application needs a VR-Link run-time license to use it. The customer does not need the entire VR-Link toolkit, nor do they need a developer's license (unless they need to recompile the application). They just need the application, the VR-Link libraries, the license management files, and a run-time license for each instance of the application that will be run. You should not provide the header files.

You can purchase a run-time license for your customer or have the customer purchase the license from MAK, depending on the arrangements you have made.

